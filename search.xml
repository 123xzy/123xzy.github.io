<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字节跳动 面试 复盘]]></title>
    <url>%2F2019%2F05%2F17%2F%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E9%9D%A2%E8%AF%95-%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[一面凉！ 题目1.项目2.Https和http3.302和303状态码4.MySQL的主键索引和非主键索引，为什么要这么做5.10g的文件，1g的内存，找重复的数字6.接上题，找重复次数最高的数字7.单链表快速排序8.url的执行流程，涉及哪些协议9.InnoDB和MyISAM的区别10.Ctrl+C之后的流程11.进程通信的方式，哪种方式更快 反思面试之前，紧张了好一阵子。面试结束，不知道是不是安慰我，面试官甚至给出了积极的评价，让我误以为能进入一面，还是太天真。后来回顾了自己面试时候的表现，表现确实不是一般的糟糕！很多时候都是在表示自己是在猜测问题的答案，而且回答问题的时候都是很粗略，一点都不详细，就像面试官所说，很多时候都是在靠记忆在作答，而不是靠自己的理解。 多去想想为什么这么做，而不是靠记忆！]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《The Go Programming Language》]]></title>
    <url>%2F2019%2F04%2F21%2F%E3%80%8AThe-Go-Programming-Language%E3%80%8B%2F</url>
    <content type="text"><![CDATA[为了解决在21世纪多核和网络化环境下越来越复杂的编程问题而发明了Go语言。Go语言是从Ken Thompson发明的B语言、Dennis M. Ritchie发明的C语言逐步演化过来的，是C语言家族的成员，因此很多人将Go语言称为21世纪的C语言。纵观这几年来的发展趋势，Go语言已经成为云计算、云存储时代最重要的基础编程语言。 但是它不仅仅是一个更新的C语言。它还从其他语言借鉴了很多好的想法，同时避免引入过度的复杂性。 Go语言中和并发编程相关的特性是全新的也是有效的，同时对数据抽象和面向对象编程的支持也很灵活。 Go语言同时还集成了自动垃圾收集技术用于更好地管理内存。 https://books.studygolang.com/gopl-zh/ https://golang.org/ 学习一门新语言时，会有一种自然的倾向, 按照自己熟悉的语言的套路写新语言程序。学习Go语言的过程中，请警惕这种想法，尽量别这么做。 Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。Go语言提供的工具都通过一个单独的命令go调用，go命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。 go build xxx生成可执行文件 Go语言编译过程没有警告信息 Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析 os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量 每次循环迭代，range产生一对值；索引以及在该索引处的元素值 初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。12s := &quot;&quot;var s string dup的前两个版本以”流”模式读取输入 数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。 一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。 数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。 内置的append函数可能使用比appendInt更复杂的内存扩展策略。因此，通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量 Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。 1.传播错误任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。内置的error是接口类型。有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。2.重新尝试失败：错误的发生是偶然性的，或由不可预知的问题导致的。3.输出错误信息并结束程序4.输出错误信息就足够了，不需要中断程序的运行5.直接忽略掉错误 在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。 函数类型的零值是nil。调用值为nil的函数值会引起panic错误。函数值可以与nil比较，但是函数值之间是不可比较的，也不能用函数值作为map的key。]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter 5]]></title>
    <url>%2F2019%2F04%2F17%2FPearls-Chapter-5%2F</url>
    <content type="text"><![CDATA[第一章讲述了如何通过深入挖掘定义正确的问题；第二、三章讲述如何选择算法和数据结构去平衡真正的需求；第四章则通过程序验证技术来确定程序的正确性；而这一章讲了如果实际的编写代码并测试 当我们经过分析、理论验证程序之后，就要亲手编写程序。程序写完不代表结束，还要花费一定时间，来编写脚手架（scaffolding）来测试代码，并了解运行时间 断言既可以用来指导程序代码的开发，也可以用来判断程序的正确性。assert(expression)的作用是计算表达式expression，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用abort来终止程序运行通过编写自动测试程序计时工具，使得每次改动实验之后都能使得程序达到预期的性能。]]></content>
      <tags>
        <tag>编程珠玑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《怎样解题》]]></title>
    <url>%2F2019%2F04%2F17%2F%E3%80%8A%E6%80%8E%E6%A0%B7%E8%A7%A3%E9%A2%98%E3%80%8B%2F</url>
    <content type="text"><![CDATA[虽然副标题是数学思维的新方式，但书中所讲对于在其他任何领域中怎样进行正确思维都有明显的指导作用。]]></content>
      <tags>
        <tag>数理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Chapter 5]]></title>
    <url>%2F2019%2F04%2F15%2FMIT-6-828-book-xv6-Chapter-5%2F</url>
    <content type="text"><![CDATA[任何操作系统都可能使用比计算机的处理器数量更多的进程运行，因此需要一个计划来在进程之间分配处理器的时间。理想情况下，共享对用户进程是透明的。一种常见的方法是为每个进程提供一种错觉，即它有自己的虚拟处理器，并在单个物理处理器上使操作系统复用多个虚拟处理器。本章说明xv6如何在多个进程之间多路复用处理器。 MIT 6.828 Operating System Engineering MultiplexingXv6多路复用方法在两种情况下，会将处理器从一个进程切换到另一个进程。第一种当进程等待设备或管道I/O完成，或等待子进程退出，或在sleep系统调用中等待时，xv6的sleep和wakeup机制会进行切换。第二种，当进程执行用户指令时，xv6会定期强制切换。这种多路复用会造成每个进程都有自己的CPU的错觉，就像xv6使用内存分配器和硬件页表创建每个进程都有自己的内存的错觉一样。 实现多路复用带来了一些挑战。首先，如何从一个进程切换到另一个进程？Xv6使用上下文切换的标准机制；虽然想法很简单，但实现是系统中一些最不透明的代码。其次，如何透明地进行上下文切换？Xv6使用计时器中断处理程序来驱动上下文切换的标准技术。第三，许多CPU可能同时在进程之间切换，并且需要一个锁定计划来避免竞争。第四，当进程退出其内存，并且必须释放其他资源时，它本身无法执行所有这些操作，因为（例如）它无法在使用它的同时释放自己的内核堆栈。Xv6试图尽可能简单地解决这些问题，但结果代码是棘手的（tricky）。 xv6必须为进程之间的协调提供方法。例如，父进程可能需要等待其子进程之一退出，或者读管道的进程可能需要等待其他进程来写管道。Xv6允许进程放弃CPU并sleep去等待事件发生，并允许另一个进程wakeup第一个进程，而不是通过反复检查所需的事件来浪费CPU。需要注意避免导致事件通知丢失的竞争。作为这些问题及其解决方案的一个例子，本章将研究管道的实现。 Code: Context switching如图5-1所示，要在进程之间切换，xv6在较低的级别上执行两种上下文切换：从进程的内核线程到当前CPU的调度线程，从调度线程到进程的内核线程。xv6永远不会直接从一个用户空间进程切换到另一个用户空间进程；这种情况是通过用户-内核转换（系统调用或中断）、上下文切换到调度程序、上下文切换到新进程的内核线程以及陷阱返回来实现的。在本节中，我们将举例说明在内核线程和调度线程之间切换的机制。 正如我们在第2章中看到的那样，每个xv6进程都有自己的内核堆栈和寄存器集。每个CPU都有一个单独的调度线程，用于在执行调度时使用，而不是任何进程的内核线程。从一个线程切换到另一个线程涉及保存旧线程的CPU寄存器，以及还原以前保存的新线程寄存器；保存并还原%esp和%eip 这意味着CPU将切换堆栈并切换它正在执行的代码。 swtch不直接了解线程；它只是保存和恢复寄存器集，称为上下文。当进程放弃CPU时，进程的内核线程将调用swtch保存自己的上下文并返回到调度程序上下文。每个上下文都由struct context*表示，这是指向存储在所涉及的内核堆栈上的结构的指针。Swtch采用两个参数：struct context **old和struct context *new。它将当前CPU寄存器推送到堆栈上，并将堆栈指针保存在*old。然后swtch将new复制到%esp，弹出以前保存的寄存器，然后返回。 让我们跟随用户进程返回，而不是按照调度程序进入swtch。我们在第3章中看到，每个中断结束时的一种可能性是trap调用yield。Yield调用sched，其调用swtch在proc-&gt;context中保存当前上下文，并切换到以前保存在cpu-&gt;scheduler（2766）中的调度上下文。 Swtch（2952）首先将其参数从堆栈加载到寄存器%eax和%edx（2959-2960）；swtch必须在更改堆栈指针之前执行此操作，并且不能再通过%esp访问参数。然后swtch推送寄存器状态，在当前堆栈上创建上下文。只有callee-save的寄存器需要保存；x86上的约定是，这些寄存器是%ebp、%ebp、%esi、%epp和%esi。Swtch显式推送前四个寄存器（2963-2966）；它隐式地将保留最后一个寄存器作为struct context*写入*old。还有一个更重要的寄存器：程序计数器%eip是由调用swtch的call指令保存的，并且在堆栈上就在%ebp之上。保存了旧上下文后，swtch已准备好还原新上下文。它将指向新上下文的指针移动到堆栈指针（2970）中。新堆栈的形式与刚才离开的旧堆栈相同（新堆栈是以前调用swtch时的旧堆栈），因此swtch可以反转序列以还原新的上下文。它弹出%edi、%esi、%ebx和%ebx的值，然后返回（2973-2977）。因为swtch更改了堆栈指针，所以还原的值和返回的指令地址是新上下文中的值。 在我们的示例中，sched调用swtch以切换到cpu-&gt;scheduler，即每个cpu调度上下文。调度程序对swtch（2728）的调用保存了该上下文。当我们一直在跟踪返回的swtch时，它并不是返回到sched而是scheduler，它的堆栈指针指向当前CPU的调度程序堆栈，而不是initproc的内核堆栈。 Code: Scheduling上一节研究了swtch的低级细节；现在让我们以swtch作为给定的，并检查从进程切换到调度程序和返回进程所涉及的约定。想要放弃CPU的进程必须获取进程表锁ptable.lock，释放它所持有的任何其他锁，更新其自己的状态（proc-&gt;state），然后调用sched。Yield（2772）遵循这一惯例，sleep和exit也是如此，我们稍后将对此进行研究。Sched再次检查这些条件（2757-2762）并提示这些条件：如果持有锁，CPU运行时要禁用中断。最后，sched调用swtch将当前上下文保存在proc-&gt;context中，并切换到cpu-&gt;scheduler中的调度器上下文。Swtch在调度程序的堆栈上返回，就像调度程序的swtch返回（2728）一样。调度程序继续for循环，找到要运行的进程，切换到它，并循环重复。 我们刚刚看到，xv6在调用swtch期间持有ptable-lock：swtch的调用方必须已经持有锁，并且对锁的控制传递到可切换到（switched-to）代码。这种惯例是不寻常的锁；典型的约定是获取锁的线程也负责释放锁，这使得对正确性的推理变得更加容易。对于上下文切换，有必要打破典型的约定，因为ptablel.lock保护在swtch中执行时进程状态和上下文字段上不正确的不变量。如果在swtch期间没有持有ptable.lock，则可能会出现一个问题的示例：在yield将其状态设置为RUNNABLE之后，但在swtch导致其停止使用自己的内核堆栈之前，不同的CPU可能会决定运行该进程。结果将是在同一堆栈上运行两个CPU，这不可能是正确的。 内核线程总是以一种方式放弃其处理器，并且总是切换到调度程序中的同一位置，该调度程序（几乎）总是以一种方式切换到一个进程。因此，如果要打印出xv6切换线程的行号，则会观察到以下简单模式：（2728）、（2728）、（2728）、（2728）等。在两个线程之间进行这种程式化切换的过程有时被称为coroutines；在本例中，sched和scheduler是彼此的co-routines。 有一种情况是，调度程序对新进程的swtch最终不会出现分裂。我们在第2章中看到了这种情况：当一个新的进程首次被安排时，它从forkret（2783）开始。Forkret的存在只是为了通过释放pt.lock 来遵守这个惯例；否则，新的过程可能从trapret开始。 调度程序（2708）运行一个简单的循环：找到要运行的进程，运行它，直到它停止，重复。调度程序对其大多数操作都持有ptable.lock，但在其外部循环的每次迭代中都会释放一次锁（并显式启用中断）。这对于此CPU处于空闲状态的特殊情况非常重要（找不到RUNNABLE进程）。如果一个闲置的调度程序循环着连续持有的锁，任何其他运行进程的CPU都不能执行上下文切换或任何与进程相关的系统调用，特别是永远不能将进程标记为RUNNABLE，从而使得闲置CPU脱离调度循环（scheduling loop）。在闲置的CPU上定期启用中断的原因是，由于进程（例如shell）正在等待I/O，因此可能没有RUNNABLE进程；如果调度程序一直禁用中断，I/O将永远无法到达。 调度程序在进程表上循环查找可运行的进程，该进程具有p-&gt;state==RUNNABLE。一旦找到一个进程，它就会设置每个CPU当前进程变量proc，用switchuvm切换到进程的页面表，将进程标记为RUNNING，然后调用swtch开始运行它（2722-2728）。 考虑调度代码结构的一种方法是，它安排对每个进程强制执行一组不变量，并在这些不变量不正确时保留ptable-&gt;lock。一个不变量的是，如果一个进程是RUNNING，事情必须设置，以便计时器中断的yield可以正确地切换远离该进程；这意味着CPU寄存器必须保存进程的寄存器值（它们实际上不在上下文中），%cr3必须指向进程的页表，%esp必须指向进程的内核堆栈，以便swtch可以正确推入寄存器，并且proc必须指向进程的proc[]插槽。另一个不变因素是，如果进程是RUNNABLE，则必须设置操作，以便空闲CPU的调度程序可以运行它；这意味着p-&gt;context必须保存进程的内核线程变量，进程的内核堆栈上没有CPU执行，没有CPU的%cr3引用进程的页面表，并且没有CPU的proc 引用进程。 维护上述不变量是xv6在一个线程中获取ptable.lock（通常在yield中）并在另一个线程中释放锁的原因（调度程序线程或下一个内核线程）。一旦代码开始修改进程的状态为RUNNABLE，它必须保持锁，直到它完成还原不变量：最早的正确释放点是在调度程序停止使用进程的页面表并清除proc 之后。同样，一旦调度程序开始将可运行的进程转换为RUNNING，在内核线程完全运行之前（在swch之后，例如在yield），锁就无法释放。 ptable.lock也保护其他东西：进程ID和空闲进程表插槽的分配，exit和wait之间的相互作用，避免丢失wakeup的机制（见下一节），可能还有其他的东西。也许值得思考的是，为了清晰，也许也是为了性能，ptable.lock的不同功能是否可以拆分。 Sleep and wakeup调度和锁有助于隐藏一个进程对另一个进程的存在，但到目前为止，我们还没有帮助进程显式交互的抽象。Sleep和wakeup填补了这一空白，让一个进程sleep去等待一个事件，另一个进程在事件发生后将其wakeup。Sleep和wakeup通常被称为序列协调（sequence coordination）或条件同步机制（conditional synchronization），在操作系统文献中还有许多类似机制。 为了说明我们的意思，让我们考虑一个简单的生产者/使用者队列（producer/consumer queue）。此队列类似于将进程中的命令提供给IDE驱动程序的队列（请参阅第3章），但抽象出所有特定于IDE（ IDE-speciﬁc）的代码。队列允许一个进程向另一个进程发送非零指针。如果只有一个发送方和一个接收方，并且它们在不同的CPU上执行，并且编译器没有过于密集地优化，则此实现将是正确的：123456789101112131415161718192021struct q &#123;void *ptr;&#125;;void*send(struct q *q，void *p)&#123;while(q-&gt;ptr != 0);q-&gt;ptr = p;&#125;void*recv(struct q *q)&#123;void *p;while((p = q-&gt;ptr) == 0);q-&gt;ptr = 0;return p;&#125; Seed循环，直到队列为空（ptr == 0），然后将指针p放入队列中。Recv循环，当队列为非空时，将指针取出。在不同进程中运行时，send和recv都修改了q-&gt;ptr，但只在指针为零时send写入指针，而在指针为非零时recv才写入指针，因此不会丢失任何更新。 上面的实现是昂贵的。如果发送方很少发送，接收方将把大部分时间花在希望得到指针的while循环中。如果接收方有一种方法可以放弃（yield）CPU，并且只在send发送指针时才会恢复，则接收方的CPU可以找到更高效的工作。 让我们想象一下一对调用，sleep和wakeup，工作如下。Sleep(chan)休眠在任意值chan上，称为等待通道（wait channel）。Sleep将调用进程置于sleep状态，释放CPU以完成其他工作。Wakeup(chan)wakeup在chan（如果有的话）上睡觉的所有进程，导致它们的Sleep调用返回。如果没有进程在等待 chan，wakeup就什么也做不到。我们可以更改队列实现以使用sleep和wakeup：123456789101112131415161718void*send(struct q *q，void *p)&#123;while(q-&gt;ptr != 0);q-&gt;ptr = p;wakeup(q); /* wake recv */&#125;void*recv(struct q *q)&#123;void *p;while((p = q-&gt;ptr) == 0)sleep(q); q-&gt;ptr = 0;return p;&#125; Recv现在放弃CPU而不是旋转（spinning），这很好。然而，事实证明，在不遭受所谓的”lost wake-up”问题的情况下，设计sleep和wakeup接口并不简单（参见图5-2）。假设recv在215行上找到那个q-&gt;ptr == 0。recv位于215行和216行时，send在另一个CPU上运行：它将q-&gt;ptr更改为非零，并调用wakeup，它不会发现任何进程处于sleep状态，因此不会执行任何操作。现在，recv继续在第216行执行：它调用sleep，然后进入sleep状态。这将导致一个问题：recv正在等待已到达的指针。下一个send将休眠，等待recv使用队列中的指针，此时系统将死锁。 此问题的根源在于，在q-&gt;ptr == 0时才会sleep这一不变量在错误的时刻运行的send违反。保护不变量的一种不正确的方法是修改recv的代码，如下所示：123456789101112131415161718192021222324252627struct q &#123;struct spinlock lock;void *ptr;&#125;;void*send(struct q *q，void *p)&#123;acquire(&amp;q-&gt;lock); while(q-&gt;ptr != 0);q-&gt;ptr = p;wakeup(q);release(&amp;q-&gt;lock);&#125;void*recv(struct q *q)&#123;void *p;acquire(&amp;q-&gt;lock);while((p = q-&gt;ptr) == 0)sleep(q); q-&gt;ptr = 0;release(&amp;q-&gt;lock);return p;&#125; 人们可能希望这个版本的recv能避免lost wakeup，因为锁可以防止在322行和323行之间执行send。它做到了这一点，但它也是死锁：recv持有锁当其在sleep，所以发送者将永远阻塞去等待锁。 我们将通过将锁传递到sleep来修复前面的方案，以便它可以在调用进程被标记为asleep并在sleep通道上等待之后释放锁。锁将强制并发send等待，直到接收者将自己置于sleep状态，这样wakeup就会找到sleep的接收者并将其wakeup。一旦接收者醒来，sleep在返回之前再次获得锁。我们新的正确方案如下：123456789101112131415161718192021222324252627struct q &#123;struct spinlock lock;void *ptr;&#125;;void*send(struct q *q，void *p)&#123;acquire(&amp;q-&gt;lock); while(q-&gt;ptr != 0) ; q-&gt;ptr = p;wakeup(q);release(&amp;q-&gt;lock); &#125; void*recv(struct q *q)&#123;void *p;acquire(&amp;q-&gt;lock);while((p = q-&gt;ptr) == 0)sleep(q，&amp;q-&gt;lock);q-&gt;ptr = 0;release(&amp;q-&gt;lock);return p;&#125; Recv持有q-&gt;lock的事实阻止send试图在recv检查q-&gt;ptr和它的sleep调用之间wakeup它。当然，接收进程必须在sleep时释放q-&gt;lock，以便发送方能够将其wakeup。因此，我们希望sleep以原子的方式释放q-&gt;lock，并将接收过程置于sleep状态。 完整的sender/receiver实现，当等待接收者使用以前send的值时，也会在send中休眠。 Code: Sleep and wakeup让我们来看看xv6中sleep和wakeup的实现。基本的想法是让sleep标记当前进程为SLEEPING，然后调用sched释放处理器；wakeup查找在给定的等待通道上休眠的进程，并将其标记为”RUNNABLE”。 sleep（2803）从一些理智检查开始：必须有一个当前进程（2803），sleep必须已通过锁（2808-2809）。然后sleep获得ptable.lock（2818）。现在，要休眠的进程持有ptable.lock和lk两把锁。在调用方中（在示例中，recv）中需要持有lk：它确保了任何其他进程（在示例中，一个正在运行的send）都不能调用wakeup(chan)。现在sleep持有ptable.lock，释放lk是安全的：其他进程可能会调用wakeup(chan)，但wakeup不会运行，直到它能够获得ptable.lock，所以它必须等到sleep完成，将进程设为休眠，防止wakeup错过sleep。 有一个小的复杂问题：如果lk等于&amp;ptable.lock，那么sleep当试图获取&amp;ptablek.lock，然后释放lk时，就会死锁。在这种情况下，sleep会考虑获取和释放以相互抵消，并完全跳过它们（2817）。例如，wait（2653）持有&amp;ptablek.lock并调用sleep。 现在，sleep持有ptable.lock，而不是其他人，它可以通过记录sleep通道（sleep channel），改变进程状态，并调用sched（2823-2825），使该进程进入sleep状态。 在某个时候，一个进程会调用wakeup(chan)。wakeup（2864）获取ptablel.lock和调用wakeup 1（其做真正的工作）。重要的是，wakeup持有ptablek.lock既是因为它在操纵进程状态，也是因为，正如我们刚才看到的，ptablek.lock确保sleep和wakeup不会相互错过。Wakeup1是一个单独的函数，因为有时调度程序需要执行wakeup，当它已经持有ptablek.lock；稍后我们将看到这方面的一个示例。Wakeu1（2853）在进程表上循环。当它发现一个进程处于具有匹配chan的状态时，它会将该进程的状态更改为RUNNABLE。下次运行调度程序时，它将看到进程已准备好运行。 在任何唤醒条件下，都必须在持有锁的时候调用wakeup；在上面的示例中，锁是q-&gt;lock。为什么sleep进程不会错过wakeup的完整论据是，在任何时候，从它检查条件之前，直到它处于sleep状态，它持有条件锁（the lock on the condition）或ptablel.lock或两者兼而有之。由于wakeup是在持有这两个锁的情况下执行的，因此wakeup必须在潜在的sleeper检查条件之前执行，或者在潜在的sleeper完成将自己置于sleep状态之后执行。 有时，多个进程在同一通道上休眠；例如，多个进程试图从管道中读取。一个简单调用就会把他们都唤醒。其中一个将首先运行，并获得调用sleep的锁，并（在管道的情况下）读取管道中等待的任何数据。其他进程会发现，尽管被wakeup，但没有数据可以读取。从他们的角度来看，这种wakeup是”虚假的”（spurious），他们必须再次休眠。因此，sleep总是在检查条件的循环中被调用。 sleep和wakeup的调用者可以使用任何相互方便的号码作为通道；实际上，xv6通常使用等待中涉及的内核数据结构的地址，如磁盘缓冲区。如果sleep/wakeup的两种使用不小心选择了相同的通道，则不会造成任何伤害：它们会看到虚假（spurious）的wakeup，但如上所述的循环会容忍此问题。sleep/wakeup的魅力在于它既轻量级（不需要创建特殊的数据结构作为sleep通道），并提供了间接层（调用者不需要知道他们正在与什么特定的进程交互）。 Code: Pipes我们在本章前面使用的简单队列是一个玩具，但xv6包含两个真正的队列，它们使用sleep和wakeup来同步读者和写者。一种是在IDE驱动程序中：进程将磁盘请求添加到队列中，然后调用sleep。中断处理程序使用wakeup来提醒进程其请求已完成。 一个更复杂的例子是管道的实现。我们在第0章中看到了管道的接口：写入管道一端的字节被复制到内核内部的缓冲区中，然后可以从管道的另一端读出。接下来的章节将检查围绕管道的文件系统支持，但现在让我们来看看pipewrite和piperead的实现。 每个管道都由一个结构pipe表示，其中包含一个lock和一个data缓冲区。字段nread和nread计数从缓冲区读取和写入缓冲区的字节数。缓冲区是环绕的：buf[PIPESIZE-1]后写入的下一个字节是buf[0]，但计数不会环绕。此约定允许实现区分完整缓冲区（nwrite == nwrite + PIPESIZE）和空缓冲区（nwrite == nread)，但这意味着索引到缓冲区中必须使用buf[nwrite%PIPESIZE]，而不仅仅是buf[nread]（类似地用于nwrite）。假设对piperead和pipewrite的调用在两个不同的CPU上同时发生。 Pipewrite（6530）从获取管道锁开始，其保护计数、数据及其关联的不变量。Piperead（6551）然后也尝试获取锁，但不能。它在acquire（1574）自旋等待锁。在piperead等待时，管道写入循环在被written—addr[0]、addr[1]、…、addr[n-1]上循环-依次将每个字节添加到管道中（6544）。在此循环中，可能会发生缓冲区溢出（6536）。在这种情况下，pipewrite调用wakeup去提醒任何处于sleep状态的读取者注意到有数据在缓冲区中等待，然后在&amp;p-&gt;nwrite上休眠，等待读取者从缓冲区中取出一些字节。sleep释放p-&gt;lock，作为使pipewrite进程进入sleep状态的一部分。 现在，p-&gt;lock可用了，piperead设法获得了它，并开始认真地运行：它发现p-&gt;nread ！= p-&gt;nwrite（6556）（pipewrite进入sleep状态，因为p-&gt;nwrite == p-&gt;nread+PIPESIZE（6536）），因此它陷入for循环，将数据复制出管道（6563-6567），并按复制的字节数增加nread。现在有许多字节可用于写入，因此piperead调用wakeup（6568），在它返回给调用方之前w唤醒任何处于sleep状态的写入这。wakeup发现一个进程正在&amp;p-&gt;nwrite上休眠，这个进程正在运行pipewrite，但在缓冲区溢出时停止。它将该过程标记为RUNNABLE。 管道代码为读取者和写入者使用单独的sleep通道（p-&gt;nread 和p-&gt;write）；这可能会使系统在不可能出现的情况下更有效率，因为有大量的读者和写者在等待相同的管道。管道代码休眠在检查sleep条件的循环中；如果有多个读者或写者，除了第一个醒来的过程外，其他人都会看到条件仍然是假的，然后再休眠。 Code: Wait，exit，and killsleep和wakeup可用于多种等待。看到第0章的一个有趣的示例是父进程用来等待子进程退出的wait系统调用。在xv6中，当子进程退出时，它不会立即死亡。相反，它切换到ZOMBIE进程状态，直到父进程调用wait去退出。然后，父进程负责释放与进程相关的内存，并准备结构proc进行重用。如果父进程在子进程之前退出，则init进程领养子进程并等待它，以便每个子进程之后都有一个父进程进行清理。请记住父进程和子进程之间wait和exit之间的竞争的可能性，以及exit和exit之间的竞争可能性。 wait从获取ptable.lock开始。然后，它扫描进程表，查找子进程。如果wait发现当前进程有子进程，但没有一个已退出，它调用sleep等待其中一个退出（2689），然后再次扫描。在这里，在sleep中释放的锁是ptable.lock，我们上面看到的特殊情况。 Exit获取ptable.lock，然后唤醒在与当前进程的父进程proc（2628）相等的等待通道上休眠的任何进程；如果有这样的过程，将是wait中的父进程。这看起来可能不成熟（premature），因为exit还没有将当前进程标记为ZOMBIE，但它是安全的：尽管wakeup可能会将父进程标记为RUNNABLE，但wait中的循环无法运行，直到exit通过调用sched进入调度程序中释放ptable.lock，因此wai只有在exi将退出进程的状态设置为ZOMBIE（2640）之后才能查找退出进程。在exit重新安排之前（reschedules），它将当前退出进程的子进程重新抚养，并将他们传给initproc（2630-2637）。最后，exit调用sched去放弃（relinquish）CPU。 如果父进程处于等待状态，调度程序最终将运行它。对sleep的调用返回时持有ptable.lock；wait重新扫描进程表，并找到state == ZOMBIE 的退出子进程（2666）。它记录子进程的pid，然后清理struct proc，释放与该进程相关的内存（2668-2676）。 子进程可以在exit过程中完成大部分清理工作，但重要的是父进程是释放p-&gt;kstack和p-&gt;pgdir的进程：当子进程运行exit时，它的堆栈位于分配为p-&gt;kstack的内存中，并且它使用自己的页表。只有在子进程最后一次完成运行后，才能通过调用swtch（通过sched）释放它们。这也是调度程序在其自己的堆栈上运行而不是在调用sched的线程堆栈上运行的原因之一。 虽然exit允许进程自行终止，但kill（2875）允许一个进程终止另一个进程。如果直接杀死受害者进程（destroy the victim process），kill将会过于复杂，因为受害者进程可能在另一个CPU上执行或在更新内核数据结构的中途处于sleep状态。为了应对这些挑战，kill只做了一点点：它只设置了受害者的p-&gt;killed，如果它处在休眠状态，就会唤醒他。最终，受害者将进入或离开内核，此时，如果设置了p-&gt;killed，trap中的代码将调用exit。如果受害者在用户空间中运行，它很快就会通过进行系统调用或由于计时器（或其他一些设备）中断而进入内核。 如果受害者过程处于sleep状态，wakeup的调用会导致受害者进程从sleep中返回。这是潜在的危险，因为正在等待的条件可能不正确。但是，xv6的sleep调用总是被包装在一个while循环中，该循环会在sleep返回后重新测试该条件。一些sleep调用也会在循环中测试p-&gt;killed，如果设置了p-&gt;killed，则放弃该活动。只有在这种放弃是正确的情况下，才会这样做。例如，如果设置了killed的标志，则管道读和写代码（6537）返回。最终代码将返回到trap，这将再次检查标志并退出。 一些xv6的sleep循环不会检查p-&gt;killed，因为代码位于应该是原子的多步骤系统调用的中间。IDE驱动程序（4279）就是一个示例：它不检查p-&gt;killed，因为磁盘操作可能是一组写入操作之一，这些写入操作都是文件系统保持在正确状态所必需的。为了避免部分操作后清理工作的复杂性，xv6将IDE驱动程序中的进程的终止延迟到稍后更容易终止该进程（例如，当整个文件系统操作已完成且进程大概率要返回到用户空间）。 Real worldXv6调度程序实现了一个简单的调度策略，该策略依次运行每个进程。此策略称为round robin（轮询调度）。实际操作系统实施更复杂的策略，例如，允许进程具有优先级。其想法是，调度程序将优先运行高优先级进程，而不是运行低优先级线程。这些策略可能很快变得复杂，因为通常存在相互竞争的目标：例如，操作可能也希望保证公平性和高吞吐量。此外，复杂的策略可能导致意想不到的互动，如优先倒置（priority inversion）和车队（convoys）。当低优先级和高优先级进程共享锁时，可能会发生优先级反转，即当低优先级进程获取锁时，可能会导致高优先级进程不运行。当许多高优先级的进程正在等待获得共享锁的低优先进程时，可以形成一个长车队；一旦车队组成，他们可以坚持很久时间。为了避免这类问题，在复杂的调度程序中需要额外的机制。 sleep和wakeup是一种简单有效的同步方法，但还有很多其他方法。所有这些问题的第一个挑战是避免我们在本章开头看到的”missed wakeups”问题。原来的Unix内核的sleep只是禁用中断，这就足以，因为Unix运行在单CPU系统上。由于xv6在多处理器上运行，因此它将显式锁定添加到sleep中。FreeBSD的msleep也采取了同样的方法。Plan’s 9的sleep使用回调函数（callback function），该函数在sleep前使用调度锁运行；该功能作为sleep状态的最后一分钟检查，以避免missed wakeups。Linux内核的sleep使用显式进程队列，而不是等待通道；队列有自己的内部锁。 在wakeup中扫描具有匹配chan整个进程列表效率低下。更好的解决方案是用一个数据结构来取代sleep和wakeup中的chan，该数据结构包含在该结构上休眠的进程列表。Plan’s 9的sleep和wakeup将这种数据结构称为rendezvous point或Rendez。许多线程库将相同的结构称为条件变量（condition variable）；在这种情况下，操作sleep和wakeup被称为wait和signal。所有这些机制都有相同的味道：sleep条件是由某种锁定在sleep过程中原子下降保护。 wakeup的实现唤醒了在特定通道上等待的所有进程，并且可能存在许多进程正在等待该特定通道的情况。操作系统将安排所有这些进程，他们将争先恐后地检查sleep状态。以这种方式运行的进程有时被称为雷鸣般的羊群（thundering herd），这最好避免。大多数条件变量都有两个wakeup的原语（primitives）：信号（signal），它唤醒一个进程，广播（broadcast），它唤醒等待的所有进程。 信号量（Semaphores）是另一种常见的协调机制。信号量是一个整数值，具有两个运算，递增和递减（或上下）。总是可以增加信号量，但信号量值不允许下降到零以下：零信号量的递增将休眠，直到另一个进程递增信号量，然后这两个操作取消（cancel out）。整数值通常对应于实际计数，例如管道缓冲区中可用的字节数或进程所具有的僵死子进程。使用显式计数作为抽象的一部分可以避免”missed wakeup”问题：有一个记录已发生的wakeup的数量的显式计数。计数值还避免了虚假的wakeup和雷鸣般的羊群（thundering herd）问题。 终止进程并对其进行清理会给xv6带来很大的复杂性。在大多数操作系统中，它更加复杂，因为受害者进程可能在内核深处休眠，并且展开（unwinding）其堆栈需要非常仔细的编程。许多操作系统使用显式机制（如longjmp）来展开堆栈。此外，还有其他事件可能会导致休眠进程被唤醒，即使它正在等待的事件还没有发生。例如，当进程处于休眠状态时，另一个进程可能会向其发送信号。在这种情况下，进程将从中断的系统调用返回，其值为-1，错误代码设置为EINTR。应用程序可以检查这些值并决定要执行的操作。Xv6不支持信号，这种复杂性也不会出现。 Xv6对kill的支持并不完全令人满意：有一些sleep循环可能应该检查p-&gt;killed。一个相关的问题是，即使是检查p-&gt;killed的sleep循环，sleep和kill之间也有竞争；后者可能会设置p-&gt;killed，并试图在受害者的循环检查p-&gt;killed之前，但在它调用sleep之前唤醒受害者。如果出现此问题，则在等待情况发生之前，受害者不会注意到p-&gt;killed。这可能会稍晚（例如，当IDE驱动程序返回受害者正在等待的磁盘块时）或永远不会（例如，如果受害者正在从控制台的输入中等待，但用户不键入任何输入）。 Exercises Sleep has to check lk != &amp;ptable.lock to avoid a deadlock (2817-2820). It could eliminate the special case by replacingif(lk != &amp;ptable.lock){ acquire(&amp;ptable.lock); release(lk); }withrelease(lk); acquire(&amp;ptable.lock);Doing this would break sleep. How? Most process cleanup could be done by either exit or wait，but we saw above that exit must not free p-&gt;stack. It turns out that exit must be the one to close the open ﬁles. Why? The answer involves pipes. Implement semaphores in xv6. You can use mutexes but do not use sleep and wakeup. Replace the uses of sleep and wakeup in xv6 with semaphores. Judge the re Fix the race mentioned above between kill and sleep，so that a kill that occurs after the victim’s sleep loop checks p-&gt;killed but before it calls sleep results in the victim abandoning the current system call. Design a plan so that every sleep loop checks p-&gt;killed so that，for example，a process that is in the IDE driver can return quickly from the while loop if another kills that process.]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重新定义公司》]]></title>
    <url>%2F2019%2F04%2F14%2F%E3%80%8A%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%85%AC%E5%8F%B8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[之前看过一本企业管理的书《基业长青》，当时年纪小，没有什么感觉。倒是这本书带我走进了管理学的大门。 书中讲述了两方面映象深刻：创意精英和对团队、公司的管理。 创意精英对Google打心底喜欢，因为其宣扬的文化和自身如此契合，希望有朝一日能去Google工作，哪怕是参观也行 文中对创意精英的定义 不仅拥有过硬的专业知识，懂得如何使用专业工具，还需具备充足的实践经验 分析头脑，善于利用数据做决策，也懂得数据的误导性 商业头脑，他们知道专业技术、优质产品和商业成功环环相扣 竞争头脑，他们的撒手锏源自创新，能以不同的视角看问题，但他们也离不开实干。即使在工作之余也不停止前进的脚步 用户头脑，他们甚至比用户或消费者更懂得对产品的看法 充满好奇，绝不满足于守常不变，善于发现问题，并自信自己能解决它 喜欢冒险，不惧怕失败，他们相信能从失败中挖掘宝贵的财富 自制主动，注重自己的信念，并依据自己的理念主动行动 心态开放，看中的是构思或结论的价值，而不是出处 一丝不苟，因为他们对知识熟谙于心，因此对细节掌握精确、如数家珍 善于沟通，风趣幽默，气场十足，魅力四射 显然，创意精英是全才，一定具有成长型思维，懂得不断学习，绝不是偏才。就像我在一则视频中看到的一句话：“Don’t be a programmer,be a problem solver.”，不要让自己沦为代码的工具，而是利用自己的广阔视野和才能，去发现问题，分析问题，并解决问题。无脑的低头码代码，只会沦为平庸。 其实自己一直在思考一个问题：如何和周围的人区别开来？之前会去寻找独特的技能来标榜自己，例如学习高深的技术。现在想想，最具竞争力的能力其实是“虚无”，这么说也是不太准确，用“创新”两个字来形容可能更好一些。这种能力是从心底深处发出的力量，能去找到现有的漏洞，并打破、解决它的一种能力。 每一个变化，都是由一小撮坚定不移，自动自发的创意精英促成的。未来社会最有价值的人，是以创造力、洞察力、对客户的感知力为核心特征的。 团队管理如果说创意精英这块内容更指明了自己未来要成为的人的模样，那团队管理这一块内容则带自己走向了一片自己未曾涉猎的领域，也是一片自己需要学习的领域：管理 管理说白了就是提炼每个人的能力和创意，使得每个人的效率在团队背景下能最大化。如何做到每个决策都是正确的？如何调动小组每一位成员的积极性？如何将每天的会议开的既有效率又有生机？很多很多管理方法的知识等待自己学习，不要只用技术的思维去思考，别让自己沦为铁锤人！ 难以认识到人与人之间的问题，以及难以找到解决的办法，以及不懂得良好的沟通，是自己现在最缺少的能力 不管是管理者还是技术人员，聚焦用户，聚焦产品，而不是盈利，反而会创造更多的利益。管理不是宫廷戏中的你争我斗，而是用智慧去实现时间的效率最大化。为什么中国996如此普遍，就是管理层在权和利斗争中的产物，这一习惯我想中国由来已久，如果不改变，未来中国的企业将没有一个能基业长青！让自己来成为那个开创时代的人吧！ 书摘市场调研等商业手段也许能发现一些用户自认为的需求，但满足消费者尚未意识到的需求更为重要。就像乔布斯所说：“用户也不知道他们想要什么” 成功的产品是以技术洞见为基础。但是中国的互联网公司做产品，多是靠数据，也就是市场调研，很少靠技术创新作为驱动力 寻找技术洞见的途径之一就是将互联网上的数据搜集起来，成为解决某个行业问题的新办法，这就是大数据时代的基础 啥是异想天开，我好像找回了小时候那种奇思妙想的感觉，记牢这个感觉，以后一定有大的帮助！ 人生就像下水道，想从中得到什么，要看你往里面扔了什么 人生最大的奢侈，莫过于从事富有激情的事业，这是通往幸福的清晰路径 心流指的是一种专心致志、深深沉浸在工作中以至于时间仿佛暂停的欢愉状态。心流只有在任务的高度挑战性与完成任务的能力出现完美契合时，这一状态才会产生。如何任何极具挑战而能力达不到，就会感到焦虑；如果能力对于任务大材小用，就会感到无聊 创意喜欢限制。创意往往和异想天开、自由挂钩。当往往是限制激发创意 人类都有强烈的自主需要（即按照自己的意愿自由行动，而不是为应对外界压力而被动行动）、能力需要以及关系需要 需要给创意精英留出20%的时间，让他们去折腾]]></content>
      <tags>
        <tag>管理</tag>
        <tag>Google</tag>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Chapter 3]]></title>
    <url>%2F2019%2F04%2F14%2FMIT-6-828-book-xv6-Chapter-3%2F</url>
    <content type="text"><![CDATA[运行进程时，CPU执行正常的处理器循环：读取指令，增加程序计数器，执行指令，重复。但有些事件，必须从对用户程序的控制转移回内核，而不是执行下一条指令。这些事件包括希望得到注意的设备指令、执行非法操作的用户程序（例如，引用没有PTE的虚拟地址），或用户程序要求内核提供具有系统调用的服务。在处理这些事件时，有三个主要挑战：1)内核必须安排处理器从用户模式切换到内核模式（和返回）；2)必须协调内核和设备之间的并行活动；3)内核必须很好地理解设备的接口；解决这三个难题需要对硬件有详细的了解并小心的编写代码，并且可能会产生不透明的内核代码。本章解释xv6如何解决这些问题。 MIT 6.828 Operating System Engineering Systems calls，exceptions，and interrupts有了系统调用，用户程序就可以像我们在最后一章结束时看到的那样，使用操作系统提供的服务（operating system service），。术语exception是指生成中断的非法程序操作。非法程序操作的示例包括除零、尝试访问不存在的PTE的内存等。interrupt一词是指硬件设备生成的信号，表明它需要操作系统的注意。例如，时钟芯片可能每100毫秒生成一次中断，以允许内核实现时间共享。另一个示例是，当磁盘从磁盘读取块时，它会生成一个中断，以提醒操作系统该块已准备好进行检索。 内核处理所有中断，而不是进程处理中断，因为在大多数情况下，只有内核具有所需的特权和状态。例如，为了在响应时钟中断的进程之间进行时间划分，内核必须参与其中，即使只是为了强制不合作进程（uncooperative processes）放弃（yield）处理器。 在所有三种示例中，操作系统设计都必须为以下情况做好安排。系统必须保存处理器的寄存器，以便将来透明恢复。必须将系统设置为在内核中执行。系统必须选择一个位置，让内核开始执行。内核必须能够检索有关事件的信息，例如，系统调用参数。这一切都必须安全地完成；系统必须保持用户进程和内核的隔离。 要实现此目标，操作系统必须了解硬件如何处理系统调用、异常和中断的详细信息。在大多数处理器中，这三个事件由一个硬件机制处理。例如，在x86上，程序通过使用int指令生成中断来调用系统调用。同样，异常也会生成中断。因此，如果操作系统有中断处理程序，那么操作系统也可以处理系统调用和异常。 基本计划如下。中断停止正常的处理器循环，并开始执行称为中断处理程序的新序列。在启动中断处理程序之前，处理器将保存其寄存器，以便操作系统可以在从中断返回时还原它们。在转换到中断处理程序和从中断处理程序返回的过程中的一个挑战是，处理器应该从用户模式切换到内核模式，然后再切换到中断处理程序。 虽然官方的x86术语是interrupt，但xv6将所有这些词都称为traps，主要是因为它是PDP 11/40中使用的术语，因此是传统的Unix术语。本章使用的术语trap和interrupt是可互换的，但重要的是要记住，陷阱是由处理器上运行的当前进程引起的（例如，进程进行系统调用，并因此生成陷阱），中断是由设备，并且可能与当前正在运行的进程无关。例如，磁盘在检索完一个进程的块后可能会生成中断，但在中断时，其他进程可能正在运行。中断的这一属性使思考中断比思考陷阱更困难，因为中断与其他活动同时发生。但是，两者都依赖于相同的硬件机制来安全地在用户和内核模式之间传输控制。 X86 protectionX86有4个保护级别，编号为0（最高特权）到3（最低特权）。实际上，大多数操作系统只使用2个级别：0和3，分别称为内核模式和用户模式。X86执行指令的当前权限级别存储在%cs寄存器中的字段CPL中。 在x86上，中断处理程序在中断描述符表（IDT，interrupt descriptor table）中定义。IDT有256个条目，每个条目都给出了在处理相应中断时要使用的%cs和%eip。 要在x86上进行系统调用，程序将调用int n指令，其中n指明了在IDT中的索引。Int指令执行以下步骤： 从IDT中提取第n个描述符，其中n是int的参数 检查%cs中CPL&lt;=DPL，其中DPL是描述符中的权限级别 在CPU内部寄存器中保存%esp和%ss，但前提是目标段选择器的PL&lt;CPL 从任务段描述符加载%ss和%esp Push %ss Push %esp Push %eflags Push %cs Push %eip Clear some bits of %eflags Set %cs and %eip to the values in the descriptor. Int指令是一个复杂的指令，人们可能会怀疑这些操作是否都是必要的。检查CPL&lt;=DPL允许内核禁止系统使用某些权限级别。例如，要使用户程序成功地执行int指令，DPL必须为3。如果用户程序没有适当的权限，则 int 指令将导致int 13，这是一个一般的保护故障。另一个示例是，int指令不能使用用户堆栈来保存值，因为用户可能没有设置适当的堆栈，以便硬件使用任务段中指定的堆栈，这是在内核模式下设置的。 图3-1显示int指令完成后的堆栈，并且需要特权级别的更改（描述符中的权限级别低于CPL）。如果int指令不需要特权级别的更改，则x86不会保存%ss和%esp。在这两种情况下，%eip指向描述符表中指定的地址，该地址上的指令是要执行的下一个指令和int n处理程序的第一条指令。实现这些处理程序是操作系统的工作，下面我们将看到xv6的作用。 操作系统可以使用iret指令从int指令返回。它从堆栈中弹出int指令期间保存的值，并在保存的%eip处继续执行。 Code: The ﬁrst system call第1章结尾的initcode.S就调用了系统调用，让我们再来看看（8213）。该进程在进程的堆栈上推入了exec调用的参数，并将系统调用号放在%eax中。系统调用号与syscalls数组中的条目匹配，syscalls数组是函数指针（3600）的表。我们需要安排int指令将处理器从用户模式切换到内核模式，内核调用正确的内核函数（即sys_exec），内核可以检索sys_exec的参数。接下来的几个小节介绍了xv6如何安排此系统调用，然后我们将发现，我们可以重用相同的代码来处理中断和异常。 Code: Assembly trap handlersXv6必须设置x86硬件，以便在遇到int指令时执行一些合理的操作，这将导致处理器生成陷阱。X86允许256个不同的中断。对于软件异常（如除法错误或尝试访问无效内存地址）定义了中断0-31。Xv6将32个硬件中断映射到32-63范围，并使用中断64作为系统调用中断。 从main调用的Tvinit（3317）设置了表idt中的256个条目。中断i由vectors[i]对应地址处的代码处理。每个入口点都是不同的，因为x86不向中断处理程序提供陷阱号。使用256种不同的处理程序是区分256种情况的唯一方法。 Tvinit处理T_SYSCALL，用户系统调用陷阱，特别是：它通过传递值1作为第二个参数来指定门的类型为”陷阱”。陷阱门（trap gate）不清除FL标志，允许在系统调用处理程序期间进行其他中断。 内核还将系统调用门权限设置为DPL_USER，它允许用户程序使用显式int指令生成陷阱。xv6不允许进程用int引发其他中断（例如，设备中断）；如果他们尝试，他们将遇到一个一般的保护异常，这指向了异常向量13。 当将保护级别从用户模式更改为内核模式时，内核不应使用用户进程的堆栈，因为它可能无效。用户进程可能是恶意的，或包含导致用户%esp指向不属于该进程的用户内存的地址的错误。Xv6 通过设置任务段描述符，通过该描述符加载堆栈段选择器和%esp的新值，对x86硬件进行编程，以便在陷阱上执行堆栈开关。函数switchuvm（1873）将用户进程内核堆栈顶部的地址存储到任务段描述符中。 当陷阱发生时，处理器硬件执行以下操作。如果处理器在用户模式下执行，它将从任务段描述符加载%esp和%ss，将旧用户%ss和%esp push到新堆栈上。如果处理器在内核模式下执行，则上述情况都不会发生。然后，处理器将push %eflags、%cs和%eip寄存器。对于一些陷阱，处理器也会推入错误字。处理器然后从相关的IDT条目中加载%eip和%cs。 xv6使用Perl脚本（3200）生成IDT条目指向的入口点。如果处理器没有，则每个条目都会push错误代码，push中断号，然后跳转到alltraps。 Alltraps（3254）继续保存处理器寄存器：它push %ds、%es、%fs、%gs和通用寄存器（3255-3260）。这种努力的结果是，内核堆栈现在包含一个strict trapframe（0602），其中包含发生陷阱时的处理器寄存器（参见图3-2）。处理器先push%ss、%esp、%eflags、%cs和%eip。处理器或陷阱向量push一个错误号，alltraps push其余的。陷阱帧包含在内核返回到当前进程时还原用户模式处理器寄存器所需的所有信息，以便处理器可以完全像陷阱启动时那样继续。回顾第2章，userinit手动构建一个陷阱来实现此目标（参见图1-4）。 在第一个系统调用的情况下，保存的%eip是在int指令之后的指令地址。%cs是用户代码段选择器。%eflags是在执行int指令时的标志寄存器（eflags register）的内容。作为保存通用寄存器的一部分，alltraps还保存%eax，其中包含供内核稍后检查的系统调用号。 现在，用户模式时的处理器寄存器已保存，alltraps已经完成设置处理器去运行内核C代码。处理器在进入处理程序之前设置选择器%cs和%ss；alltraps设置%ds和%es（3263-3265）。它将%fs和%gs设置为指向per-CPU数据段（3266-3268）的SEG_KCPU。 正确设置段后，alltraps都可以调用C陷阱处理程序trap。它将%esp（指向它刚刚构造的陷阱帧）推送到堆栈上，作为trap（3271）的参数。然后调用trap（3272）。trap返回后，alltraps通过增加堆栈指针（3273）来弹出所有参数，然后开始在标签trapret执行代码。当第一个用户进程运行此代码以退出到用户空间时，我们在第2章中跟踪了此代码。同样的顺序也发生在这里：弹出陷阱帧恢复用户模式寄存器，然后iret跳回用户空间。 到目前为止，讨论已经讨论了在用户模式下发生的陷阱，但在内核执行过程中也可能发生陷阱。在这种情况下，硬件不会切换堆栈或保存堆栈指针或堆栈段选择器；否则，会出现与用户模式陷阱相同的步骤，并执行相同的xv6陷阱处理代码。当iret稍后还原内核模式%cs时，处理器将继续在内核模式下执行。 Code: C trap handler我们在上一节中看到，每个处理程序都设置了一个陷阱框架（trap frame），然后调用C函数trap。Trap（3351）查看硬件陷阱编号tf-trapnp，以决定为什么调用它以及需要做什么。如果陷阱是T_SYSCALL，Trap调用系统调用处理程序 syscall。我们将在第5章中回头看两次proc-&gt;killed检查。 检查系统调用后，trap将查找硬件中断（我们将在下面讨论）。除了预期的硬件设备外，陷阱还可能是由虚假中断、不需要的硬件中断引起的。 如果陷阱不是系统调用，也不是寻求注意的硬件设备，则trap假定它是由不正确的行为（例如，除以零）引起的，这部分代码作为陷阱之前执行的代码的一部分。如果导致陷阱的代码是用户程序，则xv6打印详细信息，然后设置cp-&gt;killed以记住清理用户进程。我们将在第5章中了解xv6是如何进行此清理的。 如果是内核在运行，那就必须有一个内核错误：trap打印有关意外的细节，然后调用panic。 Code: System calls对于系统调用，trap调用syscall（3625）。Syscall从陷阱帧（trap frame）加载系统调用号码，其保存在%eax，并将索引加载到系统调用表中。对于第一个系统调用，%eax包含值SYS_exec（3457），syscall将调用系统调用表的SYS_exec&#39;th条目，这与调用sys_exec相对应。 Syscall将系统调用函数的返回值记录在%eax。当陷阱返回到用户空间时，它将从cp-&gt;tf中的值加载到机器寄存器中。因此，当exec返回时，它将返回系统调用处理程序返回的值(3631)。系统调用通常返回负数以指示错误，并表示成功的正数。如果系统调用号无效，syscall将打印错误并返回–1。 后面的章节将研究特定系统调用的实现。本章涉及系统调用的机制。还有一点机制：找到系统调用参数。辅助函数argint和argptr，argstr检索第n个系统调用参数，参数可以是整数、指针或字符串。argint使用用户空间%esp寄存器来定位第n个参数：%esp指向系统调用存根（system call stub）的返回地址处。参数就在它的正上方，即在%esp+4。然后第n个参数是%esp+4+4*n argint调用fetchint从用户内存中读取该地址的值，并将其写入*ip。fetchint可以简单地将地址强制转换为指针，因为用户和内核共享相同的页面表，但内核必须验证用户的指针确实是地址空间的用户部分中的指针。内核设置了页面表硬件，以确保进程无法访问其本地专用内存之外的内存：如果用户程序尝试在p-&gt;sz或更高的地址读取或写入内存，处理器将导致分段陷阱，陷阱会杀死这个过程，正如我们上面看到的。现在，内核正在运行，它可以取消用户可能已传递的任何地址，因此它必须明确检查该地址是否低于p-&gt;sz。 argptr的目的与argint相似：它解释第n个系统调用参数。argptr调用argint将参数作为整数获取，然后检查整数作为用户指针是否确实在地址空间的用户部分。请注意，在调用代码argptr时会发生两次检查。首先，在获取参数的过程中检查用户堆栈指针。然后检查参数，它本身就是一个用户指针。 argstr是系统调用参数三人组的最后一个成员。它将第n个参数解释为指针。它确保指针指向NUL-terminated的字符串，并且完整的字符串位于用户地址空间部分的末尾以下。 系统调用实现（例如，sysprocr.c和sysfile.c）通常是包装器：它们使用argint、argptr和argstr对参数进行解码，然后调用实际实现。在第2章中，sys_exec使用这些函数来获取其参数。 Code: Interrupts主板上的设备可以生成中断，xv6必须设置硬件来处理这些中断。如果没有设备支持，xv6将无法使用。用户无法在键盘上键入，文件系统无法将数据存储在磁盘上等。幸运的是，添加中断和对简单设备的支持不需要太多的复杂性。正如我们将看到的，中断可以使用与系统调用和异常相同的代码。 中断类似于系统调用，但设备随时生成中断。当设备需要得到注意时，主板上有硬件可向CPU发出信号（例如，用户在键盘上键入了字符）。我们必须对设备进行编程以生成中断，并安排CPU接收中断。 让我们来看看计时器设备和计时器中断。我们希望计时器硬件生成中断，例如，每秒100次，这样内核就可以跟踪时间的推移，并且内核就可以在多个正在运行的进程之间进行时间划分。选择每秒100次，可以实现体面的交互性能，同时不干扰处理器处理中断。 与x86处理器本身一样，PC主板也在不断发展，中断的提供方式也在演变。早期的主板有一个简单的可编程中断控制器（称为PIC， programmable interrupt controler），您可以在picirq.c中找到管理它的代码。 随着多处理器PC主板的出现，需要一种新的处理中断的方法，因为每个CPU都需要一个中断控制器来处理发送给它的中断，并且必须有一种将中断路由到处理器的方法。这种方式由两部分组成：一部分在I/O系统（the IO APIC，ioapic.c），以及连接到每个处理器的部分（the local APIC，lapic.c）。Xv6是为具有多个处理器的主板而设计的，每个处理器都必须编程以接收中断。 为了在单处理器上也正常工作，Xv6对可编程控制器（PIC）（7432）进行编程。每个PIC最多可以处理8个中断（即设备），并在处理器的中断引脚上对其进行复用。为了允许8台以上的设备，要连接PICs，通常主板至少有2个。使用inb和outb指令Xv6对master编程生成IRQ 0到7和对slave生成IRQ 8到16。最初xv6对PIC编程，以掩盖所有中断。Timer.c中的代码设置计时器为1，并在PIC（8074）上启用计时器中断。此说明忽略了编程PIC方案的一些细节。PIC（以及 IOAPIC和LAPIC）的这些详细信息对本文并不重要，但感兴趣的读者可以查阅源文件中引用的每个设备的手册。 在多处理器上，xv6必须对每个处理器上的IOAPIC和LAPIC进行编程。IO APIC有一个表，处理器可以通过内存映射的I/O对表中的条目进行编程，而不是使用inb和outb指令。在初始化过程中，xv6程序将中断0映射到IRQ 0，依此类推，但禁用它们。特定设备启用特定中断，并说明中断应路由到哪个处理器。例如，xv6 将键盘中断路由到处理器0（8016）。Xv6将磁盘中断路由到系统上编号最高的处理器，我们将在下面看到。 定时器芯片位于LAPIC内部，因此每个处理器都可以独立接收计时器中断。Xv6将其设置在lapicinit（7151）中。关键行是对计时器（7164）进行编程的行。此行告诉LAPIC定期在IRQ_TIMER（即IRQ 0）生成中断。第7193行启用CPU LAPIC上的中断，这将导致它向本地处理器传递中断。 处理器可以通过eflags寄存器中的IF标志控制是否希望接收中断。指令cli通过清除IF来禁用处理器上的中断，sti在处理器上启用中断。Xv6在引导（booting）主CPU（8912）和其他处理器（1126）时禁用中断。每个处理器上的调度程序启用中断（2714）。为了控制某些代码片段不会中断，xv6在这些代码片段期间禁用中断（例如，请参见switchuvm（1873））。 计时器通过向量32中断（其中xv6选择处理IRQ 0），其中xv6设置在idtinit（1265）。向量32和向量64（系统调用）之间的唯一区别是，向量32是中断门而不是陷阱门。中断门清除IF，以便中断的处理器在处理当前中断时不会接收中断。从这里开始，直到trap，中断遵循与系统调用和异常相同的代码路径，建立陷阱框架。 当它被调用为时间中断时，trap只做两件事：增加刻度变量（ticks variable，3367）和调用wakeup。正如我们将在第5章中看到的那样，后者可能会导致中断在不同的过程中返回。 Drivers驱动程序是操作系统中管理特定设备的一段代码：它为设备提供中断处理程序，导致设备执行操作，导致设备生成中断等。编写驱动程序代码可能会很棘手，因为驱动程序与其管理的设备同时执行。此外，驱动程序必须了解设备的接口（例如，哪个I/O执行什么操作），并且该接口可能很复杂，文档记录不足。 磁盘驱动程序在xv6中提供了一个很好的示例。磁盘驱动程序从磁盘复制数据并返回到磁盘。磁盘硬件传统上将磁盘上的数据显示为512字节块（也称为扇区）的编号序列：扇区0是前512字节，扇区1是下一个字节，依此类推。为了表示磁盘扇区，操作系统具有与一个扇区相对应的结构。存储在此结构中的数据通常与磁盘不同步：它可能尚未从磁盘中读取（磁盘正在处理，但尚未返回扇区的内容），或者它可能已更新但尚未写出。驱动程序必须确保在结构与磁盘不同步时，xv6的其余部分不会感到困惑。 Code: Disk driverIDE设备提供对连接到PC标准IDE控制器的磁盘的访问。IDE现在已经过时，取而代之的是SCSI和SATA，但接口很简单，让我们专注于驱动程序的整体结构，而不是特定硬件的细节。 磁盘驱动程序使用称为buffer的数据结构来表示磁盘扇区，struct buf（3750）。每个缓冲区表示特定磁盘设备上的一个扇区的内容。dev和sector字段提供设备和扇区编号，data字段是磁盘扇区的内存中副本。 flags跟踪内存和磁盘之间的关系：B_VALID标志表示已读取数据，B_DIRTY标志表示需要写出数据。B_BUS标志是一个锁位；它表示某些进程正在使用缓冲区，而其他进程不能使用。当缓冲区设置了B_BUSY标志时，我们说缓冲区是锁定的。 内核在启动时初始化磁盘驱动程序，方法是从main（1234）调用ideinit（4151）。Ideinit调用picenable和ioapicenable启用IDE_IRQ中断（4156-4157）。对picenable的调用启用了单处理器上的中断；ioapicenable在多处理器上启用中断，但仅在最后一个CPU（ncpu-1）上启用：在双处理器系统上，CPU 1处理磁盘中断。 接下来，ideinit探测磁盘硬件。它首先调用idewait（4158），以等待磁盘能够接受命令。PC主板显示I/O端口0x1f7上磁盘硬件的状态位。Idewait（4133）轮询状态位，直到忙位（IDE_BSY）清除并设置就绪位（IDE_DRDY）。 现在磁盘控制器已准备就绪，ideinit可以检查存在多少磁盘。它假定磁盘0存在，因为引导加载程序和内核都是从磁盘0加载的，但它必须检查磁盘1。它将写入I/O端口0x1f6以选择磁盘1，然后等待一段时间，以等待状态位显示磁盘已准备就绪（4160-4167）。如果没有，则认为磁盘不存在。 在ideinit之后，在缓冲区缓存调用iderw之前，不会再次使用磁盘，该缓冲区将按照标志的指示更新锁定的缓冲区。如果设置了B_DIRTY，则将缓冲区写入磁盘；如果未设置B_VALID，则从磁盘读取缓冲区。 磁盘访问通常需要毫秒，对于处理器来说是很长一段时间。引导加载程序发出磁盘读取命令，并重复读取状态位，直到数据准备就绪。此轮询或繁忙等待在引导加载程序中很好，没有更好的操作。但是，在操作系统中，让另一个进程在CPU上运行并在磁盘操作完成时安排接收中断会更有效。Iderw采用后一种方法，将挂起的磁盘请求列表保留在队列中，并使用中断来确定每个请求何时完成。尽管iderw维护一个请求队列，但简单的IDE磁盘控制器一次只能处理一个操作。磁盘驱动程序保持不变，即它已将队列前面的缓冲区发送到磁盘硬件；其他人只是在等着轮到他们。 Iderw（4254）将缓冲区b添加到队列的末尾（4267-4271）。如果缓冲区位于队列的最前面，则必须通过调用idestart（4224-4226）将其发送到磁盘硬件；否则，只有缓冲区前面的缓冲区得到处理，才会启动缓冲区。 根据标志，idestart（4175）会发出缓冲区设备和扇区的读取或写入问题。如果操作是写的，则必须立即提供数据（4189），中断将发出数据已写入磁盘的信号。如果操作是读取操作，中断将发出数据已准备就绪的信号，处理程序将读取该数据。请注意，idestart对IDE设备有详细的了解，并在正确的端口写入正确的值。如果这些输出语句中的任何一个是错误的，IDE将执行与我们所需的不同的操作。正确掌握这些细节是编写设备驱动程序具有挑战性的原因之一。 将请求添加到队列并在必要时启动它后，idew必须等待结果。如上所述，轮询不能有效地利用CPU。相反，idew休眠，等待中断处理程序在缓冲区的标志中记录操作已完成（4278-4279）。当此过程处于睡眠状态时，xv6将安排其他进程以保持CPU繁忙。 最终，磁盘将完成其操作并触发中断。trap会调用ideintr来处理（3374）。Ideintr（4202）会咨询队列中的第一个缓冲区，以找出正在执行的操作。如果正在读取缓冲区，并且磁盘控制器有数据等待，则ideintr会使用insl（4215-4217）将数据读取到缓冲区中。现在缓冲区已准备就绪：ideintr设置 B_VALID，清除B_DIRTY，并唤醒休眠缓冲区（4219-4222）上的任何进程。最后，ideintr必须将下一个等待缓冲区传递到磁盘（4224-4226）。 Real world支持PC主板上的所有设备的全部荣誉是大量的工作，因为有许多设备，设备有许多功能，并且设备和驱动程序之间的协议可能很复杂。在许多操作系统中，驱动程序共同在操作系统中考虑的代码比核心内核更多。 实际设备驱动程序比本章中的磁盘驱动程序复杂得多，但基本思想是相同的：通常设备比CPU慢，因此硬件使用中断来通知操作系统状态更改。现代磁盘控制器通常一次接受一批磁盘请求，甚至对其进行重新排序，以便最有效地利用磁盘臂。当磁盘更简单时，操作系统通常会对请求队列本身进行重新排序。 许多操作系统都有固态磁盘的驱动程序，因为它们提供了更快的数据访问。尽管固态与传统的机械磁盘的工作原理非常不同，但这两种设备都提供了基于块的接口，并且固态磁盘上的读/写入块仍然比读写RAM更昂贵。 其他硬件与磁盘惊人地相似：网络设备缓冲区保存数据包，音频设备缓冲区保存声音样本，图形卡缓冲区保存视频数据和命令序列。高带宽设备（磁盘、图形卡和网卡）通常使用直接内存访问（DMA， direct memory access），而不是此驱动程序中的显式I/O（insl，outsl）。DMA允许磁盘或其他控制器直接访问物理内存。驱动程序向设备提供缓冲区数据字段的物理地址，设备直接复制到主内存或从主内存复制，一旦复制完成，就会中断。使用DMA意味着CPU根本不参与传输，这可以更高效，并且对 CPU的内存缓存的负担更小。 本章中的大多数设备都使用I/O指令对其进行编程，这反映了这些设备的旧特性。所有现代设备都使用内存映射I/O（memory-mapped I/O）进行编程。 某些驱动程序在轮询和中断之间动态切换，因为使用中断可能会很昂贵，但使用轮询可能会导致延迟，直到驱动程序处理事件。例如，对于接收到大量数据包的网络驱动程序，可以从中断切换到轮询，因为它知道必须处理更多的数据包，并且使用轮询处理这些数据包的成本更低。一旦不再需要处理数据包，驱动程序就可以切换回中断，以便在新数据包到达时立即向其发出警报。 IDE驱动程序静态地将中断路由到特定的处理器。一些驱动程序有一个复杂的算法，将中断路由到处理器，使处理数据包的负载很好地平衡，但也实现了良好的局部性。例如，网络驱动程序可能会安排将一个网络连接的数据包的中断传递到管理该连接的处理器，而另一个连接的数据包的中断则传递到另一个处理器。此路由可以变得相当复杂；例如，如果某些网络连接的寿命较短，而另一些网络连接寿命较长，并且操作系统希望使所有处理器都忙得不可开交，以实现高吞吐量。 如果用户进程读取文件，则会复制该文件的数据两次。首先，驱动程序将其从磁盘复制到内核内存，然后通过读取系统调用将其从内核空间复制到用户空间。如果用户进程然后在网络上发送数据，这将再次复制数据两次：一次从用户空间到内核空间，从内核空间到网络设备。为了支持低延迟的应用程序是很重要（例如，为静态网页提供服务的Web），操作系统使用特殊的代码路径来避免这些副本。例如，在实际操作系统中，缓冲区通常与硬件页面大小匹配，因此只读副本可以使用分页硬件映射到进程的地址空间，而无需进行任何复制。 Exercises Set a breakpoint at the ﬁrst instruction of syscall() to catch the very ﬁrst system call (e.g.，br syscall). What values are on the stack at this point? Explain the output of x/37x $esp at that breakpoint with each value labeled as to what it is (e.g.，saved %ebp for trap，trapframe.eip，scratch space，etc.). Add a new system call Add a network driver]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Chapter 6]]></title>
    <url>%2F2019%2F04%2F13%2FMIT-6-828-book-xv6-Chapter-6%2F</url>
    <content type="text"><![CDATA[文件系统的目的是为了组织和保存数据。文件系统通常支持在用户和应用之间分享数据，并且支持持久化，以便数据在重启后依旧有效。 MIT 6.828 Operating System Engineering xv6文件系统提供Unix-like文件、目录和路径（见第0章），并且为了持久化将数据保存在IDE硬盘中（见第3章）。文件系统需要解决以下几个挑战： 文件系统需要保存在硬盘上（on-disk）的数据结构去表示已命名的目录和文件的树形结构，记录保存每个文件内存的块的标记，还要记录硬盘中那些区域是空闲的。 文件系统还要支持故障恢复（crash recovery）。也就是说，如果出现故障（如断电），文件系统在重启之后依旧能正常工作。风险在于，崩溃可能会中断一系列更新，并使磁盘上的数据结构不一致（例如一个块仍被文件使用却被标志位空闲）。 不同的进程可以同时在文件系统上运行，并且必须进行协调以保持一致性。 访问磁盘的速度比访问内存要慢数量级，因此文件系统必须维护常用块的内存中缓存。 本章剩余部分解释了xv6如何解决上述挑战 简介Xv6文件系统实现分为七个层，如图6-1所示。磁盘层读取和写入IDE硬盘驱动上的块。高速缓存层缓存磁盘块并同步对它们的访问，确保一次只有一个内核进程可以修改存储在任何特定块中的数据。日志层允许更高层将对多个快块的更新包装到一个事务（transaction）中，并确保这些块在发生崩溃时进行原子更新（即所有这些块都已更新或没有更新）。Inode层提供了单独的文件，每个文件表示为具有唯一i-number的inode和一些包含文件数据的块。目录层将每个目录实现为一种特殊的inode，其内容是目录项的序列，每个条目都包含文件名和i-number。路径层（pathname layer）提供分层路径名称，如/usr/rtm/xv6/fs.c，并通过递归查找对其进行解析。文件描述符层使用文件系统接口抽象了许多Unix资源（如管道、设备，文件等），简化了应用程序员的工作。 文件系统必须有一个计划，决定在磁盘上存储inodes和内容块的位置。为此，xv6将磁盘划分为多个部分，如图6-2所示。文件系统不使用block 0（它保存boot sector）。Block 1被称为超级块（superblock）；它包含有关文件系统的元数据（块中的文件系统大小、数据块的数量、inodes的数量和日志中的块数）。从Block 2开始保存 inodes，每个块有多个inodes。在这些数据块之后，位图块（bitmap blocks）跟踪正在使用的数据块。其余的大多数块都是数据块；每个都在位图块中标记为”空闲”，或保留文件或目录的内容。磁盘末端的块保存日志层的日志。 本章的其余部分讨论了每个层，从缓冲区缓存开始。在较低层选择良好的抽象可使得设计较高层变得轻松。 Buﬀer cache Layer缓冲区缓存有两个作业：（1）同步对磁盘块的访问，以确保内存中只有一个块的副本，并且一次只有一个内核线程使用该副本；（2）缓存热点块，使它们不会从慢速磁盘重新读取。该代码是在bio.c。 缓冲区缓存层提供的主要接口是bread和bwrite；前者获取一个buf，其包含可在内存中读取或修改的块的副本，后者将修改后的缓冲区写入磁盘上的相应块。内核线程必须在使用缓冲区后通过调用brelse来释放缓冲区。 缓冲区缓存通过允许最多一个内核线程具有对块缓冲区的引用来同步对每个块的访问。如果一个内核线程获得了对缓冲区的引用，但尚未释放，则其他线程对同一块的bread的调用将等待。较高的文件系统层依赖于缓冲区缓存的块同步，以帮助它们维持一致性。 缓冲区缓存具有固定数量的缓冲区来容纳磁盘块，这意味着，如果文件系统要求的块尚未在缓存中，则缓冲区缓存必须回收当前包含某些其他块的缓冲区。缓冲区缓存回收最近使用最少的新块缓冲区。假设是，最近使用最少的缓冲区是最不可能很快再次使用的缓冲区。 Code: Buﬀer cache缓冲区缓存是缓冲区的双向链表（doubly-linked list）。由main（1231）调用的函数binit使用静态数组buf中的NBUF个缓冲区初始化列表（4350-4359）。对缓冲区缓存的所有其他访问都是通过bcache.head来引用链表，而不是通过buf数组。 缓冲区有三个与之关联的状态位。B_VALID表示缓冲区包含块的副本。B_DIRTY表示缓冲区内容已被修改，需要写入磁盘。B_BUSY表示某些内核线程具有对此缓冲区的引用，但尚未释放它。 bread（4402）调用bget，以获得给定扇区（4406）的缓冲。如果需要从磁盘读取缓冲区，bread会在返回缓冲区之前调用iderw来进行读取。 Bget（4366）使用给定的设备和扇区编号扫描缓冲区列表以获取缓冲区（4373-4384）。如果有这样的缓冲区，并且缓冲区不忙，bget设置B_BUSY标志并返回（4376-4383）。如果缓冲区已在使用中，bget在缓冲区上休眠等待其释放。当sleep返回时，bget不能假定缓冲区现在可用。事实上，由于sleep释放和重新获得buf_table_lock，不能保证b仍然是正确的缓冲区：可能它已被重用到不同的磁盘扇区。Bget必须重新开始（4382），希望这次的结果会有所不同。 如果给定扇区没有缓存缓冲区，bget必须创建一个缓冲区，可能会重用包含不同扇区的缓冲区。它第二次扫描缓冲区列表，寻找空闲的的缓冲区：可以使用任何此类缓冲区。Bget编辑缓冲区元数据以记录新设备和扇区编号，并在返回缓冲区之前标记缓冲区为BUSY（4393-4395）。请注意，对标志的分配不仅设置了B_BUSY位，而且还清除了B_VALID和B_DIRTY位，从而确保bread将从磁盘读取块数据，而不是错误地使用缓冲区以前的内容。 由于缓冲区缓存用于同步，因此特定磁盘扇区只有一个缓冲区是很重要的。这些分配（4391-4393）是安全的，因为bget的第一个循环确定该扇区已经不存在缓冲区，此后bget没有放弃buf_table_lock。 如果所有的缓冲区都很忙，就出了问题：bget panics。一个更优雅的反应可能是sleep，直到有缓冲区变得空闲，尽管这样就有可能出现死锁。 一旦bread将缓冲区返回给其调用方，调用方就可以独占使用（exclusive use）该缓冲区，并且可以读取或写入数据字节。如果调用方确实写入了数据，则必须调用bwrite将更改后的数据写入磁盘，然后再释放缓冲区。Bwrite（4414）设置B_DIRTY标志，并调用iderw将缓冲区写入磁盘。 当调用方使用缓冲区完成时，它必须调用brelse释放它。（brelse，是b-release的缩短，是神秘的（cryptic），但值得学习：它起源于Unix，并在BSD，Linux 和 Solaris 也使用。Brelse（4425）将缓冲区移动到链表的前面（4432-4437），清除B_BUSY位，并唤醒在缓冲区上休眠的任何进程。移动缓冲区会导致根据缓冲区最近的使用方式（意味着已释放）对列表进行排序：列表中的第一个缓冲区是最近使用的缓冲区，最后一个缓冲区是最近使用的缓冲区。Bget 中的两个循环利用了这一点：对现有缓冲区的扫描必须在最坏的情况下处理整个列表，但首先检查最近使用的缓冲区（从bcache.head开始，然后是next指针）将减少扫描时间。选择缓冲区以重复使用的扫描通过向后扫描（在prev指针之后）选择最近使用最少的缓冲区。 Logging layer文件系统设计中最有趣的问题之一是崩溃恢复（crash recovery）。出现此问题的原因是，许多文件系统操作涉及对磁盘的多次写入，并且写入一部分后发生崩溃可能会使磁盘上的文件系统处于不一致的状态。例如，根据磁盘写入的顺序，文件删除过程中的崩溃可能会使目录项指向空闲inode，也可能会保留已分配但未引用的inode。后者是相对良性的，但一个目录条目，指向一个释放的inode很可能会在重新启动后导致严重的问题。 Xv6通过简单版本的日志（simple version of loggin）解决了文件系统操作过程中的崩溃问题。Xv6系统调用不会直接写入磁盘上的文件系统数据结构。相反，它将把有关所有磁盘写入的描述写入磁盘上的日志中。一旦系统调用记录了它的所有写入操作，它就会将一个特殊的提交记录写入磁盘，这表明日志包含一个完整的操作。此时，系统调用将写入操作复制到磁盘上文件系统数据结构。这些写入完成后，系统调用将擦除磁盘上的日志。 如果系统崩溃并重新启动，文件系统代码将从崩溃中恢复，然后再运行任何进程。如果日志被标记为包含完整的操作（containing a complete operation），则恢复代码会将写入操作复制到它们在磁盘文件系统中的位置。如果未将日志标记为包含完整操作，则恢复代码将忽略该日志。恢复代码通过擦除它来结束。 为什么xv6的日志解决了文件系统操作过程中的崩溃问题？如果在提交操作之前发生崩溃，则磁盘上的日志将不会标记为已完成，恢复代码将忽略它，并且磁盘的状态将像操作甚至尚未启动一样。如果在操作提交后发生崩溃，则恢复代码将重做所有写入操作，如果操作已开始将其写入磁盘数据结构，则可能会重复这些写入操作。无论哪种情况，日志都会使操作成为与崩溃有关的原子操作：恢复后，操作的所有写入都显示在磁盘上，或者这些写入操作都不会出现。 Log design日志驻留在磁盘末尾的已知固定位置。它由一个标头块（header block）和一系列更新的块副本（”记录块”，logged blocks）组成。标头块包含一个扇区编号数组，对应每个记录块。标头块还包含记录块的数量。Xv6在事务提交时写入标头块，并将记录块复制到文件系统后将计数设置为零。因此，事务中途崩溃将导致日志的标头块中的计数为零；提交后的崩溃将导致非零计数。 每个系统调用的代码都指示原子写入序列的开始和结束。为了提高效率，并允许文件系统代码中的一定程度的并发性，日志记录系统可以在每个事务中累积多个系统调用的写入。因此，一次提交可能涉及多个完整系统调用的写入。为了保持原子性，只有在没有文件系统的系统调用的情况下，日志记录系统才会提交。 同时提交多个事务的想法称为组提交（group commit）。组提交允许多个事务同时运行，并允许文件系统批处理多个磁盘操作，并向磁盘驱动程序发出单个磁盘操作。这允许磁盘巧妙地安排块的写入，并以磁盘带宽的速率进行写入。Xv6的IDE驱动程序不支持批处理（batching），但xv6的文件系统设计允许批处理。 Xv6在磁盘上指定固定的空间来保存日志。系统调用在事务中写入的块总数必须适合该空间。这有两个后果。任何单个系统调用都不能比日志中的空间更多地写入块。这对大多数系统调用来说不是问题，但其中两个调用可能会编写许多块：write和unlink。大文件写入可能会写入多个数据块和多个位图块以及inode块；取消大文件链接可能会写入多个位图块和inode。Xv6的写入系统调用将大型写入分解为多个适合日志中的较小的写入，并且unlink不会导致问题，因为实际上xv6文件系统只使用一个位图块。有限日志空间的另一个后果是，日志系统无法允许系统调用启动，除非系统调用的写入符合日志中剩余的空间。 Code: logging系统调用中典型的日志使用如下所示：1234567begin_op(); ... bp = bread(...); bp-&gt;data[...] = ...; log_write(bp);... end_op(); begin_op（4628）等待，直到日志记录系统当前未提交，直到有足够的可用日志空间来保存此调用和当前正在执行的所有系统调用的写入。log.outstanding记录调用的个数；该增量既保留了空间，又防止了在此系统调用期间发生提交。代码保守地假定每个系统调用可能写入MAXOPBLOCK不同的块。 log_write（4722）充当bwrite的代理。它在内存中记录块的扇区号，在磁盘上保留一个槽（slot），并标记缓冲区B_DIRTY以防止块缓存将其逐出。提交之前，块必须保留在缓存中：此时缓存的副本是修改的唯一记录；直到提交后，它才能写入它在磁盘上的位置；和同一事务中的其他读取必须看到修改。当一个块在单个事务中多次写入时，log_write会收到通知，并分配该块日志中的同一插槽。这种优化通常被称为吸收（absorption）。例如，通常情况下，包含多个文件的inodes的磁盘块在事务中多次写入。通过将多个磁盘写入归并到一个当中，文件系统可以节省日志空间，并可以获得更好的性能，因为只需将磁盘块的一个副本写入磁盘。 end_op（4653）第一个减少未完成（outstanding）的系统调用的计数。如果计数现在为零，它将通过调用commit()提交当前事务。这一过程分为四个阶段。write_log()（4683）将事务中修改的每个块从缓冲区缓存复制到其在磁盘日志中的插槽。write_head()（4604）将标头块写入磁盘：这是提交点（commit point），写入后的崩溃将导致恢复从日志中重做（replaying）事务的写入。install_trans()（4572）从日志中读取每个块，并将其写入文件系统中的适当位置。最后，end_op写入日志标头的计数为零；这必须在下一个事务开始写入记录块之前发生，因此崩溃不会导致使用一个事务的标头与后续事务的记录块进行恢复。 recover_from_log（4618）由initlog（4556）调用，在第一个用户进程运行之前，在引导过程中调用 initlog（2794）。 它读取日志标头，如果标头指示日志包含已提交的事务，则模拟（mimics）end_op的操作。日志的一个示例使用发生在filewrite（5752）中。该事务如下所示：12345begin_op(); ilock(f-&gt;ip); r = writei(f-&gt;ip，...); iunlock(f-&gt;ip); end_op(); 此代码被包装在一个循环中，该循环将大型写入分解为一次只包含几个扇区的单个事务，以避免日志溢出。对writei的调用在此事务中写入多个块：文件的inode、一个或多个位图块和一些数据块。 Code: Block allocator文件和目录内容存储在磁盘块中，这些磁盘块必须从一个可用池（free pool）中分配。xv6的块分配器在磁盘上维护一个空闲位图（free bitmap），每个块有一个位。零位表示相应的块是空闲的；一个位表示它正在使用中。引导扇区、超级块、inode块和位图块对应不同位，并且Bitmap块对应的位总是设置为1。 块分配器提供了两个功能：balloc分配一个新的磁盘块，然后bfree释放一个块。Balloc（4804）首先调用readsb将磁盘上的超级块（或buﬀer cache）读入sb.balloc，通过计算引导扇区、超级块和inodes（使用BBLOCK）消耗多少块来决定哪些块持有数据块自由位图。循环（4812）考虑每个块，从块0开始，直到sb.size（文件系统中的块数）。它查找位图位为零的块，这表示它是空闲的。如果balloc找到这样的块，它将更新位图并返回该块。为了提高效率，循环被拆分为两个部分。外部循环读取位图位的每个块。内部循环检查单个位图块中的所有BPB位。如果两个进程尝试同时分配一个块，则可能发生的竞争由于缓冲区缓存只允许一个进程同时使用任何一个位图块而被阻止。 Bfree（4831）找到正确的位图块并清除正确位。同样，bread和brelse所暗示的独家使用避免了显式锁定的需要。 与本章其余部分中描述的大部分代码一样，必须在事务中调用balloc和bfree。 Inode layerInode一词可以有两个相关的含义。它可能指的是包含文件大小和数据块编号列表的磁盘数据结构。或者，”inode”可能指的是内存中的inode（in-memory inode），其中包含磁盘上inode的副本以及内核中所需的额外信息。 所有磁盘上的inodes都被打包到一个连续的磁盘区域（contiguous area）中，称为inode块。每个inode的大小相同，因此在给定数字n的情况下，很容易在磁盘上找到第n个inode。事实上，这个数字n，称为inode number或i-number，是如何识别inode的实现方式。 磁盘上的inode由struct dinode（3926）定义。type字段区分文件、目录和特殊文件（设备)。type为0表示磁盘上的inode是空闲的。Nlink字段计算引用此inode的目录项的数量，以便识别何时应释放磁盘上的inode及其数据块。size字段记录文件中内容的字节数。addrs数组记录保存文件内容的磁盘块的块号。 内核在内存中保留一组活动的inodes； struct inode（4012）是磁盘上struct dinode的内存副本。只有当存在引用该inode的C指针时，内核才会在内存中存储一个inode。Ref字段计算引用内存中inode的C指针的数量，如果引用计数下降到零，内核将从内存中丢弃inode。iget和iput函数获取和释放指向inode的指针，修改引用计数。指向inode的指针可以来自文件描述符、当前工作目录和瞬态内核代码（transient kernel code，如exec）。 Iget()返回的指针在对iput()的相应调用之前保证有效；inode不会被删除，指针所引用的内存也不会被重新用于不同的inode。iget()提供对inode的非独占访问，以便可以有许多指向同一inode的指针。文件系统代码的许多部分依赖于iget()的这种行为，这既是为了保留对inodes的长期引用（作为打开的文件和当前目录），也是为了防止竞争，同时避免在操作多个inodes的代码中的死锁（如路径名查找）。 Iget返回的struct inode可能没有任何有用的内容。为了确保它保存磁盘上inode的副本，代码必须调用ilock。这将锁定inode（以便其他进程无法重新锁定它），并从磁盘读取inode（如果尚未读取）。iunlock释放inode上的锁。在某些情况下（例如在目录查找期间），将inode指针的获取与锁定分开有助于避免死锁。多个进程可以将c指针保存到iget返回的inode，但一次只能有一个进程锁定inode。 Inode缓存仅缓存内核代码或数据结构包含C指针的inode。它的主要工作实际上是通过多个进程而不是缓存来同步访问。如果频繁使用inode，则如果不由inode缓存保存，则缓冲区缓存可能会将其保留在内存中。 Code: Inodes若要分配新的inode（例如，在创建文件时），xv6调用ialloc（4953）。Ialloc类似于balloc：它在磁盘上的inode结构上循环，一次一个块，寻找一个标记为空闲的结构。当它找到一个，它通过将新类型写入磁盘来声明（claim）它，然后从inode cache返回一个条目并尾调用iget（4970）。Ialloc的正确操作取决于这样一个事实，即一次只能有一个进程持有对bp的引用：ialloc可以确保其他进程不会同时看到inode可用并尝试声明它。 Iget（5004）通过inode cache查看具有所需设备和inode编号的活动条目（ip-&gt;ref &gt;0）。如果找到一个，它将返回对该inode的新引用（5013-5017）。当iget扫描时，它记录第一个空插槽（5018-5019）的位置，如果需要分配缓存条目，它将使用该位置。 在读取或写入其元数据或内容之前，代码必须使用ilock锁定inode。Ilock（5053）使用现在熟悉的睡眠循环来等待ip_flag的I_BUSY是否空闲，然后设置它（5062-5064）。一旦ilock具有对inode的独占访问权限（exclusive access），它就可以根据需要从磁盘加载inode元数据（更有可能是缓冲区缓存）。函数iunlock（5085）清除I_BUSY 位，并唤醒睡在ilock中的任何进程。 Iput（5108）通过递减引用计数（5124）将释放指向inode的C指针。如果这是最后一个引用，则 inode缓存中的inode插槽现在是空闲的，可以重新用于不同的inode。 如果iput看到没有指向inode的C指针引用，并且没有指向inode的链接（发生在没有目录中），则必须释放inode及其数据块。Iput重新锁住inode；调用itrunc将文件截断（truncate）为零字节，释放数据块；将inode类型设置为0（未分配）；将更改写入磁盘；最后解锁inode（5111-5123）。 在释放inode的情况下，锁定协议（locking protocol）值得仔细研究。首先，当通过设置I_BUSY锁定ip时，iput假定它已解锁。这必须是这样：调用方需要在调用iput之前解锁ip，并且没有其他进程可以锁定此inode，因为没有其他进程可以获得指向它的指针。这是因为，在此代码路径中，inode没有引用，没有链接（即没有路径名引用它），并且没有（尚未）标记为空闲。第二部分值得研究的是iput临时释放（5116）并重新获取（5120）的inode缓存锁，因为itrunc和iupdate将在磁盘I/O期间休眠。但我们必须考虑在没有锁的情况下可能会发生什么。具体来说，一旦iupdate 完成，磁盘inode将被标记为免费，并在iput完成之前，对ialloc的并发调用可能会找到它并重新分配它。Ialloc通过调用iget，将返回对块的引用，它将在缓存中找到ip，看到I_BUSY标志已设置，并休眠。现在，与磁盘相比，内核中的inode不同步：ialloc重新初始化磁盘版本，但在ilock期间依赖调用方将其加载到内存中。为了确保发生这种情况，iput在释放inode锁之前，不仅必须清除I_BUSY，还必须清除I_VALID。它通过归零标志（5121）来做到这一点。 iput()可以写入磁盘。这意味着使用文件系统的任何系统调用都可能写入磁盘，甚至像read()这样的调用似乎是只读的。这反过来又意味着，即使是只读系统调用，如果它们使用文件系统，也必须包装在事务中。 Code: Inode content磁盘上的inode结构，struct dinode，包含一个大小和一个块数数组（参见图6-4）。Inode数据在dinode的dinode’s addrs数组中列出的块中找到。数组中的第一个NDIRECT条目中列出了第一个NDECECT数据块；这些块被称为直接块（direct blocks）。下一个NINDECECT数据块不是在inode中列出的，而是在称为间接块（indirect block）的数据块中列出的。addrs数组中的最后一个条目给出了间接块的地址。因此，文件的前6KB（NDECECT BSIZE）字节可以从inode中列出的块加载，而下一个64KB（NINDECT BSIZE）字节只能在咨询间接块后加载。这是一个很好的磁盘表示形式，但对客户端来说是一个复杂的表示形式。函数bmap管理表示（manages the representation），以便更高级别的例程（如readi和writei），我们将很快看到这些例程。Bmap返回inode ip的第bn个数据块的磁盘块号。如果ip还没有这样的方块，bmap将分配一个。 函数bmap（5160）从挑选简单的情况开始：第一个NDIRECT块列在inode本身（5165-5169）中。下一个NINDIECT块列在间接块中，在ip-&gt;addrs[NINDIECT]中。Bmap读取间接块（5176），然后从块（5176）内的正确位置读取块号。如果块数超过NDIRECT+NINDECECT，则bmap pancs；writei包含防止这种情况发生的检查（5315）。 Bmap根据需要分配块。一个ip-&gt;addrs[]或间接输入零表示没有分配块。当bmap遇到零时，它将替换为按需分配的新块的数量（5166-5167，5174-5175）。 itrunc释放文件的块，将inode的大小重置为零。Itrunc（5206）首先释放直接块（5212-5217），然后释放在间接块（52225225）中列出的块，最后释放间接块本身（5227-5228）。 Bmap使readi和writei更容易获得inode的数据。Readi（5252）首先要确保偏移量和计数不超过文件的末尾。在文件末尾之后开始的读取返回错误（5263-5264），而在文件末尾或交叉的读取返回的字节数少于请求的字节数（5265-5266）。主循环处理文件的每个块，将数据从缓冲区复制到 dst（5268-5273）。writei（5302）与readi相同，但有三种例外：在文件末尾或在文件末尾开始的写入将文件增长，可达最大文件大小（5315-5316）；循环将数据复制到缓冲区而不是输出（5321）；如果写入扩展了文件，则writei必须更新其大小（5326-5329）。 Readi和writei都从检查ip-&gt;type == T_DEV开始。这种情况下处理数据不存在于文件系统中的特殊设备；我们将在文件描述符层中返回到这种情况。 函数stati（4773）将inode元数据复制到stat结构中，通过stat系统调用向用户程序公开该结构。 Code: directory layer目录在内部实现，就像文件一样。它的inode具有T_DIR类型，其数据是目录项的序列。每个条目都是一个struct dirent（3950），其中包含一个名称和一个inode号。名称最多是DIRSIZ（14）字符；如果较短，则由NUL（0）字节终止。包含inode号零的目录条目是空闲的。 函数dirlookup（5361）在目录中搜索具有给定名称的条目。如果找到一个，它将返回指向相应的 inode、解锁和设置*poff的指针，指向目录中条目的字节偏移量，以防调用方希望对其进行编辑。如果dirlookup找到具有正确名称的条目，它将更新*poff，释放块，并返回通过iget获得的未锁定的inode。Dirlookup是iget返回未解锁的inodes的原因。调用方已锁定dp，因此，如果查找为.，即当前目录的别名，尝试在返回之前锁定inode将尝试重新锁定dp和死锁。（有更复杂的死锁场景涉及多个进程，并且..，父目录的别名；.不是唯一的问题）。调用者可以解锁dp，然后锁定ip，确保它一次只持有一个锁。 函数dirlink（5402）将具有给定名称和inode号的新目录条目写入目录dp。如果名称已存在，dirlink将返回错误（5408-5412）。主循环读取查找未分配项的目录项。当它找到一个时，它会提前停止循环（5372-5373），off设置为可用条目的偏移量。否则，循环以off设置为dp-&gt;size结束。无论哪种方式，dirlink都通过写在偏移量off添加一个新的条目到目录中（5422-5425）。 Code: Path names路径名称查找涉及对dirlookup的连续调用，每个路径组件一个调用。Namei（5540）评估path并返回相应的inode。函数nameiparent是一个变量：它在最后一个元素之前停止，返回父目录的inode并将最后一个元素复制到name中。两者都调用通用函数namex来做实际的工作。 Namex（5505）首先决定路径评估（path evaluation）的起始位置。如果路径以斜杠（Slash）开头，则从根开始计算；否则，从当前目录开始（5509-5512）。然后，它使用skipelem依次考虑路径的每个元素（5514）。循环的每次迭代都必须在当前inode ip中查找名称。迭代首先要锁定ip并检查它是否为目录。如果不是，查找将失败（5515-5519）。（锁定ip是必要的，不是因为ip-type可以在脚底更改（change underfoot，它不能），而是因为在ilock运行之前，不能保证从磁盘加载了ip类型。如果调用是nameiparent和并且是最后一个路径元素，则循环会根据nameiparent的定义提前结束，最终路径元素已被复制到名称中, 因此namex只需返回解锁的ip（5520-5524）。最后循环会使用dirlookup查找路径元素并通过设置ip = next （5525-5530）为下一次迭代做准备。当循环用完路径元素时，它返回ip。 File descriptor layerUnix接口的一个很酷的方面是，Unix中的大多数资源都可以表示为文件，包括控制台、管道等设备，当然还有实际文件。文件描述符是实现这种一致性（uniformity）的层。 正如我们在第0章中看到的那样，Xv6为每个进程提供了独有的打开文件表或文件描述符。每个打开的文件都由一个struct file（4000）表示，该结构是一个inode或pipe 的包装，外加上一个I/O偏移量。Open的每次调用都会创建一个新的打开文件（一个新的struct file）：如果多个进程独立打开同一文件，则不同的实例将具有不同的I/O偏移量。另一方面，单个打开的文件（相同的结构文件）可以在一个进程的文件表中多次出现，也可以在多个进程的文件表中出现。如果一个进程使用open去打开文件，然后使用dup创建别名，或者使用fork与子进程共享，则会发生这种情况。引用计数值跟踪对特定打开文件的引用数。文件可以打开读取或写入，也可以同时。readable和writable字段跟踪这一点。 系统中所有打开的文件都保存在全局文件表中。文件表具有分配文件（filealloc）、创建重复引用（filealloc）、释放引用（filecloc）以及读取和写入数据（filealloc和filealloc）的函数。 前三个遵循现在熟悉的形式。Filealloc（5625）扫描文件表中的未引用文件（f-&gt;ref == 0），并返回新引用；filedup（5652）递增引用计数；fileclose（5664）减少它。当文件的引用计数达到零时，fileclose会根据类型释放基础管道或inode。 函数filestat、fileread和filewrite实现文件上的stat、read和write操作。Filestat（5702）只允许作用在inodes和调用stati。Fileread和filewrite通过open mode检查操作是否被允许，然后将调用传递给管道或inode实现。如果文件表示inode，则fileread和filewrite使用I/O偏移量作为操作的偏移量，然后将其推进（5725-5726、5765-5766）。管道没有偏移量的概念。回想一下，inode函数要求调用方处理锁定（5705-5707，5724-5727，5764-5778）。Inode锁定具有一种方便的副作用，即读取和写入偏移量以原子方式进行更新，因此同时对同一文件的多次写入不能覆盖彼此的数据，尽管它们的写入最终可能会相互交错。 Code: System calls使用较低层提供的大多数系统调用实现的功能是微不足道的（trivial，请参见sysfile.c）。但仍有几个调用值得仔细研究。 函数sys_link和sys_unlink编辑目录，创建或删除对inodes的引用。它们是使用事务的力量的另一个很好的例子。Sys_link（5913）从获取其参数开始，一个新字符串和一个旧的字符串（5918）。假设旧的存在，且不是一个目录（5922-5925），sys_link增加其ip-&gt;nlink。然后，sys_link调用nameiparent来查找新字符串的（5938）的父目录和最终路径元素，并创建一个指向旧inode（5938）的新目录条目。新的父目录必须存在，并且与现有inode位于同一设备上：inode数字在单个磁盘上只有唯一的含义。如果发生这样的错误，sys_link必须返回并减少ip-&gt;nlink。 事务简化了实现，因为虽然它需要更新多个磁盘块，但我们不必担心执行这些操作的顺序。他们要么都成功，要么不成功。例如，如果没有事务，在创建链接之前更新ip-&gt;nlink会使文件系统暂时处于不安全状态，而两者之间的崩溃可能会导致严重破坏(havoc)。有了事务，我们不必担心这一点。 Sys_link为现有的inode创建一个新名称。函数create（6057）为新的inode创建一个新名称。它是三个文件创建系统调用的泛化：使用O_CREATE标志的open创建一个新的普通文件，mkdir 创建一个新的目录，mkdev创建一个新的设备文件。与sys_link一样，create通过调用nameiparent来得到父目录的inode。然后，它调用dirlookup来检查名称是否已经存在（6067）。如果名称确实存在，则create的行为取决于它所使用的系统调用：open与mkdir和mkdev具有不同的语义。如果create是代表open使用的（type == T_FILE）并且存在的名称本身就是一个常规文件，则open该名称将其视为成功，因此也可以创建（6071）。否则，它是一个错误（6072-6073）。如果名称不存在，create通过ialloc（6076）创建一个新的inode。如果新的inode是一个目录，create初始化它…条目。最后，既然数据已正确初始化，create可以将其链接到父目录（6089）。create，像sys_link，同时持有两个inode的锁：ip和dp。不存在死锁的可能性，因为inode ip是新分配的：系统中没有其他进程会持有ip锁，然后尝试锁定dp。 使用create，可以很容易地实现sys_open、sys_mkdir和sys_mnod。Sys_open（6101）是最复杂的，因为创建新文件只是它所能做的事情的一小部分。如果打开的是O_ CREATE标志，则调用create（6114）。否则，它调用namei（6120）。Create返回锁定的inode，但namei不返回，因此sys_open必须锁定inode本身。这提供了一个方便的地方来检查目录是否只为读取而不是写入打开。假设inode是以这样或那样的方式获得的，sys_open会分配一个文件和一个文件描述符（6132），然后填充该文件（6142-6146）。请注意，没有其他进程可以访问部分初始化的文件，因为它只在当前进程的表中。 在我们有一个文件系统之前，第5章就讲述了管道的实现。函数sys_pipe通过提供一种创建管道对的方法，将该实现连接到文件系统。它的参数是指向两个整数的空间的指针，它将在其中记录两个新的文件描述符。然后，它分配管道并安装文件描述符。 Real world现实操作系统中的缓冲区缓存比xv6要复杂得多，但它提供了同样的两个用途：缓存和同步对磁盘的访问。Xv6 的缓冲区缓存与V6一样，使用的是最近使用的简单（LRU）逐出策略；有许多更复杂的策略可以实现，每个策略对某些工作负载都有好处，但对其他工作负载就没有那么好。更高效的LRU缓存将消除链接列表，而是使用哈希表进行查找，并为LRU驱逐策略使用堆。现代缓冲区缓存通常与虚拟内存系统集成，以支持内存映射文件。 Xv6的日志记录系统效率低下。提交不能与文件系统调用同时进行。系统记录整个块，即使只更改了块中的几个字节。它执行同步日志写入，一次一个块，每个块都可能需要整个磁盘旋转时间。真正的日志记录系统解决了所有这些问题。 日志记录并不是提供崩溃恢复的唯一方法。早期的文件系统在重新启动期间使用了清除器（scacenger）（例如，UNIX的fsck程序）来检查每个文件和目录以及块和inode空闲列表，查找和解决不一致的问题。清除大型文件系统可能需要数小时，在某些情况下，无法以导致原始系统调用为原子的方式解决不一致问题。从日志中恢复的速度要快得多，并导致系统调用在发生崩溃时是原子的。 Xv6使用与早期UNIX相同的INODES和目录的基本磁盘布局；多年来，这一计划一直非常持久。BSD的UFS/FFS和Linux的ext2ext3使用的数据结构基本相同。文件系统布局中最低效的部分是目录，它需要在每次查找过程中对所有磁盘块进行线性扫描。当目录只有几个磁盘块时，这是合理的，但对于包含许多文件的目录来说，成本很高。仅举几例，微软Windows的NTFS、Mac OS X’s HFS和Solaris的ZFS，实现了一个目录作为磁盘上的平衡树块。这很复杂，但保证了对数时间目录查找。 Xv6对磁盘故障很天真：如果磁盘操作失败，xv6就会恐慌。这是否合理取决于硬件：如果操作系统位于使用冗余来屏蔽磁盘故障的特殊硬件之上，则操作系统可能很少看到故障，从而认为panic是可接受的。另一方面，使用普通磁盘的操作系统应该做好出现故障的准备，并更优雅地处理这些故障，因此在一个文件中丢失一个块不会影响文件系统其余部分的使用。 Xv6要求文件系统适合一个磁盘设备，并且大小不变。随着大型数据库和多媒体文件对存储的要求越来越高，操作系统正在开发消除”每个文件系统一个磁盘”瓶颈的方法。基本方法是将多个磁盘合并到一个逻辑磁盘中。RAID等硬件解决方案仍然是最流行的解决方案，但目前的趋势是尽可能多地在软件中实现这种逻辑。这些软件实现通常允许丰富的功能，如通过动态添加或删除磁盘来增长或收缩逻辑设备。当然，可以动态增长或收缩的存储层需要一个可以执行同样操作的文件系统: xv6使用的固定大小的inode块数组在这种环境中无法正常工作。 将磁盘管理与文件系统分开可能是最干净的设计，但两者之间的复杂接口导致一些系统（如Sun 的ZFS）将它们组合在一起。 Xv6的文件系统缺乏现代文件系统的许多其他功能；例如，它缺乏对快照和增量备份的支持。 现代Unix系统允许使用与磁盘存储相同的系统调用访问多种资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口（如/procp）。这些系统通常为每个打开的文件提供一个函数指针表，每个操作一个，并调用函数指针来调用inode对调用的实现，而不是在fileread和filewrite中的xv6的语句。网络文件系统和用户级文件系统提供的功能可将这些调用转换为网络RPCS，并等待响应后再返回。 Exercises Why panic in balloc? Can xv6 recover? Why panic in ialloc? Can xv6 recover? Why doesn’t filealloc panic when it runs out of ﬁles? Why is this more common and therefore worth handling? Suppose the ﬁle corresponding to ip gets unlinked by another process between sys_link’s calls to iunlock(ip) and dirlink. Will the link be created correctly? Why or why not? create makes four function calls (one to ialloc and three to dirlink) that it requires to succeed. If any doesn’t，create calls panic. Why is this acceptable? Why can’t any of those four calls fail? sys_chdir calls iunlock(ip) before iput(cp-&gt;cwd)，which might try to lock cp-&gt;cwd，yet postponing iunlock(ip) until after the iput would not cause deadlocks. Why not?]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell script & Make]]></title>
    <url>%2F2019%2F04%2F13%2FLinux-Make-Shell%2F</url>
    <content type="text"><![CDATA[Shell script和Makefile Shell Script我们已经编写过简单的Shell，其就是与系统沟通的工具，而Shell script则是利用Shell的语法和命名，并搭配正则表达式、管道等功能实现的纯文本文件，由Shell去解释执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# test.hmy_name="xzy"echo $my_name#readonly variablereadonly my_name#can not use like this# my_name="xxx"#delete this variable,#but still can not do like this#cause my_name is readonly varible# unset my_name#string variablestr_1='my name is \"xzy\"'str_2="my name is \"xzy\""echo $str_1echo $str_2#string joinstr_3="hello,$str_2"echo $str_3#string lengthecho $&#123;#str_3&#125;#get substring#first variable is start#second variable is the length of substringecho $&#123;str_3:18:3&#125;#search substring#find the first index of x,z or yecho `expr index "$str_3" xzy`#arrayval_1=1val_2=2val_3=3array=($val_1,$val_2,$val_3)#get all elementsecho $&#123;array[@]&#125;#get length of arrayecho $&#123;#array[*]&#125;#get parameter pass to shell script #$0 is file's nameecho $0echo $1#$# is count of parameterecho $##$$ is progress'IDecho $$#process controlif test $str_3 = $str_2then echo "same"else echo "diff"fifor var in arraydo echo $vardone#functionfunc()&#123; echo "function" echo $1&#125;func xzy#include file. ./test_2.shecho $url 12#test_2.shurl="123xzy.github.com" 上面基本上囊括了Shell script的基本用法，除了一些变量比较的命令没有列出来，要熟练掌握，主要还是要不断书写、练习 Makefile1234target ... : prerequisites ... command ... ... target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label）。prerequisites就是，要生成那个target所需要的文件或是目标。command也就是make需要执行的命令。（任意的Shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 123456789101112131415161718192021222324252627# Students' Makefile for the Malloc Lab#TEAM = bovikVERSION = 1HANDINDIR = /afs/cs.cmu.edu/academic/class/15213-f01/malloclab/handinCC = gccCFLAGS = -Wall -O2 -m32 -gOBJS = mdriver.o mm.o memlib.o fsecs.o fcyc.o clock.o ftimer.omdriver: $(OBJS) $(CC) $(CFLAGS) -o mdriver $(OBJS)mdriver.o: mdriver.c fsecs.h fcyc.h clock.h memlib.h config.h mm.hmemlib.o: memlib.c memlib.hmm.o: mm.c mm.h memlib.hfsecs.o: fsecs.c fsecs.h config.hfcyc.o: fcyc.c fcyc.hftimer.o: ftimer.c ftimer.h config.hclock.o: clock.c clock.hhandin: cp mm.c $(HANDINDIR)/$(TEAM)-$(VERSION)-mm.cclean: rm -f *~ *.o mdriver 在默认的方式下，也就是我们只输入make命令。那么， make会在当前目录下找名字叫“Makefile”或“makefile”的文件 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“mdriver”这个文件，并把这个文件作为最终的目标文件 如果“mdriver”文件不存在，或是“mdriver”所依赖的后面的.o 文件的文件修改时间要比edit这个文件新，那么他就会执行后面所定义的命令来生成“mdriver”这个文件 如果“mdriver”所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Shell script</tag>
        <tag>Make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《独立功能的实现》]]></title>
    <url>%2F2019%2F04%2F13%2FRedis%EF%BC%9A%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Chapter 4]]></title>
    <url>%2F2019%2F04%2F13%2FMIT-6-828-book-xv6-Chapter-4%2F</url>
    <content type="text"><![CDATA[Xv6在多处理器上运行，多核CPU的计算机独立执行代码。这些多核CPU在单个物理地址空间上运行，并共享数据结构；xv6必须引入一个协调机制，以防止它们相互干扰。即使在单处理器上，xv6也必须使用某种机制来防止中断处理程序干扰非中断代码。Xv6对两者都使用相同的低级概念：锁。锁提供互斥，确保一次只能有一个CPU拥有锁。如果xv6仅访问数据结构，同时持有特定的锁，则xv6可以确保一次只有一个CPU访问数据结构。在此情况下，我们说锁保护了数据结构。 MIT 6.828 Operating System Engineering 本章的其余部分解释了为什么xv6需要锁，xv6是如何实现锁的，以及它是如何使用锁的。一个关键的观察是，如果你看xv6中的一行代码，你必须问自己，是否有另一个处理器可以改变该行的预期行为（例如，因为另一个处理器也在执行该行或另一行代码去修改共享变量），以及如果中断处理程序运行时会发生什么情况。在这两种情况下，您必须记住，一个C语句可以是多条机器指令，因此另一个处理器或中断可能会在C语句的中间出现。不能假定页面上的代码行是按顺序执行的，也不能假定单个C语句将以原子方式执行。并发使得对正确性的推理变得更加困难。 Race condition作为为什么我们需要锁的示例，请考虑共享单个磁盘的多个处理器，例如xv6中的IDE磁盘。磁盘驱动程序维护重要的磁盘请求（4121）的链表，处理器可以同时向列表中添加新请求（4254）。如果没有并发请求，则可以向下面这样实现链表：12345678910111213141516struct list &#123; int data; struct list *next; &#125;; struct list *list = 0; void insert(int data) &#123; struct list *l; l = malloc(sizeof *l); l-&gt;data = data; l-&gt;next = list; list = l; &#125; 证明此实现正确是数据结构和算法类中的典型练习。尽管这种实现可以被证明是正确的，但它不是正确的，至少在多处理器上不是。如果两个不同的CPU同时执行insert，则可能会在执行16之前执行第15行（参见图4-1）。如果发生这种情况，现在将有两个列表节点，每个节点的node设置为list的前一个值。当list的两个赋值发生在第16行时，第二个分配将覆盖第一个分配；第一个分配中涉及的节点将丢失。这种问题被称为race condition。race的问题在于，它们取决于所涉及的两个CPU的确切时间，以及它们的内存操作是如何由内存系统排序的，因此很难重现。例如，在调试插入时添加打印语句可能会更改执行的时间，从而使竞争消失。 避免race的典型方法是使用锁。锁确保相互排斥（mutual exclusion），因此一次只能执行一个 CPU的Insert；这使得上面的场景是不可能的。上述代码的正确锁定版本只添加几行（未编号）：1234567891011121314struct list *list = 0; struct lock listlock; void insert(int data) &#123; struct list *l; acquire(&amp;listlock); l = malloc(sizeof *l); l-&gt;data = data; l-&gt;next = list; list = l; release(&amp;listlock); &#125; 当我们说锁保护数据时，我们实际上意味着锁保护一些适用于数据的不变量（invariants）集合。不变量是在操作时维护的数据结构的属性。通常，操作的正确行为取决于操作开始时的不变量是否为true。该操作可能会暂时违反（violate）不变量，但必须在完成之前重新建立它们。例如，在链表中，不变量是列表中第一个节点上的节点，以及每个节点的next字段指向的下一个节点。Insert的实现暂时违反了这一不变量：第13行创建了一个新的列表元素l，目的是使l是列表中的第一个节点，但l的next指针尚未指向列表中的下一个节点（在第15行重新建立），并且list还没有指向l（重新建立在第16行）。我们上面检查的race condition之所以发生，是因为第二个CPU执行的代码依赖于列表不变量，而这些代码暂时破坏了不变量。正确使用锁可确保一次只能有一个CPU对数据结构进行操作，因此，当没有持有数据结构的不变量，CPU不会执行数据结构操作。 Code: LocksXv6把锁表示为struct spinlock（1501，自旋锁）。结构中的关键字段是locked，当锁可用时，该字为零，在持有时为非零。从逻辑上讲，xv6应该通过执行代码来获取锁，如12345678910void acquire(struct spinlock *lk) &#123; for(;;) &#123; if(!lk-&gt;locked) &#123; lk-&gt;locked = 1; break; &#125; &#125;&#125; 遗憾的是，此实现不能保证在现代多处理器上相互排斥。可能会发生两个（或更多）CPU同时到达第25行，看到 lk-&gt;locked为零，然后通过执行第26行和第27行抓住锁。此时，两个不同的CPU持有锁，这违反了相互排除的属性。acquire的这种实现并没有帮助我们避免race condition，而是有自己的race condition。这里的问题是第25行和第26行作为单独的操作执行。为了使上述例程正确，第25行和第26行必须在一个原子（即不可分割）步骤中执行。 要以原子方式执行这两行，xv6依赖于特殊的386硬件指令xchg（0569）。在一个原子操作中，xchg将内存中的字与寄存器的内容交换。函数acquire（1574）在循环中重复此xchg指令；每次迭代读取lk-&gt;locked，并以原子方式将其设置为1（1583）。如果锁被持有，lk-&gt;locked将已经是 1，因此xchg返回1，循环继续。但是，如果xchg返回0，则acquire已成功获取锁，之前locked为0，现在则为1，因此循环可以停止。一旦获取锁，为了用于调试，acquire会记录获取锁的CPU和堆栈跟踪。当一个进程获取锁而忘记释放它时，这些信息可以帮助识别罪魁祸首。这些调试字段受锁保护，只能在持有锁的情况下进行编辑。 函数release（1602）与acquire相反: 它清除调试字段，然后释放锁。 Modularity and recursive locks系统设计追求干净的模块化抽象：调用方不需要知道被调用方如何实现特定功能。锁的接口会干扰此模块化。例如，如果CPU持有特定的锁，它就不能调用任何试图重新获取该锁的函数f：因为调用方在f返回之前无法释放锁，因此，如果f尝试获取相同的锁，它将永远自旋或死锁。 没有透明的解决方案允许调用方和被调用方隐藏他们使用的锁。一个常见的、透明但不能令人满意的解决方案是递归锁，它允许被调用方重新获取其调用方已经持有的锁。此解决方案的问题在于，递归锁不能用于保护不变量。在上面insert调用acquire（&amp;listlock）之后，它可以假定没有其他函数持有锁，没有其他函数在列表操作的中间，最重要的是持有所有列表不变量。在具有递归锁的系统中，insert在调用acquire后不能保证任何内容：也许acquire成功只是因为insert的一个调用方已经持有锁，并且正在编辑列表数据结构。他们可能只有不变量，也可能没有。该列表不再保护它们。锁对于保护调用者和被调用者之间的隔离与保护不同CPU之间的隔离同样重要；递归锁则放弃了这个性质。 由于没有理想的透明解决方案，我们必须考虑锁作为函数规范的一部分。程序员必须安排该函数在持有f所需的锁的同时不调用函数f。Locks强制程序员进入我们定义的抽象中。 Code: Using locksXv6小心使用锁来编程，以避免出现race conditions。一个简单的示例是IDE driver（4100）。如本章开头所述，iderw（4254)）有一个磁盘请求队列，处理器可以同时向列表中添加新的请求（4254）。为了保护此列表和驱动程序中的其他不变量，iderw要acquire idelock（4265）并在函数结束时release。练习1探讨如何触发我们在本章开头看到的竞争条件，方法是将acquire移动到队列操作之后。尝试这个练习是值得的，因为它将明确触发race并不那么容易，这表明很难找到race-conditions的BUG。xv6依旧可能存在一些races。 使用锁的一个困难部分是决定要使用多少锁，以及每个锁保护哪些数据和不变量。这里有一些基本原则。首先，当一个CPU可以在另一个CPU可以读取或写入变量的同时编写这个变量时，都应引入一个锁，以防止这两个操作重叠。其次，请记住锁保护不变量：如果不变量涉及多个数据结构，则通常所有结构都需要由单个锁保护，以确保保持不变量。 上面的规则说明锁何时必要，但对锁何时不必要什么都不说，为了提高效率，重要的是不要锁定太多，因为锁减少了并行性。如果效率并不重要，那么人们可以使用单处理器计算机，根本不用担心锁。为了保护内核数据结构，只需创建一个在进入内核时必须获取并在退出内核时释放的锁就足够了。许多单处理器操作系统已被转换为在多处理器上运行使用这种方法，有时被称为”巨大的内核锁”，但该方法牺牲了真正的并发性：一次只能有一个CPU在内核中执行。如果内核执行任何繁重的计算，则使用更大的一组更细粒度的锁将更有效，以便内核可以同时在多个CPU上执行。 最终，锁粒度的选择是并行编程中的一项练习。Xv6使用一些粗糙的数据结构特定的锁；例如，xv6使用单个锁保护进程表及其不变量，如第5章所述。更精细的方法是在进程表中对每个条目都有一个锁，以便在进程表中处理不同条目的线程可以并行进行。但是，它使在整个进程表上具有不变的操作复杂化，因为它们可能必须取出多个锁。希望xv6的示例将有助于传达如何使用锁。 Lock ordering如果通过内核的代码路径必须获得多个锁，则所有代码路径都必须以相同的顺序获取锁，这一点很重要。如果他们不这样做，就有陷入死锁的危险。假设xv6中的两个代码路径需要锁A和B，但代码路径1按顺序A和B获取锁，而其他代码按顺序B和A获取锁。这种情况可能会导致死锁，因为代码路径1可能会获取锁A，在它获取锁B之前，代码路径2可能会获取锁B。现在这两个代码路径都不能继续，因为代码路径1需要锁定B，而B现在由代码2持有，代码路径2需要锁定A，但其由代码路径1持有A。为了避免这种死锁，所有代码路径都必须以相同的顺序获取锁。避免死锁说明了锁必须是函数规范（function’s speciﬁcation）的一部分：调用方必须以一致的顺序调用函数，以便函数以相同的顺序获取锁。 因为xv6使用粗粒度的锁，xv6很简单，所以xv6几乎没有锁序链（lock-order chains）。最长的链子只有两层深（two deep）。例如，ideintr在调用wakeup时持有ide锁，wakeup则需要获取ptable锁。还有很多其他涉及sleep和wakeup的例子。这些命令的产生是因为sleep和wakeup有一个复杂的不变量，如第5章所述。在文件系统中有许多两个链的示例，因为文件系统必须获取目录上的锁和该目录中文件上的锁，才能正确地从其父目录中取消文件的链接。Xv6总是按顺序获取锁的第一个父目录，然后是文件。 Interrupt handlersXv6使用锁保护在一个CPU上运行的中断处理程序不受访问另一个CPU上相同数据的非中断代码的影响。例如，计时器中断处理程序（3364）会增加ticks，但另一个CPU可能同时处于sys_sleep状态，也使用相同变量（3723）。锁tickslock同步两个CPU对单个变量的访问。 中断甚至在单个处理器上也会导致并发：如果启用了中断，则可以随时停止内核代码以运行中断处理程序。假设iderw拿着idelock，然后被中断去运行ideintr。Ideintr会试图锁定idelock，看到它被持有，并等待它被释放。在这种情况下，idelock永远不会被释放–只有iderw才能释放它，而且在ideintr返回之前，iderw不会继续运行–因此处理器，最终整个系统将死锁。 若要避免这种情况，如果中断处理程序使用锁，处理器绝不能在启用中断的情况下持有该锁。Xv6更为保守：在启用中断时，它从不持有任何锁。它使用pushcli（1655）和popcli（1665）来管理堆栈的”禁用中断”操作（cli是x86的禁用中断指令）。在尝试获取锁（1576）之前Acquire调用pushcli，并在释放锁（1621）后release调用popcli。Pushcli（1655）和popcli（1666）不仅仅是cli和sti的包装：，函数内存还存在计数器，因此需要两个调用popcli才能撤销两次调用pushcli；这样，如果代码获取两个不同的锁，中断将不会重新启用，直到两个锁都被释放。 在xchg可能获得锁之前让acquire去调用pushcli很重要。如果交换两者位置，则在启用中断的情况下持有锁在几个指令周期之后，不幸的定时中断就会使系统死锁。同样，只有在xchg释放锁（1583）之后，release才调用popcli也很重要。 中断处理程序和非中断代码之间的交互提供了一个很好的示例，说明了递归锁存在问题的原因。如果xv6使用递归锁（如果第一次获取也发生在CPU上，则允许在CPU上进行第二次获取），则中断处理程序可以在非中断代码处于关键部分时运行。这可能会造成严重破坏，因为当中断处理程序运行时，处理程序所依赖的不变量可能会被暂时违反。例如，ideintr（4202）假定具有未完成请求的链表格式正确。如果xv6使用递归锁，则ideintr可能会在idew正在操作链接列表时运行，并且链表最终将处于不正确的状态。 Memory ordering本章假定处理器按照它们在程序中出现的顺序启动和完成指令。但是，许多处理器执行指令的顺序不正常，以实现更高的性能。如果指令需要多个周期才能完成，处理器可能希望提前发出指令，以便它可以与其他指令重叠并避免处理器停滞。例如，处理器可能会注意到，在指令A和B的串行序列中，A和B并不相互依赖，并在A之前启动指令B，以便在处理器完成A时完成指令B，但是并发性可能会将这种重新排序暴露给软件，这将导致不正确的行为。 例如，人们可能想知道，如果release只是将0分配给lk-&gt;locked，而不是使用xchg，会发生什么情况。这个问题的答案不清楚，因为不同代的x86处理器对内存排序做出了不同的保证。如果lk-&gt;locked=0，允许在popcli之后重新排序，则acquire可能会中断，因为在释放锁之前将启用另一个线程中断。为了避免依赖不明确的处理器规格有关内存排序，xv6不承担任何风险，并使用xchg，即处理器必须保证不重新排序。 Real world并发原语和并行编程是研究的活跃领域，因为使用锁编程仍然具有挑战性。最好使用锁作为较高级别的构造（如同步队列）的基础，尽管xv6并不这样做。如果您使用锁编程，则明智的做法是使用尝试识别竞争条件的工具，因为很容易错过需要锁的不变量。 用户级程序也需要锁，但在xv6应用程序中只有一个执行线程，进程不共享内存，因此xv6应用程序中不需要锁。 可以在没有原子指令的情况下实现锁，但成本很高，大多数操作系统都使用原子指令。 当锁满足时，原子指令也不是免费的。如果一个处理器在其本地缓存中缓存了一个锁，而另一个处理器必须获取锁，则更新持有锁的行的原子指令必须将该行从一个处理器的缓存移动到另一个处理器的缓存中，然后可能使其失效缓存行的任何其他副本。从另一个处理器的缓存中获取缓存行的成本可能比从本地缓存中获取一行的成本要高出数级。 为了避免与锁相关的开销，许多操作系统使用无锁定数据结构和算法，并尝试避免这些算法中的原子操作。例如，可以实现一个链表，如本章开头的链表，在列表搜索过程中不需要锁定，以及只需要一个原子指令在链表中插入项。 Exercises Remove the xchg in acquire. explain what happens when you run xv6? Move the acquire in iderw to before sleep. is there a race? why don’t you observe it when booting xv6 and run stressfs? increase critical section with a dummy loop; what do you see now? explain. Setting a bit in a buﬀer’s flags is not an atomic operation: the processor makes a copy of flags in a register，edits the register，and writes it back. Thus it is important that two processes are not writing to flags at the same time. xv6 edits the B_BUSY bit only while holding buflock but edits the B_VALID and B_WRITE ﬂags without holding any locks. Why is this safe?]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.824 Lab:MapReduce]]></title>
    <url>%2F2019%2F04%2F09%2FMIT-6-824-Lab-MapReduce%2F</url>
    <content type="text"><![CDATA[构建MapReduce库 MIT 6.824 Distributed System 简介在本实验中，将构建一个MapReduce库，熟悉如何使用Go中编程和构建容错分布式系统。在第一部分中，将编写一个简单的MapReduce程序。在第二部分中，您将编写一个Master，将任务分发给MapReduce的workers，并处理workers的失败 首先从网上获取实验需要的源代码，并熟悉。开始实验之前最好先熟悉一下go语言 接下来的任务就是编写/修改doMap，doReduce。。您还必须在../main/wc.go中编写map和reduce函数。 Part I: Map/Reduce input and outputMap/Reduce实现缺少一些部分。在编写第一个Map/Reduce函数之前，需要修复sequential实现。特别是，我们给你的代码缺少两个关键部分：分割map任务输出的函数，以及收集reduce任务的所有输入的函数。这些任务分别由common_map.go中的doMap()函数和common_reduce.go中的doReduce()函数执行。这些文件中的注释应该指向正确的方向。 为了帮助您确定是否正确实现了doMap()和doReduce()，我们为您提供了一个Go测试套件，用于检查实现的正确性。这些测试在test_test.go文件中实现。加入参数-v获得测试更多的信息，用于调试 run参数表示测试mapreduce文件夹下test_test.go文件中以Test开头包含Sequential的测试函数，即TestSequentialSingle和TestSequentialMany函数。]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.824 Distributed System]]></title>
    <url>%2F2019%2F04%2F09%2FMIT-6-824-Distributed-System%2F</url>
    <content type="text"><![CDATA[MIT6.824 分布式系统课程 MIT 6.824 是一门被广泛好评的分布式系统课程。它最重要的特点就是它实践第一的教学原则。在这门课程中会涉及到非常丰富的实验，也会有非常多的动手机会。和MIT 6.828课程一样，做到规范，认真完成lab。 这门课的不同点在于要阅读大量论文，通过研究论文，来阐述了关键思想和重要细节，许多主题讨论都集中在论文上 这一系列文章会包括以下几个内容： Lab：MIT 6.824 Lab *** 资源lab guide：实验时刻表，链接 目录Lab MIT 6.824 Lab:MapReduce PaperGoogle MapReduce]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Assignment:Boot xv6]]></title>
    <url>%2F2019%2F04%2F08%2FMIT-6-828-Assignment-Boot-xv6%2F</url>
    <content type="text"><![CDATA[启动！ MIT 6.828 Operating System Engineering CPU上电时执行的第一条指令是jump存储在ROM中的指令。BIOS将把存储在硬盘第一扇区中的512字节引导扇区加载到物理地址0x7c00到0x7dff的内存中。接下来，是时候执行引导加载程序代码（从实模式切换到保护模式）并进入内核 先在0x7c00处切断点，看看在执行boot loader之前，寄存器和堆栈的状况。可以看到%eip存储CPU要读取指令的地址，段寄存器%ss为0，也就是处于实模式下 当要正式进入boot loader（即boot main）之前，查看寄存器和堆栈的情况。栈顶寄存器%esp初始化为正确的0x7c00，段寄存器%ss也表示此时处于保护模式下 再单步运行一步，发现将%esp的值（也就是返回地址）推入堆栈。所有准备工作做好，就要正式进入boot main 其实做到这步，能理顺整个流程，其实这个assignment也就完成了。在回头看看一开始的要求 第一步：找到内核的入口点_start 第二步，在该入口点切断点，并查看相关寄存器堆栈内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Assignment:System Calls]]></title>
    <url>%2F2019%2F04%2F08%2FMIT-6-828-Assignment-System-Calls%2F</url>
    <content type="text"><![CDATA[系统调用 MIT 6.828 Operating System Engineering System call tracing在进行系统调用时，打印出系统调用的名字和返回值。提醒也很明显，就是修改syscall.c/syscall()函数， 123456789101112131415161718192021222324252627282930313233343536373839404142char* syscall_name[22] =&#123; [SYS_fork] "fork", [SYS_exit] "exit", [SYS_wait] "wait", [SYS_pipe] "pipe", [SYS_read] "read", [SYS_kill] "kill", [SYS_exec] "exec", [SYS_fstat] "fstat", [SYS_chdir] "chdir", [SYS_dup] "dup", [SYS_getpid] "getpid", [SYS_sbrk] "sbrk", [SYS_sleep] "sleep", [SYS_uptime] "uptime", [SYS_open] "open", [SYS_write] "write", [SYS_mknod] "mknod", [SYS_unlink] "unlink", [SYS_link] "link", [SYS_mkdir] "mkdir", [SYS_close] "close",&#125;;voidsyscall(void)&#123; int num; struct proc *curproc = myproc(); num = curproc-&gt;tf-&gt;eax; if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123; curproc-&gt;tf-&gt;eax = syscalls[num](); cprintf("%s -&gt; %d\n",syscall_name[num],curproc-&gt;tf-&gt;eax); &#125; else &#123; cprintf("%d %s: unknown sys call %d\n", curproc-&gt;pid, curproc-&gt;name, num); curproc-&gt;tf-&gt;eax = -1; &#125;&#125; Date system call第二个任务是添加新的系统调用，去获取当前时间并返回给用户程序。此时需要辅助函数cmostime() （在lapic.c中定义）来读取实时时钟。date.h包含struct rtcdate结构的定义，作为提供给cmostime()的指针参数 重新定义一个系统调用需要修改一下文件，另外还需要新建一个用户程序12345syscall.csyscall.huser.cusys.Sxxx.c 对于系统调用的流程还是不清楚，这个assignment也是跟着网上写的，看完第三章，再回过头整理]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Chapter 2]]></title>
    <url>%2F2019%2F04%2F07%2FMIT-6-828-book-xv6-Chapter-2%2F</url>
    <content type="text"><![CDATA[页表 MIT 6.828 Operating System Engineering 页表是操作系统控制内存地址含义的机制。它们允许xv6将不同进程的地址空间复用到一个物理内存上,并保护不同进程的内存。页面表提供的间接级别也是许多巧妙技巧的来源。xv6主要使用页表来复用地址空间和保护内存。它还使用了一些简单的页表技巧：在多个地址空间中映射相同的内存（内核），在一个地址空间中多次映射相同的内存（每个用户页面也映射到内核的物理内存视图中），以及保护用户堆栈用一个未映射的页面。本章的其余部分解释了x86硬件提供的页表以及xv6如何使用这些页表。 分页硬件作为提醒，x86指令（包括用户和内核）操作虚拟地址。计算机的RAM（物理内存）使用物理地址索引。X86页表硬件通过将每个虚拟地址映射到物理地址来连接这两种地址。 从逻辑上讲，x86页表是由$2^{20}(1,048,576)$个页表项（PTEs，page table entries）组成的数组。每个PTE都包含一个20位的物理页码（PPN，physical page number ） 和一些标志。分页硬件通过使用其前20位索引到页面表中查找PTE，并将地址的前20位替换为 PTE中的PPN，从而转换虚拟地址。分页硬件将较低的12位从虚拟复制到已翻译的物理地址。因此，页表提供了操作系统对$4096(2^{12})$字节对齐块的粒度的虚拟到物理地址转换的控制。这样的块称为页。 如图2-1所示，实际转换分两个步骤进行。页表作为两级树（two-level tree）存储在物理内存中。树的根目录是4096字节的页目录，其中包含对页表页的1024个类似于PTE的引用。每个页面页是一个包含1024个32位PTE的数组。分页硬件使用虚拟地址的前10位来选择页目录项。如果存在页目录项，分页硬件将使用虚拟地址的接下来10位从页面目录项所引用的页面表页中选择PTE。如果页目录项或PTE不存在，分页硬件将引发故障。这种两级结构允许页表在大量虚拟地址没有映射的常见情况下省略整个页表页。 每个PTE都包含标志位，这些标记位告诉分页硬件是否允许使用关联的虚拟地址。PTE_P指示PTE是否存在：如果未设置PTE，则对页面的引用会导致错误。PTE_W控制是否允许指令对页面进行写入；如果未设置，则只允许读取指令。PTE_U控制是否允许用户程序使用该页面；如果清除，则只允许内核使用该页面。图2-1 显示了它是如何工作的。标志和所有其他页面硬件相关结构在mmu.h（0700）中定义。 一些关于术语的说明。物理内存是指DRAM中的存储单元。物理内存的每个字节有一个地址，称为物理地址。指令仅使用虚拟地址（分页硬件将其转换为物理地址），然后发送到DRAM硬件以读取或写入存储。在这个层次的讨论中，没有虚拟内存这样的东西，只有虚拟地址。 进程地址空间 由entry创建的页表具有足够的映射，以允许内核的C代码开始运行。但是，main通过调用kvmalloc（1857）立即切换到新的页面表，因为内核有一个更详细的描述进程地址空间的计划。 进程有一个单独的页面表，xv6告诉页面表硬件在进程之间切换时切换页表。如图2-2所示，进程的用户内存从虚拟地址零开始，并可以增长为KERNBASE，从而允许进程处理多达2GB的内存。文件memlayout.h（0200）声明xv6内存布局的常量，以及将虚拟转换为物理地址的宏。 当进程要求xv6提供更多内存时，xv6首先找到可用的物理页来提供存储，然后将PTES添加到指向新物理页的进程页表中。xv6在这些PTES中设置PTE_U、PTE_W和PTE_P标志。大多数进程不使用整个用户地址空间；xv6在未使用的PTES中清除PTE_P标志。不同进程的页面表将用户地址转换为不同的物理内存页，以便每个进程都有私有用户内存。 Xv6包括内核在每个进程的页面表中运行所需的所有映射；这些映射都出现在KERNBASE上方。它将虚拟地址KERNBASE:KERNBASE+PHYSTOP映射到0:PHYSTOP。此映射的一个原因是内核可以使用自己的指令和数据。另一个原因是内核有时需要能够编写给定的物理内存页，例如在创建页表页时；让每个物理页面都显示在可预测的虚拟地址，这就很方便了。这种安排的一个缺陷是xv6不能使用超过2GB的物理内存。一些使用内存映射的I/O设备出现在0xFE000000开始的物理地址上，因此xv6页表包括它们的直接映射。Xv6在KERNBASE上方的PTES中没有设置PTE_U标志，因此只有内核可以使用它们。 让每个进程的页表同时包含用户内存和整个内核的映射，这样可以在系统调用和中断期间，方便地切换到内核：这样的切换不需要页表切换。对于内核大部分没有自己的页面表；它几乎总是借用一些进程的页面表。 总的来说，xv6可确保每个进程只能使用自己的内存，并且每个进程都将其内存视为具有从零开始的连续虚拟地址。xv6通过仅在引用进程自身内存的虚拟地址的PTES上设置PTE_U位来实现第一个要求。它使用页面表将连续的虚拟地址转换为恰好分配给进程的任意物理页的功能，来实现第二个要求。 代码：创建地址空间main调用kvmalloc（1857）来创建并切换到一个页面表，其中包含内核运行所需的KERNBASE 上面的映射。大部分工作发生在setupkvm（1837）。它首先分配一个内存页来保存页面目录。然后调用mappages来安装内核所需的地址翻译，这些翻译在kmap（1828）数组中进行了描述。这些翻译包括内核的指令和数据、最多PHYSTOP字节的物理内存以及I/O设备的内存范围。setupkvm不会为用户内存安装任何映射；这种情况稍后发生。 Mappages（1779）将一系列虚拟地址的映射装到页面表中，以形成相应的物理地址范围。它按页间隔对范围内的每个虚拟地址分别执行此操作。对于要映射的每个虚拟地址，mappages调用walkpgdir，以查找该地址的PTE地址。然后，它初始化PTE以保存相关的物理页码和所需的权限（PTE_W/PTE_U）和PTE_P，使得PTE标记为有效（1791）。 walkpgdir（1754）模仿x86分页硬件的操作。因为它也是遍历PTE，去寻找虚拟地址（参见图 2-1）。walkpgdir使用虚拟地址的前10位查找页面目录项（1759）。如果页面目录条目不存在，则该页面表页尚未分配。如果设置了alloc参数, 则walkpgdir将其分配，并将其物理地址放在页面目录中。最后，它使用虚拟地址的后10位在页面表页面（1772）中查找PTE的地址。 物理内存分配内核需要在运行时为页表、进程用户内存、内核堆栈和管道缓冲区分配和释放物理内存。 xv6使用内核末端和PHYSTOP之间的物理内存来进行运行时分配。它一次分配和释放4096字节的页面。它通过在页面本身中遍历链接列表来跟踪哪些页面是空闲的。分配包括从链接列表中删除页面；释放包括将释放的页面添加到列表中。 这里存在一个引导问题（bootstrap problem）：必须映射所有物理内存，才能使分配器初始化空闲列表，但创建一个包含这些映射的页表涉及分配页表页。xv6通过在输入（entry）过程中使用单独的页面分配器来解决此问题，该分配器在内核的数据段后面分配内存。此分配器不支持释放，并受到entrypgdir中的4MB映射的限制，但这足以分配第一个内核页表。 代码：物理内存分配器分配器的数据结构是可用于分配的物理内存页的免费列表。每个空闲页的列表元素都是结构run（3014）。分配器在哪里获得内存来容纳该数据结构？它将每个空闲页面的run结构存储在免费页面本身中，因为那里没有其他存储。空闲列表受旋转锁（3018-3022，spin block）的保护。列表和锁被包装在一个结构中，以明确锁保护结构中的字段。现在，忽略锁，以及acquire和release的调用；第4章将详细介绍锁。 main调用kinit1和kinit2来初始化分配器（3030）。有两个调用的原因是，对于大部分main不能使用锁或超过4MB的内存。对kinit1的调用设置为在前4MB中的无锁定分配，对kinit2的调用启用锁定和安排更多的内存是可分配的。main应该确定有多少物理内存是可用的，但这在x86上证明是困难的。相反，它假定计算机有240MB（PHYSTOP）的物理内存，并使用内核末端和PHYSTOP之间的所有内存作为空闲内存的初始池。kinit1和kinit2调用freerange，其通过对kfree的每页调用将内存添加到免费列表中。PTE只能引用在4096字节边界上对齐的物理地址（是4096的倍数），因此freerange使用PGROUNDUP来确保它只释放对齐的物理地址。分配器从没有内存开始；这些免费的调用给它一些管理。 分配器通过其在高内存中映射的虚拟地址来引用物理页，而不是通过它们的物理地址来引用物理页，这就是kinit使用p2v(PHYSTOP)将PHYSTOP（物理地址）转换为虚拟地址的原因。分配器有时将地址视为整数，以便对其执行算术运算（例如，遍历kinit中的所有页面），有时使用地址作为读取和写入内存的指针（例如，操作存储在每个页面中的运行结构）；这种地址的双重使用是分配器代码充满C型强制转换的主要原因。另一个原因是，释放和分配本质上改变了内存的类型。 函数kfree（3065）首先将已释放内存中的每个字节设置为值1。这将导致在释放内存后使用内存的代码（使用”悬空引用”）来读取垃圾，而不是旧的有效内容；这样做使得引用无效内存的代码损坏的更快。然后kfree强制转换v指向一个指向struct run的指针，在r-&gt;next中记录空闲列表的旧开始，并将空闲列表设置为r。kalloc则删除并返回空闲列表中的第一个元素。 地址空间的用户部分 图2-3显示了xv6中执行进程的用户内存的布局。堆（heap）位于堆栈上方，以便它可以扩展（使用sbrk）。堆栈是一个单一的页，并显示exec创建时的初始内容。包含命令行参数的字符串以及指向它们的指针数组，位于堆栈的最顶层中。在下面的值是允许程序从mian上开始的值，就好像函数刚刚启动并调用main(argc, argc)。为了保护堆栈页面上不断增长的堆栈，xv6将在堆栈正下方放置一个保护页（guard page）。保护页未映射，因此，如果堆栈用完栈页，硬件将生成异常，因为它无法转换错误地址。 代码：execExec是创建地址空间的用户部分的系统调用。它用存储在文件系统中的文件初始化地址空间的用户部分。Exec（6310）使用namei（6321）打开命名的二进制路径，这在第6章中进行了解释。然后，它读取ELF header。Xv6应用程序以广泛使用的ELF格式进行描述，格式定义在elf.h。ELF 二进制文件包含一个ELF header，即struct elfhdr（0955），然后是一系列程序节标头，即struct proghdr（0955）。每个proghdr描述了必须加载到内存中的应用程序的一部分；xv6程序只有一个程序节标头，但其他系统可能有单独的指令和数据部分。 第一步是快速检查文件是否是ELF二进制文件。ELF二进制文件以四字节魔数0x7F”：”E”、”L”、”F” 或ELF_MAGIC（0952）开头。如果ELF header具有正确的魔数，exec假定二进制文件的格式良好。 Exec使用setupkvm（6334）分配一个没有用户映射的新页面表，用allocuvm（6334）为每个 ELF段分配内存，并用loaduvm（6334）将每个段加载到内存中。allocuvm检查在KERNBASE下面检查请求的虚拟地址。loaduvm（1918）使用walkpgdir查找分配的内存的物理地址，以便在其中写入ELF段的每一页，readi则读入文件。 使用exec创建的第一个用户程序/init的程序节标头如下所示：123# objdump -p _init_init: file format elf32-i386Program Header: LOAD off 0x00000054 vaddr 0x00000000 paddr 0x00000000 align 2**2 filesz 0x000008c0 memsz 0x000008cc flags rwx 程序节标头的文件大小可能小于memsz，这表明它们之间的间隙应该用0（对于C全局变量）来填充，而不是从文件中读取。对于/init，文件大小（filesz）是2240字节，内存大小（memsz）则是2252个字节，因此分配了足够的物理内存来容纳2240字节，但只从文件/init 读取2240字节。 现在exec分配并初始化用户堆栈。它只分配一个堆栈页。Exec将参数字符串复制到堆栈的顶部，并将指向它们的指针记录在ustack中。它在传递给main的argv列表的末尾放置一个空指针。在 ustack的前三个条目是假的return PC，argc，和argv指针。 Exec将无法访问的页面放置在堆栈页的正下方，因此尝试使用多个页面的程序将出现故障。这个无法访问的页还允许exec处理过大的参数；在这种情况下，exec用来将参数复制到堆栈的copyout函数将注意到目标页是不可访问，并将返回–1。 在准备新内存映像的过程中，如果exec检测到像无效的程序段这样的错误，它将跳到标签bad，释放新映像，并返回–1。Exec必须等待释放旧映像，直到它确定系统调用将成功：如果旧映像消失，系统调用将无法返回–1。Exec中唯一的错误情况发生在映像的创建过程中。映像完成后，exec可以安装新映像（6394）并释放旧映像（6394）。最后exec返回0。 真实世界与大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统对分页的使用要比xv6复杂得多；例如，xv6缺少来自磁盘、写入时复制分叉、共享内存、延迟分配的页面和自动扩展堆栈的需求分页。X86支持使用分段的地址转换（见附录B），但xv6仅使用段实现per-cpu变量（如proc）的常见技巧，这些变量位于固定地址上，但在不同CPU上具有不同的值（请参见seginit）。在非段式架构上实现per-cpu（或per-thread）存储将专门用于保存指向per-cpu数据区域的指针的寄存器，但x86的常规寄存器很少，因此使用分段所需的额外工作是值得的。 在具有大量内存的计算机上，使用x86的4MB”超级页面”可能是有意义的。当物理内存较小时，小页面是有意义的，可以以精细的粒度分配和分页到磁盘。例如，如果程序只使用8KB的内存，则为其提供4Mb的物理页是一种浪费。较大的页面在具有大量RAM的计算机上是有意义的，并且可能会减少页面表操作的开销。Xv6在一个地方使用超级页面：初始页面表（1311）。数组初始化设置两个1024 PDE，索引为0和512（KERNBE&gt;&gt;PDXSHIFT），使其他PDES为零。Xv6在这两个PDES中设置PTE_ PS位，将它们标记为超级页面。内核还告诉分页硬件允许超级页面，方法是在%cr4中设置CR_PSE位（页面大小扩展）。 Xv6应确定实际的RAM配置，而不是假定240MB。在x86上，至少有三种常见的算法：第一种算法是探测物理地址空间，以查找行为类似于内存的区域，从而保留写入它们的值；二是从PC的非易失性RAM中已知的16位位置读取内存的大量KB字节；第三是在BIOS内存中查找作为多处理器表的一部分留下的内存布局表。读取内存布局表很复杂。 内存分配是很久以前的热门话题，基本问题是有效利用有限内存和为未知的未来请求做准备；参见Knuth。如今，人们更关心的是速度而不是空间效率。此外，一个更精细的内核可能会分配许多不同大小的小块，而不是（如xv6）仅仅4096字节块；一个真正的内核分配器将需要处理小的分配以及大的分配块。 练习 Look at real operating systems to see how they size memory. If xv6 had not used super pages, what would be the right declaration for entrypgdir? Modify xv6 so that the pages for the kernel are shared among processes, which reduces memory consumption. Unix implementations of exec traditionally include special handling for shell scripts. If the ﬁle to execute begins with the text #!, then the ﬁrst line is taken to be a program to run to interpret the ﬁle. For example, if exec is called to run myprog arg1 and myprog’s ﬁrst line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6.]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《C程序设计语言》]]></title>
    <url>%2F2019%2F04%2F02%2F%E3%80%8AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B%2F</url>
    <content type="text"><![CDATA[回炉重造，哭！ 《C程序设计语言》 结构在关键字struct之后可带有一个被称为结构标记的可选名字。该标记命名了该类型的结构，并在此后可做为声明中花括号部分的缩写使用。 一个struct声明定义了一个类型。在标志成员列表结束的右花括号后可以带有一列变量，就像任何基本类型那样。譬如12struct &#123; … &#125; x, y, z; int x, y, z; 在语法上可以类比：两者都将x、y和z声明为所命名的类型，并且为它们预留了存储空间]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《众病之王》]]></title>
    <url>%2F2019%2F04%2F01%2F%E3%80%8A%E4%BC%97%E7%97%85%E4%B9%8B%E7%8E%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[癌症是一段跑偏的代码，会不断产生数据，直到内存溢出，耗尽所有资源。奶奶死于肺癌，姑父正遭受肺癌的折磨。如果不是他们，我无法体会癌症的可怕。愿大家有个健康的人生！ 现代人觉得癌症似乎是现代病。但癌症在历史的缺席，背后有几个原因，一癌症与年龄有关，发生概率随着年龄增加呈指数增加，古代社会，人们收到其他疾病的影响，往往还没有得癌症就已经死去。现代医学的发展，延长了人们的寿命，也暴露了癌症。 上百年的抗癌战争背后，是人们对死亡的恐惧和对生的渴望。 从外科切除到化疗，再到基因靶向治疗，人类走了很多错路，但终归找到了正确的路。很长一段时间，癌症即等于死亡，这使得人们不得不急于求成，去寻找一劳永逸的解决癌症的办法，而在很长一段时间内都忽略了癌症最基本的机理。但书中并没有去批判这种状况，而是客观呈现医学领域对癌症的研究一直处在不断自我批判的良性发展状况，是每个人都在追求真理的过程中不断奉献自我，在前进的道路上，没有人徒劳无功。 每次睡前看这本书，心情都会变得很压抑。一是书中讲述的波澜壮阔的抗癌史呈现的一次次看似成功的失败，二是那种代入感，幻想自己如果某天真的患了癌症，会怎么办？心中难免会有恐惧。也使得自己不断思考生命的意义到底在哪里？这本书并没有带来知识上的收获，而是让我更加敬畏生命本身，更加宏观的看待生命的意义。 对于死亡的恐惧和好奇心是嵌入人类基因的。因此人们不断探究未知的世界，不断发展更好的生活环境和医疗条件。整本书都在讲述癌症的历史，但呈现的内涵绝不局限在癌症本身，它包含政治、经济等，甚至包含人类本身。 一直把人生就是一场游戏作为自己的信条。处在游戏中的每个人难道不因为获得快乐，获得成就感吗？可我在最近的学习中始终找不到这两点，我还没有找到自己内心的G点。人生最宝贵的三样东西：健康、爱和快乐。好好守护他们，不要挥霍。 这篇文章还没完结，姑父就已经去世了。]]></content>
      <tags>
        <tag>癌症</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章：存储器层次结构]]></title>
    <url>%2F2019%2F04%2F01%2FCSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[具有良好局部性的程序倾向于一次又一次的访问相同的数据项集合 存储的CPU寄存器的数据，只要0个周期就能访问，存储在高速缓存的数据，需要4-75个周期，存储在磁盘上的数据，则大约需要几千万个周期 只有了解系统是如何将数据在存储器层次结构中上下移动的，才可以编写自己的程序，使得程序的数据项存储在层次结构中较高的地方 了解如何看一眼源代码就能获得对程序局部性的高层次的认识，是程序员要掌握的一项重要和有用的技能 存储设备局部性局部性通常有两种形式：空间局部性和时间局部性。空间局部性好的代码倾向于在下次引用附近的内存位置，时间局部性好的代码倾向于引用相同的内存代码 从硬件到操作系统，再到应用程序，它们的设计都用到了局部性原理 硬件层：局部性原理允许计算机设计者引入高速缓存存储器来保存最近使用的指令和数据。从而提高对主存的访问速度 操作系统层：允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存 应用程序层：如Web浏览器把最近引用的文档放在本地磁盘上，利用的就是时间局部性 对于顺序访问数组元素的函数，具有步长为1的顺序引用模式具有较好的空间局部性，且随着步长的增加，空间局部性下降。而对于多维数组，如果是普通的行优先顺序访问数组元素，也具有良好的空间局部性，因为是步长为1的引用模式；如果是按照列顺序访问数组，就会得到步长为N的引用模式，空间局部性下降 对于取指令，循环有好的时间和空间局部性，循环体越小，迭代次数越多，局部性越好？？ 高速缓存]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>高速缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter 1]]></title>
    <url>%2F2019%2F03%2F27%2FPearls-Chapter-1%2F</url>
    <content type="text"><![CDATA[位向量 第一章通过提出下面问题带我们认识了位向量 问题：如果对磁盘中的文件进行排序？ 问题场景分析：文件存储最多1000万个7位整数，不会出现任何重复的整数 约束：内存之多只有1MB，磁盘看作无限，要求算法优化到10秒 位向量/位图是一个很有用的数据结构，在充分利用小空间存储大量数据方面非常具有优势，Linux内核中很多地方都是用了位图，如分配pid 位图数据结构描述了一个有限定义域内的稠密集合，其中每个元素最多出现一次并且没有其他任何数据与该元素相关联 考虑到计算机中最小的数据单位是非0即1的二进制位，对于一个对象，使用一个二进制位就足够了。很多语言都具有位运算，因为不能用一个变量名直接表示一个位，那么可以将多个位组合成一个基本数据类型，通过对这个基本数据类型进行操作，达到使用位的方法。同时，为了方便，延续使用int数组的做法，把这些由位组合成的基本数据类型也组成数组 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define N 100 // size of bitset#define BITSPERWORD 32 // size of byte,it depends on machine#define NUM (N-1)/BITSPERWORD+1 // size of int array#define SHIFT 5#define MASK 0x1F // 11111 in binaryint a[NUM];void set(int i)&#123; a[i&gt;&gt;SHIFT] |= (1&lt;&lt;(i &amp; MASK)); &#125;void clr(int i)&#123; a[i&gt;&gt;SHIFT] &amp;= ~(1&lt;&lt;(i &amp; MASK)); &#125;int test(int i)&#123; return a[i&gt;&gt;SHIFT] &amp; (1&lt;&lt;(i &amp; MASK)); &#125;void set_2(int i)&#123; a[i/BITSPERWORD] != (1&lt;&lt;(i%BITSPERWORD)); &#125;void clr_2(int i)&#123; a[i/BITSPERWORD] &amp;= ~(1&lt;&lt;(i%BITSPERWORD)); &#125;int test_2(int i)&#123; return a[i/BITSPERWORD] &amp; (1&lt;&lt;(i%BITSPERWORD)); &#125;int main()&#123; set(19); printf("%x",test(19));&#125; 书上的版本用的位运算，第一眼不一样就能明白，但是运算效率更高，因此自己写了个垃圾版本 i &gt;&gt; SHIFT表示算数右移5位，即i/32，该操作的作用是将数组的索引定位到需要操作的那个int 的位置上，因为我们的位向量结构是由许多个int组成的。i &amp; MASK表示取 i 的最后5位，就相当于i%32 SET操作是取或运算，即把定位到的int中的某位设置为1]]></content>
      <tags>
        <tag>编程珠玑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Appendix B]]></title>
    <url>%2F2019%2F03%2F26%2FMIT-6-828-book-xv6-Appendix-B%2F</url>
    <content type="text"><![CDATA[The boot loader MIT 6.828 Operating System Engineering 当x86 PC启动时, 它将开始执行名为BIOS的程序，该程序存储在主板上的非易失性内存中。BIOS 的工作是准备硬件，然后将控制权转移到操作系统。具体来说，它将控制权转移到从引导扇区加载的代码，即引导磁盘的第一个512字节扇区。引导扇区包含引导加载程序，即将内核加载到内存中的指令。BIOS在内存地址0x7c00处加载引导扇区, 然后跳转（设置处理器的%ip）到该地址。当引导加载程序开始执行时，处理器正在模拟英特尔8088，加载程序的工作是将处理器置于更现代的操作模式，将xv6内核从磁盘加载到内存中，然后将控制权转移到内核。xv6引导加载程序由两个源文件组成，一个由16位和32位x86汇编语言编写，另一个由C语言编写。 Assembly bootstrap12345678910111213141516171819202122// 译者引入# Start the CPU: switch to 32-bit protected mode, jump into C.# The BIOS loads this code from the first sector of the hard disk into# memory at physical address 0x7c00 and starts executing in real mode# with %cs=0 %ip=7c00..set PROT_MODE_CSEG, 0x8 # kernel code segment selector.set PROT_MODE_DSEG, 0x10 # kernel data segment selector.set CR0_PE_ON, 0x1 # protected mode enable flag.globl startstart: .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax,%ax # Segment number zero movw %ax,%ds # -&gt; Data Segment movw %ax,%es # -&gt; Extra Segment movw %ax,%ss # -&gt; Stack Segment 引导加载程序中的第一个指令是cli（8912），它禁用处理器中断。中断是硬件设备调用称为中断处理程序的操作系统功能的一种方式。BIOS是一个很小的操作系统，它可能已经设置了自己的中断处理程序，作为初始化硬件的一部分。但是BIOS不再运行（轮到引导加载程序运行），因此处理来自硬件设备的中断不再合适或安全。当xv6准备就绪时（在第3章中），它将重新启用中断。 处理器处于实模式（real mode），在该模式下模拟英特尔8088。在实模式下，有8个16位通用寄存器，但处理器向内存发送20位地址。段寄存器%cs % ds %es和%ss提供了从16位寄存器生成20位内存地址所需的额外位。当程序引用内存地址时，处理器会自动添加一个段寄存器的值的16倍（即左移4位，译者注），这些寄存器是16位宽。因此，内存引用中其实隐含地使用了段寄存器的值：指令提取使用%cs（code segment，译注），数据读取和写入使用%ds（data segment，译注）, 堆栈读取和写入使用%ss（stack segment，译注）。 Xv6假装x86指令对其内存操作使用虚拟地址，但x86指令实际上使用逻辑地址（参见图B-1）。逻辑地址由段选择器（segment selector）和偏移量（offset）组成，有时将其写成segment:offset。更常见的情况是，会忽略segment，程序直接操作offset。Segmentation hardware执行上述转换以生成线性地址（linear address）。如果启用分页硬件（请参阅第2章），则会将线性地址转换为物理地址；否则处理器使用线性地址作为物理地址。 引导加载程序不启用分页硬件；它使用的逻辑地址由Segmentation hardware转换为线性地址，然后直接用作物理地址。Xv6将Segmentation hardware配置为从逻辑地址转换为线性地址时不进行更改，以便它们始终相等。由于历史原因，我们使用了“虚拟地址”（virtual address）一词来指程序操纵的地址；xv6的虚拟地址就是x86上的逻辑地址，也就是Segmentation hardware映射到的得到的线性地址。启用分页后，系统中唯一有趣的地址映射就是从线性地址到物理地址。 BIOS不保证%ds %es %ss的内容，因此禁用中断后的第一步是将%ax设置为零，然后将零复制到%ds %es %ss（8915-8918）中。 虚拟地址segment:offset可以产生21位物理地址，但英特尔8088只能寻址20位内存，因此它丢弃了顶部：0xffff0+0xffff = 0x10ffef，但在Intel 8088上，虚拟地址0xffff:0xffff指的是物理地址0x0ffef。一些早期的软件依赖于硬件去忽略21地址位，因此，当英特尔引入具有20位以上的物理地址的处理器时，IBM提供了一个兼容的技巧用来匹配兼容的硬件。如果键盘控制器的输出端口的第二位是低电平，则始终清除第21位物理地址，否则就会保留第21位。Boot loader使用键盘控制器上的0x64和0x60两个I/O端口来启用第21个地址位（第8920-8936行）。123456789101112131415161718192021// 译者引入# Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this.seta20.1: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.1 movb $0xd1,%al # 0xd1 -&gt; port 0x64 outb %al,$0x64seta20.2: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.2 movb $0xdf,%al # 0xdf -&gt; port 0x60 outb %al,$0x60 实模式的16位通用和分段寄存器使程序使用超过65536字节的内存变得很尴尬，并且不可能使用超过兆字节的内存。自80286以来，x86处理器具有保护模式（protected mode），允许物理地址具有更多的位。并且自80386以来，“32位”模式会导致寄存器、虚拟地址和大多数整数算法使用32位而不是16位执行。xv6启用保护模式和32位模式的顺序如下所示。 在保护模式下，段寄存器是段描述符表（segment descriptor table）索引（见图 B-2）。每个表条目表明了一个基本物理地址，一个称为limit的最大虚拟地址和段的权限位。这些权限位就是保护模式下的保护措施，因为内核使用它们去保证程序只能使用属于它自己的内存。 xv6几乎不使用段，而是使用第2章所描述的分页硬件。引导加载程序设置段描述符表gdt（第8982-8985行），以便所有段的基址为零和可能的最大限制（4GB）。该表有一个空条目，一个可执行代码的条目，和一个数据条目。代码段描述符具有一个标志集, 指示代码应在32位模式（0660）下运行。使用此设置，当引导加载程序进入保护模式时，逻辑地址将一对一映射到物理地址。123456789101112131415161718// 译者引入// 第8982-8985行# Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: SEG_NULL # null seg SEG(STA_X|STA_R, 0x0, 0xffffffff) # code seg SEG(STA_W, 0x0, 0xffffffff) # data seg// 660行// The 0xC0 means the limit is in 4096−byte units // and (for executable segments) 32−bit mode. #define SEG_ASM(type,base,lim) .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff); .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)), (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff) 引导加载程序执行 lgdt 指令（8941），将处理器的全局描述符表（GDT）寄存器加载到值gdtdesc（8987-8989），该值指向表gdt。 123456789101112131415161718// 译者引入# Switch from real to protected mode, using a bootstrap GDT# and segment translation that makes virtual addresses # identical to their physical addresses, so that the # effective memory map does not change during the switch.lgdt gdtdescmovl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax, %cr0# Jump to next instruction, but in 32-bit code segment.# Switches processor into 32-bit mode.ljmp $PROT_MODE_CSEG, $protcseggdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt 一旦加载GDT寄存器后，引导加载程序通过在寄存器%cr0（8942-8944）中设置1位（CR0_PE）来启用保护模式。启用保护模式不会立即更改处理器将逻辑转换为物理地址的方式；只有当将一个新值加载到段寄存器中时，处理器才会读取GDT并更改其内部段设置。但是因为不能直接修改%cs，代码通过执行ljmp（far jump）指令（8953）的方式，来指定代码段选择器。跳转将在下一行（8956）继续执行，但在此过程中设置%cs以引用gdt中的代码描述符项。该描述符描述了32位代码段，因此处理器切换到32位模式。引导加载程序随着处理器从8088到80286到80386的演变而不断改变。 引导加载程序在32位模式下的第一个操作是使用SEG _ KDATA（8958-8961）初始化数据段寄存器。逻辑地址现在直接映射到物理地址。在执行C代码之前剩下的唯一步骤是在未使用的内存区域中设置堆栈。0xa0000到0x100000的内存通常散落在设备内存区域中，xv6内核预计将被放置在0x100000。引导加载程序本身位于0x7c00到0x7c00。从本质上讲，内存的任何其他部分都是堆栈的良好位置。引导加载程序选择0x7c00（在此文件中称为$start）作为堆栈的顶部；堆栈将从那里向0x0000增长，远离引导加载程序 最后，引导加载程序调用C函数bootmain（8968）。Bootmain的工作是加载和运行内核。只有在出了问题的情况下，它才会回来。在这种情况下, 代码会在端口0x8a00（8970-8976）上发送几个输出字。在实际硬件上, 没有设备连接到该端口，因此此代码不执行任何操作。如果引导加载程序在PC模拟器内运行，则端口0x8a00将连接到模拟器本身，并可以将控制权转移回模拟器。如果没有模拟器，代码然后执行无限循环（8977-8978）。真正的引导加载程序可能会尝试先打印错误消息。 123456789101112131415161718192021222324.code32 # Tell assembler to generate 32−bit code now. start32: # Set up the protected−mode data segment registers movw $(SEG_KDATA&lt;&lt;3), %ax # Our data segment selector movw %ax, %ds # −&gt; DS: Data Segment movw %ax, %es # −&gt; ES: Extra Segment movw %ax, %ss # −&gt; SS: Stack Segment movw $0, %ax # Zero segments not ready for use movw %ax, %fs # −&gt; FS movw %ax, %gs # −&gt; GS # Set up the stack pointer and call into C. movl $start, %esp call bootmain # If bootmain returns (it shouldn’t), trigger a Bochs # breakpoint if running under Bochs, then loop. movw $0x8a00, %ax # 0x8a00 −&gt; port 0x8a00 movw %ax, %dx outw %ax, %dx movw $0x8ae0, %ax # 0x8ae0 −&gt; port 0x8a00 outw %ax, %dx spin: jmp spin C bootstrap引导加载程序的C部分（boot. c（9000））希望在第二个扇区开始的磁盘上找到可执行内核的副本。正如我们在第2章中所看到的，内核是一个ELF格式的二进制文件。为了获取ELF标头，bootmain加载ELF二进制文件的前4096字节（9014），并放在内存地址0x10000。 下一步是快速检查这是ELF二进制文件，而不是未初始化的磁盘。Bootmain从ELF标头off字节后开始读取节的内容，并从地址paddr开始写入内存。Bootmain调用readseg从磁盘加载数据（9038）并调用stosb为段的其余部分（9040）为零。Stosb（0492）使用x86指令代表stosb初始化内存块的每个字节。 内核已经编译和链接，因此它希望从虚拟地址0x80100000开始找到自己。因此，函数调用指令必须看起来像0x801xxxxx的目标地址；你可以在kernel.asm中看到例子。此地址是在kernel.ld中配置的。0x80100000是一个相对较高的地址，接近32位地址空间的末尾，第2章解释了这一选择的原因。在如此高的地址可能没有任何物理内存。一旦内核开始执行，它将设置分页硬件，将从0x80100000开始的虚拟地址映射到0x00100000开始的物理地址；内核假定在这个较低的地址有物理内存。但是，在引导过程中的这一点上，未启用分页。相反，kernel.ld指定ELF paddr从0x00100000开始，这将导致引导加载程序将内核复制到分页硬件最终将指向的低物理地址。 引导加载程序的最后一步是调用内核的入口点，这是内核希望开始执行的指令。对于xv6，入口地址为 0x10000c:123456$ objdump -f obj/kern/kernelkernel: file format elf32-i386architecture: i386, flags 0x00000112:EXEC_P, HAS_SYMS, D_PAGEDstart address 0x0010000c 按照惯例，_start符号指定了ELF入口点，该值定义在文件entry.S（1036）。由于xv6尚未设置虚拟内存，因此xv6的入口点是entry（1040）的物理地址。1234567// 译者引入# '_start' specifies the ELF entry point. Since we haven't set up# virtual memory when the bootloader enters this code, we need the# bootloader to jump to the *physical* address of the entry point..globl _start_start = RELOC(entry) Real world本附录中描述的引导加载程序将编译为大约470字节的机器代码，具体取决于编译C代码时使用的优化。为了适应这少量的空间，xv6引导加载程序做出了一个主要的简化假设，即内核已连续从扇区1开始写入引导磁盘。更常见的情况是，内核存储在普通文件系统中，在这些文件系统中，内核可能不是连续的，或者是通过网络加载的。这些复杂情况要求引导加载程序能够驱动各种磁盘和网络控制器，并了解各种文件系统和网络协议。换句话说，引导加载程序本身必须是一个小型操作系统。由于这种复杂的引导加载程序肯定不止512字节，大多数PC操作系统启动过程分为两步。首先，像本附录中的一个简单的引导加载程序从已知的磁盘位置加载一个功能齐全的引导加载程序，通常依赖于空间限制较少的BIOS进行磁盘访问，而不是试图驱动磁盘本身。然后，完全加载程序，摆脱512字节的限制，可以实现定位、加载和执行所需内核所需的复杂性。也许更现代的设计会让BIOS直接从磁盘读取更大的引导加载程序 (并在受保护和32位模式下启动它)。 编写本附录时，似乎在开机和执行引导加载程序之间发生的唯一事情是BIOS加载引导扇区。事实上，BIOS做了大量的初始化，以使现代计算机的复杂硬件看起来像一个传统的标准PC。 Exercises 由于扇区粒度，文本中对readseg的调用等效于 readseg((uchar*)0x100000、0xb500、0x1000)。实际上, 这种马虎的行为原来不是问题。为什么粗粒度的readsect不会引起问题？ 有关BIOS持续较长+安全问题的内容 假设您希望bootmain()以0x200000而不是0x100000去加载内核，并且您是通过修改bootmain()将0x200000添加到每个ELF节的va部分的来完成的。这是会出事的。为什么？ 引导加载程序将ELF标头复制到任意位置0x10000的内存似乎具有潜在的危险。为什么不叫malloc来获得它所需要的内存呢？]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停一停！]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%B0%8F%E8%AE%B0%EF%BC%9A%E5%81%9C%E4%B8%80%E5%81%9C%EF%BC%81%2F</url>
    <content type="text"><![CDATA[成长道路中总是会有阵痛！ 今天看到知乎上一个话题“为什么有些程序员GitHub、博客都很活跃，工资却不高”，这个对自己的打击其实挺大的，也算是写下这篇文章的一个导火索。当然，让我写这篇文章的主因还是因为最近的思考 先解释一下为什么一个看似平常的问题为什么会引发自己这么多思考。 其实这个问题也算是触碰到自己的一个恐惧点：我害怕挑战。为什么这么说呢？我倾向于埋头努力，但不希望让现实检验自己，因为这么做，就会将自己原本看似完美的自我认知摧毁，将自己戳的千疮百孔。所以我现在虽然努力看书，学习技术，但我还是担心会有自己不熟悉的领域，总觉得自己没准备好，不敢去接受现实 我习惯了立下计划，然后推倒它，没有成就，做不成事情，是我现在最大的问题 最近的另一个思考是关于教训。俗话说：吃一堑长一智，可我只会吃一堑，不会长一智。对教训透明让自己的成长变得缓慢，不懂得从一件事中发掘出价值所在，并形成自己今后的做事原则 另一个问题是关于深度思考，写了快一年的博客，回头看看自己平时学的文章，哪篇不是东抄一点，西抄一点，没有一篇自己的深度思考，把博客渐渐写成了书摘的集合 该怎么解决上述问题？第一改变自己太过于理想主义的思维，要给自己多一点自信，第二多一点责任心，立下切实可行的目标并实现它，第三训练自己的深度思考，不要活得太简单 总感觉自己的语言好苍白，没有表达自己的真实的想法 接下来急需改变的是不要让自己成为行动的矮人，语言的巨人！ 感觉现在慢慢开始厌倦计算机，学的时间久了，却没有成果出现。长时间告诉自己打好基础，可是现在觉得自己思想有点停滞不前了！ 想了好几天，这几天想到一个词形容自己太贴切：急功近利。 投资切记一点：危机总会到来。唯一能做的就是意识到这一点，并不断学习，以推迟危机到来的时间点]]></content>
      <tags>
        <tag>成长</tag>
        <tag>小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Chapter 1]]></title>
    <url>%2F2019%2F03%2F24%2FMIT-6-828-book-xv6-Chapter-1%2F</url>
    <content type="text"><![CDATA[操作系统结构 MIT 6.828 Operating System Engineering 操作系统的一个关键要求是支持多个活动。例如，使用第0章中描述的系统调用接口，进程可以使用fork创建进程。操作系统必须安排这些进程可以共享（time-share）计算机的资源。例如，进程可能比计算机中的处理器启动更多的新进程，但所有进程都必须能够取得一些进展。此外，操作系统必须安排进程之间的隔离。也就是说，如果一个进程有一个bug并出现错误，它不应该影响不依赖于失败进程的进程。然而，完全隔离要求太严格（strong），因为进程应该有可能相互作用。例如，用户可以方便地组合进程来执行复杂的任务（例如，通过使用管道）。因此，操作系统的实现必须满足三个要求: 多路复用、隔离和交互。 本章概述了如何组织操作系统以实现上述3个要求。事实证明，这样做的方法有很多，但本文重点围绕一个整体内核（monolithic kernel），介绍在许多Unix操作系统都使用的主流设计。本章通过跟踪xv6开始运行时创建的第一个进程来说明此组织。在此过程中，我们将研究xv6提供的所有主要抽象的实现、它们如何交互以及如何满足多路复用、隔离和交互的三个要求。大多数xv6为了避免第一个进程的特殊性，重用xv6提供的标准操作的代码。后面的章节将更详细地探讨每个抽象。 Xv6在PC平台上的英特尔80386或更高版本（”x86”） 处理器上运行，其大部分低级功能（例如，进程实现） 都是特定于x86的。本书假定读者已经在一些体系结构上做了一些机器级的编程，并将在提出x86特定的想法时引入它们。附录A简要概述了PC平台。 物理资源抽象当遇到操作系统时，人们可能会问的第一个问题是，为什么会有它？也就是说，可以将图0-2中的系统调用实现为一个库，应用程序将使用该库进行链接。在这个计划中，每个应用程序甚至可以有自己的库，也许是根据自己的需要量身定做的。同时，应用程序可以直接与硬件资源交互，并以应用程序的最佳方式使用这些资源（例如，实现高性能或可预测的性能）。嵌入式设备或实时系统的一些微小操作系统就是这样组织的。 这种方法的缺点是应用程序可以自由使用库，这意味着它们也可以不使用它。如果他们不使用操作系统库，则操作系统无法强制进行时间共享。它必须依赖于应用程序才能正常运行，例如，定期放弃处理器，以便另一个应用程序可以运行。对于一个所有应用程序都彼此信任的系统来说，这样的合作分时方案也许是可以的，但如果应用程序相互不信任，这将不会提供强大的隔离。 要实现强隔离，一个有用的方法是不允许应用程序直接访问硬件资源，而是将资源抽象为服务。例如，应用程序仅通过open read write close系统调用与文件系统交互，而不是读取和写入原始磁盘扇区。这为应用程序提供了路径名的便利性，并允许操作系统（作为接口的实现者） 管理磁盘。 类似地，在Unix中应用程序通过fork作为进程运行，允许操作系统在不同进程之间切换时代表应用程序保存和还原寄存器，这样应用程序就不必知道进程切换。此外，如果应用程序是一个无限循环，它允许操作系统强制切换出占用处理器的应用程序。 另一个例子是，Unix进程使用exec来构建它们的内存映像，而不是直接与物理内存交互。这使操作系统能够决定将进程放置在内存中的位置，并在内存不足的情况下移动数据，并为应用程序提供了文件系统存储其映像的便利。 为了支持控制应用程序之间的交互，Unix应用程序只能使用文件描述符，而不是自己的一些共享约定（例如，保留一段物理内存）。Unix文件描述符抽象出所有共享细节，在与终端、文件系统或管道发生交互时，会向应用程序隐藏，但允许操作系统控制交互。例如，如果一个应用程序出现故障，它可以关闭通信通道。 正如您所看到的，图0-2中的系统调用接口经过精心设计，为程序员提供了便利的同时，也为强制隔离接口的实现提供便利。Unix接口并不是抽象资源的唯一方法，但事实证明它是一种非常好的方法。 用户模式、内核模式和系统调用为了在使用系统调用的软件和实现系统调用的软件之间提供强大的隔离，我们需要应用程序和操作系统之间的硬边界。如果应用程序出错，我们不希望操作系统失败。相反，操作系统应该能够清理应用程序并继续运行其他应用程序。这种强大的隔离意味着应用程序不应该能够写入操作系统维护的数据结构，不应该能够覆盖操作系统的指令等。 为提供这种强隔离处理器提供硬件支持。 例如，与许多其他处理器一样，x86处理器有两种处理器执行指令的模式: 内核模式（Kernel mode）和用户模式（user mode）。在内核模式中，处理器允许执行特权指令（privileged instructions），像读取和写入磁盘（或任何其他I/O设备）就是一个特权指令。如果用户模式下的应用程序尝试执行特权指令，但处理器不会执行该指令，而是切换到内核模式，以便内核模式下的软件可以清理应用程序，因为它执行了不应该执行的操作。第0章中的图0-1说明了这一组织操作系统 强隔离。应用程序只能执行用户模式指令（例如添加数字等），并且被认为是在用户空间中运行，而内核模式下的软件也可以执行特权指令，并被称为在内核空间中运行。在内核空间（或内核模式） 运行的软件称为内核。 如果用户模式应用程序必须读取或写入磁盘，则必须转换到内核才能执行此操作，因为应用程序本身无法执行I/O指令。处理器提供了一个特殊的指令，将处理器从用户模式切换到内核模式，并在内核指定的入口点进入内核。（x86处理器为此目的提供int指令。）一旦处理器切换到内核模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行它。由内核来设置转换到内核模式的入口点是非常重要的，如果应用程序可以决定内核入口点，则恶意应用程序可以在跳过参数验证的位置进入内核。 内核组织操作系统的一个关键设计问题是操作系统的哪一部分应该在内核模式下运行。一个简单的答案是内核接口是系统调用接口。也就是说，fork exec open`closereadwrite`等都是内核调用。此选择意味着操作系统的完整实现在内核模式下运行。这种内核组织被称为单片内核（monolithic kernel）。 在此组织中，完整的操作系统以完全硬件权限运行。此组织很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要完全的硬件特权。此外，操作系统的不同部分也很容易进行合作。例如，操作系统可以具有文件系统和虚拟内存系统可以共享的缓冲区缓存。 整体组织的一个缺点是，操作系统不同部分之间的接口通常很复杂（我们将在本文的其余部分看到），因此操作系统开发人员很容易犯错。在单片内核中，错误是致命的，因为内核模式中的错误通常会导致内核失败。如果内核出现故障，计算机将停止工作，因此所有应用程序也将失败。计算机必须重新启动才能重新启动。 为了降低内核出现错误的风险，操作系统设计人员可以将在内核模式下运行的代码行做得更小。大多数操作系统不需要访问到特权指令，从而可以作为普通的用户级应用程序运行，与应用程序通过消息进行交互。这个内核组织被称为微内核（microkernel）。 图1-1说明了这种微内核设计。在图中，文件系统作为用户级应用程序运行。为普通用户程序运行提供服务的操作系统称为服务器。为了允许应用程序与文件服务器交互，内核提供了一种最小的机制，用于将消息从一个用户模式应用程序发送到另一个用户模式应用程序。例如，如果像shell这样的应用程序想要读取或写入文件，它将向文件服务器发送一条消息并等待响应。 在微内核中，内核接口由一些用于启动应用程序、执行I/O、向应用程序发送消息这样低级函数组成。此组织允许使用几行代码实现内核，因为它没有做太多事情，因为操作系统的大多数功能都是由用户级服务器实现的。 在现实世界中，人们既可以找到单片内核，也可以找到微内核。例如，Linux 主要是作为一个单片内核实现的，尽管某些操作系统功能作为用户级服务器（例如，窗口系统） 运行。Xv6 是作为一个单片内核实现的，遵循大多数Unix操作系统。因此，在xv6中，内核接口对应于操作系统接口，内核实现完整的操作系统。由于xv6提供的功能不多，它的内核比一些微内核小。 下图是译者提供的内核结构图比较 进程概述xv6中的隔离单元（与其他Unix操作系统中一样）叫做进程。进程抽象可防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核本身（即阻止内核强制隔离）。内核必须谨慎地实现进程抽象，因为错误或恶意应用程序可能会欺骗内核或硬件做一些不好的事情（例如，绕过强制隔离）。内核用于实现进程的机制包括用户/内核模式标志、地址空间和线程的时间切片，本小节对此进行了概述。 为了能够强制隔离，一个过程是一个抽象，就好像一个程序拥有它有自己的抽象机器。进程提供给程序专有的内存系统，或地址空间，其他进程无法读取或写入。进程还给程序提供私有CPU执行程序指令的假象。 Xv6 使用页表（由硬件实现）为每个进程提供自己的地址空间。x86页表将虚拟地址（“地图”）转换为物理地址（处理器芯片发送到主内存的地址） Xv6为每个进程维护一个单独的页面表，用于定义该进程的地址空间。如图1-2所示，地址空间包括从虚拟地址零开始的进程的用户内存。先是指令，然后是全局变量，然后是堆栈，最后是一个“堆”区域（用于malloc），进程可以根据需要扩展。 每个进程的地址空间映射内核的指令和数据以及用户程序的内存。当进程调用系统调用时，系统调用将在进程地址空间的内核映射中执行。这种安排的存在，以便内核的系统调用代码可以直接引用用户内存。为了给用户内存的增长留出空间，xv6的地址空间将内核映射到高地址，从0x80100000开始。 xv6内核为每个进程维护许多状态片段, 并将其收集到一个结构proc（第2353行）中。进程最重要的内核状态是它的页面表、内核堆栈和运行状态。我们将使用符号p-&gt;xxx来引用proc结构的元素。1234567891011121314151617//译者引入//Per−process statestruct proc &#123; uint sz; // Size of process memory (bytes) pde_t* pgdir; // Page table char *kstack; // Bottom of kernel stack for this process enum procstate state; // Process state int pid; // Process ID struct proc *parent; // Parent process struct trapframe *tf; // Trap frame for current syscall struct context *context; // swtch() here to run process void *chan; // If non−zero, sleeping on chan int killed; // If non−zero, have been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) 2367 &#125;;&#125; 每个进程都有一个执行线程（或简称线程）来执行进程的指令。线程可以挂起，然后恢复。要在进程之间透明地切换，内核将挂起当前正在运行的线程，并恢复另一个进程的线程。线程的大部分状态（局部变量、函数调用返回地址）存储在线程的堆栈中。每个进程都有两个堆栈：用户栈和内核栈（p-&gt;kstack）。当进程执行用户指令时，只有其用户栈正在使用中，其内核栈为空。当进程进入内核（如系统调用或中断）时，内核代码将在进程的内核堆栈上执行；当进程在内核中时，其用户堆栈仍然包含已保存的数据，但未被积极使用。进程的线程在主动使用其用户堆栈和内核堆栈之间交替进行。内核堆栈是独立的（并与用户代码一起保护），因此即使进程破坏了其用户堆栈，内核也可以执行。 当进程进行系统调用时，处理器切换到内核堆栈，提高硬件权限级别，并开始执行实现系统调用的内核指令。系统调用完成后，内核将返回到用户空间：硬件降低其权限级别，切换回用户堆栈，并在系统调用指令之后继续执行用户指令。进程的线程可以在内核中阻塞去等待I/O，并在I/O完成后从停止的位置继续执行。 p-&gt;state指示进程是分配、准备运行、运行、等待I/O还是退出。 p-&gt;pgdir保存进程的页表，格式为x86硬件所期望的格式。xv6会导致分页硬件在执行进程时使用进程的p-&gt;pgdir。进程的页表还可作为分配给存储进程内存的物理页的地址的记录。 代码：第一个地址空间为了使xv6的组织更加具体，我们将了解内核如何创建第一个地址空间（为其自身），如何创建并启动第一个进程，以及该进程进行的第一个系统调用。通过跟踪这些操作，我们详细了解xv6如何为进程提供强大的隔离。提供强隔离的第一步是将内核设置为在其自己的地址空间中运行。 当PC通电时，它会初始化自身，然后将引导加载程序（boot loader）从磁盘加载到内存中并执行它。附录B（MIT 6.828 book_xv6:Appendix B，译者注）解释了细节。Xv6的引导加载程序从磁盘加载xv6内核，并从entry（第1040行）开始执行它。内核启动时，未启用x86分页硬件；虚拟地址直接映射到物理地址。 123456789101112131415161718//译者引入#define V2P_WO(x) ((x) − KERNBASE) // same as V2P, but without casts# Entering xv6 on boot processor, with paging off. .globl entry entry: # Turn on page size extension for 4Mbyte pages movl %cr4, %eax orl $(CR4_PSE), %eax movl %eax, %cr4 # Set page directory movl $(V2P_WO(entrypgdir)), %eax movl %eax, %cr3 # Turn on paging. movl %cr0, %eax orl $(CR0_PG|CR0_WP), %eax movl %eax, %cr0 引导加载程序将xv6内核加载到物理地址0x100000的内存中。它不将内核加载到0x80100000（内核希望在那里找到它的指令和数据）的原因是，在一台小机器上，在这么高的地址可能没有任何物理内存。它之所以将内核放在0x100000而不是0x0, 是因为地址范围0xa0000: 0x100000包含I/O设备。 为了允许内核的其余部分运行，entrty设置一个页表, 将从0x800000开始的虚拟地址（称为KHRNBASE（第0207行））映射到0x0开始的物理地址（参见图 1-2）。设置两个映射到相同物理内存范围的虚拟地址范围是页表的常见用法，我们将看到更多类似这样的示例。 入口页表(entry page table）是在main. c（1311）中定义的。我们将在第2章中查看页表的详细信息，简短来说就是entry 0映射了虚拟地址0:0x400000到物理地址0:0x400000。只要entry在低地址执行，但最终都会被移除，那就需要此映射。1234567891011121314151617// 译者引入// Key addresses for address space layout (see kmap in vm.c for layout)#define KERNBASE 0x80000000 // First kernel virtual address #define KERNLINK (KERNBASE+EXTMEM) // Address where kernel is linked// Boot page table used in entry.S and entryother.S. // Page directories (and page tables), must start on a page boundary, // hence the "__aligned__" attribute. // Use PTE_PS in page directory entry to enable 4Mbyte pages.__attribute__((__aligned__(PGSIZE))) pde_t entrypgdir[NPDENTRIES] = &#123; // Map VA’s [0, 4MB) to PA’s [0, 4MB) [0] = (0) | PTE_P | PTE_W | PTE_PS, // Map VA’s [KERNBASE, KERNBASE+4MB) to PA’s [0, 4MB) [KERNBASE&gt;&gt;PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS, &#125;; Entry 512将虚拟地址KERNBASE:KERNBASE+0x400000 映射到物理地址0:0x400000。此entry将在entry完成后由内核使用；它将内核希望找到其指令和数据的高虚拟地址映射到引导加载程序加载加载器加载它们的低物理地址。此映射将内核指令和数据限制为4Mb。 回到entry过程中，它将entrypgdir的物理地址加载到控制寄存器%cr3中。分页硬件必须知道entrypgdir的物理地址，因为它还不知道如何翻译虚拟地址，即它还没有一个页面表。符号entrypgdir指向高内存中的地址，宏V2P_WO(0220)减去KERNBASE以查找物理地址。若要启用分页硬件，xv6在控制寄存器%cr0中设置CR0_PG标志。 启用分页后，处理器仍在低地址执行指令，这是因为entrypgdir映射低地址。如果xv6省略了 entrypgdir中的entry 0，则启用分页之后去尝试执行指令时，计算机将崩溃。 现在，entry需要跳转到内核的C代码，并在高内存中运行它。首先，它使堆栈指针%esp 指向要用作堆栈（1054）的内存。所有符号都有较高的地址（包括堆栈），因此即使删除了低映射，堆栈依旧有效。最后，entry进入main，这也是一个高地址。间接跳转是必要的，因为汇编程序将生成一个相对于pc的直接跳转，这将执行内存不足版本的main。Main无法返回，因为堆栈上没有返回 PC。现在内核在函数main（1217）中的高地址运行。12345678910111213141516171819202122232425262728293031323334//译者引入# Set up the stack pointer. movl $(stack + KSTACKSIZE), %esp// Bootstrap processor starts running C code here. // Allocate a real stack and switch to it, first // doing some setup required for memory allocator to work. int main(void) &#123; kinit1(end, P2V(4*1024*1024)); // phys page allocator kvmalloc(); // kernel page table mpinit(); // collect info about this machine lapicinit(); 1223 seginit(); // set up segments cprintf("\ncpu%d: starting xv6\n\n", cpu−&gt;id); picinit(); // interrupt controller ioapicinit(); // another interrupt controller consoleinit(); // I/O devices &amp; their interrupts uartinit(); // serial port pinit(); // process table tvinit(); // trap vectors binit(); // buffer cache fileinit(); // file table iinit(); // inode cache ideinit(); // disk if(!ismp) timerinit(); // uniprocessor timer startothers(); // start other processors kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers() userinit(); // first user process 1240 // Finish setting up this processor in mpmain. mpmain(); &#125; 代码：创建第一个进程现在内核在自己的地址空间内运行，我们来看看内核是如何创建用户级进程的，并确保内核和用户级进程之间以及进程本身之间的强隔离。 在main初始化多个设备和子系统后，它通过调用userinit（1239）创建第一个进程。Userinit 的第一个操作是调用allocproc。Allocproc（2455）的工作是在进程表中分配一个插槽0（槽就是一个proc结构体），并初始化内核线程执行所需的进程状态的各个部分。每个新进程都调用Allocproc，只有第一个进程调用userinit。Allocproc扫描proc表中是否有UNUSED状态的插槽（2461-2463）。当它找到未使用的插槽时，allocproc将状态设置为EMBMYO，将其标记为已使用，并为进程提供一个唯一的pid（2451-2469）。接下来，它尝试为进程的内核线程分配一个内核堆栈。如果内存分配失败，则allocproc会将状态更改回UNSED，并返回零信号失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//译者引入// Look in the process table for an UNUSED proc. // If found, change state to EMBRYO and initialize // state required to run in the kernel. // Otherwise return 0. static struct proc* allocproc(void) &#123; struct proc *p; char *sp; acquire(&amp;ptable.lock); for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++) if(p−&gt;state == UNUSED) goto found; release(&amp;ptable.lock); return 0; found: p−&gt;state = EMBRYO; p−&gt;pid = nextpid++; release(&amp;ptable.lock); // Allocate kernel stack. if((p−&gt;kstack = kalloc()) == 0)&#123; p−&gt;state = UNUSED; return 0; &#125; sp = p−&gt;kstack + KSTACKSIZE; // Leave room for trap frame. sp −= sizeof *p−&gt;tf; p−&gt;tf = (struct trapframe*)sp; // Set up new context to start executing at forkret, // which returns to trapret. sp −= 4; *(uint*)sp = (uint)trapret; sp −= sizeof *p−&gt;context; p−&gt;context = (struct context*)sp; memset(p−&gt;context, 0, sizeof *p−&gt;context); p−&gt;context−&gt;eip = (uint)forkret; return p; &#125;// Set up first user process. void userinit(void) &#123; struct proc *p; extern char _binary_initcode_start[], _binary_initcode_size[]; p = allocproc(); initproc = p; if((p−&gt;pgdir = setupkvm()) == 0) panic("userinit: out of memory?"); inituvm(p−&gt;pgdir, _binary_initcode_start, (int)_binary_initcode_size); p−&gt;sz = PGSIZE; memset(p−&gt;tf, 0, sizeof(*p−&gt;tf)); p−&gt;tf−&gt;cs = (SEG_UCODE &lt;&lt; 3) | DPL_USER; p−&gt;tf−&gt;ds = (SEG_UDATA &lt;&lt; 3) | DPL_USER; p−&gt;tf−&gt;es = p−&gt;tf−&gt;ds; p−&gt;tf−&gt;ss = p−&gt;tf−&gt;ds; p−&gt;tf−&gt;eflags = FL_IF; p−&gt;tf−&gt;esp = PGSIZE; p−&gt;tf−&gt;eip = 0; // beginning of initcode.S safestrcpy(p−&gt;name, "initcode", sizeof(p−&gt;name)); p−&gt;cwd = namei("/"); p−&gt;state = RUNNABLE; &#125;// A fork child’s very first scheduling by scheduler() // will swtch here. "Return" to user space. void forkret(void) &#123; static int first = 1; // Still holding ptable.lock from scheduler. release(&amp;ptable.lock); if (first) &#123; // Some initialization functions must be run in the context // of a regular process (e.g., they call sleep), and thus cannot 2792 // be run from main(). first = 0; initlog(); &#125; // Return to "caller", actually trapret (see allocproc). &#125;# Context switch # # void swtch(struct context **old, struct context *new); # # Save current register context in old # and then load register context from new. .globl swtch swtch: movl 4(%esp), %eax movl 8(%esp), %edx # Save old callee−save registers pushl %ebp pushl %ebx pushl %esi pushl %edi # Switch stacks movl %esp, (%eax) movl %edx, %esp # Load new callee−save registers popl %edi popl %esi popl %ebx popl %ebp ret// 3277# Return falls through to trapret... .globl trapret trapret: popal popl %gs popl %fs popl %es popl %ds addl $0x8, %esp # trapno and errcode iret 现在，allocproc必须设置新进程的内核堆栈。使用allocproc这个名词以便在创建第一个进程时可以使用fork。allocproc使用专门准备的内核堆栈和一组内核寄存器来设置新进程，这些内核寄存器集导致它在首次运行时“返回”到用户空间。准备好的内核堆栈的布局如图1-4所示。allocproc通过设置返回程序计数器值来完成这项工作的一部分，这将导致新进程的内核线程首先在forkret中执行，然后在trapret中执行（2486-2491）。内核线程将从p-&gt;context复制的寄存器内容开始执行。因此，将p-&gt;context-&gt;eip设置为forkret将导致内核线程在forkret（2783）开始时执行。此函数将返回到堆栈底部的任何地址。上下文切换代码（2958）将堆栈指针设置为p-&gt;context上方。allocproc把p-&gt;context放在栈上，并把指向trapret的指针放在上面，这就是forkret返回的地址。trapret从保存在内核栈的顶部的值恢复到用户寄存器上，并跳转到进程（3277）。此设置对于普通fork和创建第一个进程是相同的，尽管在后一种情况下，进程将开始在用户空间位置为零执行，而不是从fork返回的地方。 正如我们将在第3章中看到的，控制从用户软件传输到内核的方式是通过中断机制进行的，该机制由系统调用、中断和异常被使用。每当进程运行时控制传输到内核时，硬件和xv6陷阱输入代码将把用户寄存器保存在进程的内核堆栈上。userinit在新堆栈的顶部写入值，这些值看起来就像，如果进程是通过中断（2514-2520）进入内核的，就会一直在那里。因此从内核返回到进程的用户代码的二进制代码将工作。这些值存储着用户寄存器的struct trapframe。现在，新的进程的内核堆栈已完全准备好，如图1-4 所示。第一个进程将执行一个小程序（initcode.S；（8200））。进程需要物理内存来存储这个程序，该程序需要复制到内存中，并且该进程需要引用该内存的页表。 12345678910111213141516171819202122232425262728293031//译者引入//8200# Initial process execs /init. #include "syscall.h" #include "traps.h" # exec(init, argv) .globl start start: pushl $argv pushl $init pushl $0 // where caller pc would be movl $SYS_exec, %eax int $T_SYSCALL # for(;;) exit(); exit: movl $SYS_exit, %eax int $T_SYSCALL jmp exit # char init[] = "/init\0"; init: .string "/init\0" # char *argv[] = &#123; init, 0 &#125;; .p2align 2 argv: .long init .long 0 userinit调用setupkvm（1837）为进程创建一个页表，其中（首先）只用于内核使用的内存。我们将在第2章中详细研究此函数，但在高级setupkvm和userinit中创建一个地址空间，如图1-2所示。 第一个进程内存的初始内容是initcode.S的编译形式；作为内核构建过程的一部分，链接器在内核中嵌入了二进制，并定义了两个特殊符号， _binary_initcode_start和_binary_initcode_size，指示二进制文件的位置和大小。Userinit通过调用inituvm将该二进制文件复制到新进程的内存中，其将分配物理内存的一页，将虚拟地址零映射到该内存，并将二进制文件复制到该页（1903）。 然后，userinit使用初始用户模式状态设置陷阱帧（0602）：%cs寄存器包含在特权级别DPL_USER（如用户模式而非内核模式）上运行的SEG_UCODE段的段选择器，同样%ds、%es和%ss使用享有特权DPL_USER的SEG_UDATA。%eflags FL_IF 位设置为允许硬件中断；我们将在第3章中重新讨论这个问题。 堆栈指针%esp设置为进程的最大有效虚拟地址p-&gt;sz。指令指针设置为initcode的入口点，地址0。 函数userinit将p-&gt;name设置为initcode，主要用于调试。设置p-&gt;cwd为进程的当前工作目录；我们将在第6章中详细研究namei。 初始化进程后，userinit会通过将p-&gt;state设置为RUNNABLE来标记它可用于计划。 代码：运行第一个进程现在，第一个进程的状态已准备好，是运行它的时候了。在main调用userinit之后，mpmain调用调度程序（scheduler）以启动运行进程（1267）。Scheduler（2708）查找将p-&gt;state设置为”RUNNABLE”的进程，并且只有一个进程：initproc。它将每个cpu变量proc设置为它找到的进程，并调用switchnum告诉硬件开始使用目标进程的页面表（1868）。在内核中执行更改页面表是有效的，因为setupkvm会导致所有进程的页面表对内核代码和数据具有相同的映射。Switchnvm还设置了一个任务状态段SEG_TSS指示硬件在进程的内核堆栈上执行系统调用和中断。我们将在第3章中重新检查任务状态段123456789101112//译者引入//1260-1268// Common CPU setup code. static void mpmain(void) &#123; cprintf("cpu%d: starting\n", cpu−&gt;id); idtinit(); // load idt register xchg(&amp;cpu−&gt;started, 1); // tell startothers() we’re up scheduler(); // start running processes &#125; Scheduler现在将p-&gt;state设置为RUNNING，并调用swtch（2958）执行对目标进程的内核线程的上下文切换。swtch 保存当前寄存器，并将目标内核线程（proc-&gt;context）保存的寄存器加载到x86硬件寄存器中，包括堆栈指针和指令指针。当前上下文不是一个进程，而是一个特殊的per-cpu scheduler上下文，因此scheduler告诉swtch将当前硬件寄存器保存在per-cpu存储（cpu-schedule）中，而不是保存在任何进程的内核线程上下文。我们将在第5章中详细介绍swtch。最后的ret指令（2977）从堆栈中弹出目标进程的%eip，完成上下文切换。现在处理器运行在进程p的内核栈中。 Allocproc设置initproc的p-&gt;context-&gt;eip为forkret，因此，ret从forkret开始执行。在第一次调用（即这一次）上，forkret（2783）运行无法在main运行的初始化函数，因为它们必须在具有自己的内核堆栈的常规进程的上下文中运行。然后，forkret返回。Allocproc安排，p-&gt;context弹出后堆栈上的顶部单词是trapret，因此现在trapret开始执行，%esp设置为p-&gt;tf。Trapret（3277）使用弹出指令从陷阱帧（0602，trap frame）恢复寄存器，就像swtch对内核上下文所做的那样：popal还原常规寄存器，然后popl指令还原%gs、%fs、%es和%ds。addl跳过两个字段trapno和errcode。最后，iret指令从堆栈弹出%cs、%eip、%flags、%esp和%ss。陷阱帧的内容已转移到CPU状态，因此处理器将继续在陷阱帧中指定的%eip。对于initproc，这意味着虚拟地址零，即initproc.S的第一个指令。 此时，%eip为零，%esp为4096。这些是进程地址空间中的虚拟地址。处理器的分页硬件将它们转换为物理地址。allocuvm设置进程的页面表，使虚拟地址零指向为此进程分配的物理内存，并设置一个标志（PTE_U），告诉分页硬件允许用户代码访问该内存。userinit（2514）将%cs的低位设置为CPL=3去运行进程的用户代码，这意味着用户代码只能使用PTE_U标记的页面，并且不能修改敏感硬件寄存器，如%cr3。因此，该过程仅限于使用自己的内存。 第一个系统调用：exec现在我们已经看到了内核如何为进程提供强大的隔离，让我们看看用户级进程如何可以重新进入内核，请求它可以执行的服务。 initcode.S中的第一个操作的是调用exec系统调用。正如我们在第0章中看到的，exec用一个新的程序替换当前进程的内存和寄存器，但它使文件描述符、进程id和父进程保持不变。 initcode.S（8208）首先将三个值推入栈中：$argv、$init和$0，然后将%eax设置为SYS_exec，并执行int T_SYSCALL：它要求内核运行exec系统调用。如果一切顺利，exec永远不会返回：它开始运行由$init命名的程序，该程序是指向nul终止字符串/init（8221-8223）的指针。如果exec失败并返回，initcode循环调用exit系统调用，这绝对不应该返回 (8215-8219）。12345678910111213//译者引入//8221-8223# char init[] = "/init\0"; init: .string "/init\0"//8215-8219# for(;;) exit(); exit: movl $SYS_exit, %eax int $T_SYSCALL jmp exit Exec系统调用的参数是$init和$argv。最后的零使得这个手写的系统调用看起来像普通的系统调用，我们将在第3章中看到。与以前一样，此设置避免了对第一个进程的特殊化（在本例中为其第一个系统调用），而是重用xv6必须提供标准操作的代码。 第2章将详细介绍exec的实现，但在较高的层次上，它将用从文件系统加载的/init二进制文件替换initcode。现在，initcode（8200）已经完成，该进程将替代其运行。Init（8310）根据需要创建一个新的控制台设备文件，然后将其作为文件描述符0、1和2打开。然后，它循环，启动控制台外壳，处理孤立的僵尸，直到shell退出，并重复。至此系统已经完成启动。 12345678910111213141516171819202122232425262728293031323334353637// init: The initial user−level program #include "types.h" #include "stat.h" #include "user.h" #include "fcntl.h" char *argv[] = &#123; "sh", 0 &#125;; int main(void) &#123; int pid, wpid; if(open("console", O_RDWR) &lt; 0)&#123; mknod("console", 1, 1); open("console", O_RDWR); &#125; dup(0); // stdout dup(0); // stderr for(;;)&#123; printf(1, "init: starting sh\n"); pid = fork(); if(pid &lt; 0)&#123; printf(1, "init: fork failed\n"); exit(); &#125; if(pid == 0)&#123; exec("sh", argv); printf(1, "init: exec sh failed\n"); exit(); &#125; while((wpid=wait()) &gt;= 0 &amp;&amp; wpid != pid) printf(1, "zombie!\n"); &#125; &#125; 真实世界大多数操作系统都采用了进程这一概念，大多数进程看起来与xv6的相似。一个真正的操作系统会在常数时间内找到具有显式空闲列表的空间proc结构，而不是在分配器中的线性时间搜索；为了简单，xv6使用线性扫描（许多扫描中的第一个）。 xv6的地址空间布局存在无法使用超过2GB的物理RAM的缺陷。解决这个问题是可能的，尽管最好的计划是切换到具有64位地址的机器。 练习 在swtch设置断点。单步调试到forkret，然后使用gdb的finish进行trapret，然后stepi，直到你得到在虚拟地址为零的initcode KERNBASE限制单个进程可以使用的内存量，这可能会在具有完整的4GB RAM 的计算机上引起干扰。提升KERNBASE是否允许进程使用更多内存？]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Lab:Memory Management]]></title>
    <url>%2F2019%2F03%2F24%2FMIT-6-828-Lab-Memory-Management%2F</url>
    <content type="text"><![CDATA[实验2：内存管理 MIT 6.828 Operating System Engineering 该实验原始指南 简介在本实验中，将编写操作系统的内存管理代码。内存管理有两个组成部分 内核的物理内存分配器：因此内核可以分配内存，释放内存。分配器将以4096字节为单位运行，即页。这次lab的任务是维护数据结构，记录哪些物理页面是空闲的，哪些是已分配的，以及共享每个已分配页面的进程数。除此之外，还要编写例程来分配和释放内存页面 虚拟内存：将内核和用户程序使用的虚拟地址映射到物理内存中的地址。当指令使用内存时，x86硬件的内存管理单元（MMU）执行映射，查询一组页表 实验2包含以下新的源文件 memlayout.h：描述了虚拟地址空间的布局 pmap.c：读取此设备硬件以便计算出有多少物理内存 pmap.h：定义了相关数据结构 kclock.c：操纵PC的时钟和CMOS RAM硬件 kclock.h：其中BIOS记录PC包含的物理内存量等 重点阅读memlayout.h 以及 pmap.h，还需参考 inc/mmu.h 第1部分：物理页面管理操作系统需要追踪那部分物理内存是空闲的，那部分是正在使用的。JOS以页粒度（page granularity）管理PC的物理内存，以便可以使用MMU映射和保护每个分配的内存。 现在要编写物理页分配器（physical page allocator）。它通过以struct PageInfo组成的链表跟踪哪些页面是空闲的（与xv6不同，它们没有嵌入到自由页面本身中？？？），每个对应于一个物理页面。在编写剩余的虚拟内存实现之前，您需要编写物理页分配器，因为页表管理代码需要分配用于存储页表的物理内存。 In the file kern/pmap.c, you must implement code for the following functions (probably in the order given). boot_alloc() mem_init() (only up to the call to check_page_free_list(1)) page_init() page_alloc() page_free() check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct. 先看看相关的函数理理思路：mem_init()：在内核刚开始运行时就会调用这个子函数，对整个操作系统的内存管理系统进行一些初始化的设置，比如设定页表等等操作。该函数里面又会有以下子函数。static void i386_detect_memory(void)：在MIT 6.828 Lab:Booting a PC的图中我们看到物理内存被默认分为三个部分。该函数会去探测basemem和extmem两部分的大小，并计算出对应的物理页的数量。 0x00000~0xA0000，这部分也叫basemem，是可用的 0xA0000~0x100000，这部分叫做IO hole，是不可用的，主要被用来分配给外部设备、BIOS ROM 0x100000~0x...，这部分叫做extmem，是可用的，这是最重要的内存区域 kern_pgdir = (pde_t *) boot_alloc(PGSIZE); memset(kern_pgdir, 0, PGSIZE);：kern_pgdir是一个指针，它是指向操作系统的页目录表的指针，操作系统之后工作在虚拟内存模式下时，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存大小空间为PGSIZE，即一个页的大小。并且把这部分内存清0。 boot_alloc这里调用了boot_alloc函数，这个函数是实验要完成的函数：它只是被用来暂时当做页分配器，之后我们使用的真实页分配器是page_alloc()。注释中对该函数要实现什么功能已经说得很明白。1234567891011// Allocate a chunk large enough to hold 'n' bytes, then update// nextfree. Make sure nextfree is kept aligned// to a multiple of PGSIZE.//// LAB 2: Your code here.result = nextfree;nextfree = ROUNDUP(nextfree + n,PGSIZE);if((uint32_t)nextfree - KERNBASE &gt; (npages*PGSIZE)) panic("out of memory\n"); cprintf("boot_alloc %d bytes memory success\n",n); return result; kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;这一条语句就是为页目录表添加第一个页目录表项。通过查看memlayout.h文件，我们可以看到，UVPT的定义是一段虚拟地址的起始地址0xef400000，从这个虚拟地址开始，存放的就是这个操作系统的页表kern_pgdir，所以我们必须把它和页表kern_pgdir的物理地址映射起来，PADDR(kern_pgdir)就是在计算kern_pgdir所对应的真实物理地址。 1234567891011struct PageInfo &#123; // Next page on the free list. struct PageInfo *pp_link; // pp_ref is the count of pointers (usually in page table entries) // to this page, for pages allocated using page_alloc. // Pages allocated at boot time using pmap.c's // boot_alloc do not have valid reference count fields. uint16_t pp_ref;&#125;; 接下来的注释提醒我们要去分配一块内存，来存放一个struct PageInfo的数组，上面就是结构在memlayout.h中的定义，数组中的每一个PageInfo代表内存当中的一个物理页。操作系统内核就是通过这个数组来追踪所有内存页的使用情况。12pages = (struct PageInfo *)boot_alloc(npages * sizeof(PageInfo));memset(pages,0,npages * sizeof(PageInfo)); page_init()之后就会调用page_init()，也就是这个练习的重头戏。通过上面的页表的分配，目前的物理内存状态如下所示 如注释所说，该函数要初始化pages数组和page_free_list链表，上图给出了此时物理内存的使用情况，因此需要根据该图来初始化数组和链表。1234567891011121314151617181920212223242526272829size_t i;// IOPHYSMEM:the start address of IO hole // io_hole:the index of IO hole in pagessize_t io_hole = (size_t)IOPHYSMEM / PGSIZE;// boot_alloc(0):return the end address of kernel// kernel_end:including [IOPHYSMEM,EXTPHYSMEM] and [EXTPHYSMEM,...]size_t kernel_end = PADDR(boot_alloc(0)) / PGSIZE;page_free_list = NULL;for(i = 0;i &lt; npages ;i++)&#123; // mark physical page 0 as in use if(i == 0)&#123; pages[0].pp_ref = 1; pages[0].pp_link = NULL; continue; &#125; // mark physical page [PGSIZE,npages_basemem * PGSIZE] as free else if(i &gt;= io_hole &amp;&amp; i &lt; kernel_end)&#123; pages[i].pp_ref = 0; pages[i].pp_link = NULL; &#125; else&#123; pages[i].pp_ref = 0; pages[i].pp_link = page_free_list; page_free_list = &amp;pages[i]; &#125;&#125; page_alloc123456789101112131415struct PageInfo *result; // out of memory if(page_free_list == NULL) return NULL; result = page_free_list; page_free_list = result-&gt;pp_link; result-&gt;pp_link = NULL; // page2kva:get virtual address by physical address(result) if(alloc_flags &amp; ALLOC_ZERO) memset(page2kva(result),0,PGSIZE); return result; page_free1234567// Fill this function in // Hint: You may want to panic if pp-&gt;pp_ref is nonzero or // pp-&gt;pp_link is not NULL. if(pp-&gt;pp_link != NULL || pp-&gt;pp_ref != 0) panic("page still in used\n"); pp-&gt;pp_link = page_free_list; page_free_list = pp; 重新玩到mem_init函数，会调用check_page_free_list(1)和check_page_alloc()。这两个函数通过一系列断言，判断我们的实现是否符合预期。至此第一部分就算完成。 第2部分：虚拟内存 在做其他任何事情之前，请熟悉x86的保护模式内存管理架构：即分段和页面转换。 80386分两步将逻辑地址（即程序员查看的地址）转换为物理地址（即物理内存中的实际地址） 段转换，其中逻辑地址（由段选择器和段偏移组成）被转换为线性地址。 页面转换，其中线性地址转换为物理地址。此步骤是可选的，由系统软件设计人员决定。此阶段的地址转换实现了面向页面的虚拟内存系统和页面级保护所需的基本功能。 段翻译处理器将逻辑地址转换为线性地址，需要使用以下数据结构：描述符、描述符表，选择器、段寄存器。 描述符由编译器，链接器，加载器或操作系统创建，而不是由应用程序员创建 段描述符存储于两种描述符表中的一种：全局描述符表（GDT）和本地描述符表（LDT）。处理器通过GDTR和LDTR寄存器将GDT和当前LDT定位在存储器中。这些寄存器将表的基址存储在线性地址空间中，并存储段限制 逻辑地址的选择器部分通过指定描述符表并索引该表内的描述符来标识描述符。应用程序可以将选择器看作指针变量中的字段，但选择器的值通常由链接器或链接加载器分配（固定）。 80386在段寄存器中存储来自的描述符的信息，从而避免在每次访问存储器时查询描述符表。 每个段寄存器都有一个“可见”部分和一个“不可见”部分。这些段地址寄存器的可见部分由程序操作，就好像它们只是16位寄存器一样。不可见部分由处理器操纵。 加载这些寄存器的操作是正常的程序指令（之前在第3章中描述 ）。这些说明分为两类： 使用正常的程序指令，程序使用16位选择器加载段寄存器的可见部分。处理器自动从描述符表中提取基址，限制，类型和其他信息，并将它们加载到段寄存器的不可见部分。 因为大多数指令指的是其选择器已经被加载到段寄存器中的段中的数据，所以处理器可以将指令提供的段相对偏移添加到段基地址而没有额外的开销。 页面翻译虚拟，线性和物理地址引用计数页表管理第3部分：内核地址空间参考参考参考参考]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编程珠玑》]]></title>
    <url>%2F2019%2F03%2F21%2F%E3%80%8A%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E3%80%8B%2F</url>
    <content type="text"><![CDATA[正如自然界的珍珠来自于磨砺牡蛎的细沙一样，这些编程珠玑来自于磨砺程序员的实际问题 在无止境地追求精湛技艺一点上，程序员、数学家和武侠其实是相通的 对实例的深入思考不仅有趣，而且可以获得实际的益处 现在的自己有了一些大局观，但就是缺乏对细节的打磨，这本书刚好可以锻炼自己这方面的能力！ 阅读这本书不能读太快，一次读一章，要尝试解答书中的问题，并努力回答每章末尾的习题。对于这样一本满是Pearls的书籍，决不能糟蹋！ Chapter 1 Chapter 5]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备份与恢复]]></title>
    <url>%2F2019%2F03%2F20%2FMySQL-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[备份！备份！]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2019%2F03%2F20%2FMySQL-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务（transaction）也是数据库区别于文件系统的重要特性之一，]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁]]></title>
    <url>%2F2019%2F03%2F20%2FMySQL-%E9%94%81%2F</url>
    <content type="text"><![CDATA[锁是数据库系统区别于文件系统的一个关键特性 锁机制用于管理对共享资源的并发访问，不同的数据库虽然有相同的SQL，但却设计了不同的锁。InnoDB的锁提供了一致性的非锁定读、行级锁支持 lock &amp; latchlatch主要分为mutex和rwlock，用来保证并发线程操作临界资源的正确性，用来保护内存中的数据结构，没有死锁检测机制，这种锁更像是之前在CSAPP中学的锁 lock的对象则是事务，用来锁定数据库的表、页和行 简介InnoDB中实现了两种行级锁 S lock：允许事务读取一行数据 X lock：允许事务删除或更新一行数据 上面两种锁，很像CSAPP中提到的读者-写者模型，也就是读写锁 InnoDB也支持不同粒度的锁，但不是特定粒度的锁，而是一种叫做Intention Lock（意向锁），要对记录上锁，就要将对应的页、表和数据库上意向锁。意向锁其实是表级别的锁，又分为 IS lock：事务想要获取表中某几行的S lock IX lock：事务想要获取表中某几行的X lock 可以通过mysql&gt; desc information_schema.INNODB_xxx;查看INNODB_TRX（事务的状态信息） INNODB_LOCKS（锁的状态） INNODB_LOCK_WAITS（反应事务请求和等待锁的状态）三张表的结构 一致性非锁定读]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lex/Yacc入门]]></title>
    <url>%2F2019%2F03%2F19%2FLex-Yacc%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[词法分析器（Scanner）和语法解析器 Lex（Lexical Analyzar）词法分析器，简单来说，其任务就是将输入的各种符号，转化成相应的标识符(token)，转化后的标识符 很容易被后续阶段处理 Lex工具是一种词法分析程序生成器，它可以根据词法规则说明书的要求来生成单词识别程序，由该程序识别出输入文本中的各个单词。 一般可以分为定义部分、规则部分、用户子程序部分。其中规则部分是必须的，定义和用户子程序部分是任选的 Lex编程可以分为三步： 以Lex可以理解的格式指定模式相关的动作 在这一文件上运行Lex，生成扫描器的C代码 编译和链接C代码，生成可执行的扫描器 下面的程序识别一组动词1234567891011121314151617181920212223242526272829303132333435363738394041%&#123;#include &lt;stdio.h&gt;int k;%&#125;%%[\t ]+is |am |are |were |was |be |being |been |do |does |did |will |would |should |can |could |has |have |had |go &#123; printf("%s: is a verb\n",yytext); &#125;[a-zA-Z]+ &#123;printf("%s: is not a verb\n",yytext);&#125;.|\n &#123;ECHO;&#125;%%int main()&#123; yyin = fopen("example.txt","r"); yylex(); fclose(yyin);&#125;int yywrap()&#123; return 1;&#125; 通过flex flex_test.l命令生成相应的C语言程序，然后编译执行，得到下图 定义部分起始于%{，终止于%}符号 规则部分起始于%%符号，终止于%%符号，期间就是词法规则，词法规则由模式和动作组成。模式部分可以由任意的正则表达式组成，动作部分是由C语言语句组成，这些语句用来对所匹配的模式进行相应处理 需要注意的是，lex将识别出来的单词存放在yytext[]字符数据中，因此该数组的内容就代表了所识别出来的单词的内容。类似yytext这些预定义的变量函数会随着后面内容展开一一介绍。动作部分如果有多行执行语句，也可以用{}括起来 正则表达式是规则部分最麻烦的一部分 规则部分也能使用变量，例如1234567891011%&#123;#include "stdio.h"int linenum;%&#125;int [0-9]+float [0-9]*/.[0-9]+%%&#123;int&#125; printf("Int : %s/n",yytext);&#123;float&#125; printf("Float : %s/n",yytext);. printf("Unknown : %c/n",yytext[0]);%% 在%}和%%之间，加入了一些类似变量的东西，注意是没有;的，这表示int，float分别代指特定的含义，在两个%%之间，可以通过{int} {float}进行直接引用，简化模式定义 用户子程序部分最后一个%%后面的内容是用户子程序部分，可以包含用C语言编写的子程序，而这些子程序可以用在前面的动作中，这样就可以达到简化编程的目的。这里需要注意的是，当编译时不带-ll选项时，是必须加入main函数和yywrap，如： 1234567891011121314151617%%showtitle()&#123;printf("----- Lex Example -----/n");&#125;int main()&#123; linenum=0; yylex(); /* 进行Lex分析 */ printf("/nLine Count: %d/n",linenum); return 0;&#125;int yywrap()&#123;return 1;&#125; Lex内置变量和函数内置变量： yytext： char *，当前匹配的字符串 yyleng： int，当前匹配的字符串长度 yyin： FILE *，lex当前的解析文件，默认为标准输出 yyout： FILE *，lex解析后的输出文件，默认为标准输入 yylineno： int，当前的行数信息 内置宏： ECHO：#define ECHO fwrite(yytext, yyleng, 1, yyout)，也是未匹配字符的默认动作 内置函数： int yylex(void)：调用Lex进行词法分析 int yywrap(void)：在文件(或输入)的末尾调用。如果函数的返回值是1，就停止解析。因此它可以用来解析多个文件。代码可以写在第三段，这样可以解析多个文件。方法是使用yyin文件指针指向不同的文件，直到所有的文件都被解析。最后，yywrap() 可以返回1来表示解析的结束 Lex其实就是词法分析器，通过配置文件*.l，依据正则表达式逐字符去顺序解析文件，并动态更新内存的数据解析状态。不过Lex只有状态和状态转换能力。因为它没有堆栈，它不适合用于剖析外壳结构。而yacc增加了一个堆栈，并且能够轻易处理像括号这样的结构。Lex善长于模式匹配，如果有更多的运算要求就需要yacc了 YaccYacc文法采用BNF(Backus-Naur Form)的变量规则描述。BNF文法最初由John Backus和Peter Naur发明，并且用于描述Algol60语言。BNF能够用于表达上下文无关的语言。现代程序语言大多数结构能够用BNF来描述 出现在每个产生式左边(left-hand side：lhs)的符号是非终端符号，出现在产生式右边(right-hand side：rhs)的符号有非终端符号和终端符号，但终端符号只出现在右端 1、yacc语法规则部分和BNF类同，先来看BNF巴克斯范式 （1）&lt;&gt; 内包含的内容为必选项； （2）[] 内的包含的内容为可选项； （3）{ } 内包含的为可重复0至无数次的项； （4） | 表示在其左右两边任选一项，相当于”OR”的意思；（5）::= 是“被定义为”的意思；（6）双引号“”内的内容代表这些字符本身；而double _quote用来表示双引号 2.Yacc文件格式Yacc文件分为三部分：12345... definitions ...%%... rules ...%%... subroutines ... 3.定义部分第一部分包括标志(token)定义和C代码(用“%{”和“%}”括起来)。 如在定义部分定义标志： %token INTEGER当运行yacc后，会产生头文件，里面包含该标志的预定义，如：12345#ifndef YYSTYPE#define YYSTYPE int#endif#define INTEGER 258extern YYSTYPE yylval; lex使用该头文件中的标志定义。Yacc调用lex的yylex()来获得标志(token)，与标志对应的值由lex放在变量yylval中。yylval的类型由YYSTYPE决定，YYSTYPE缺省类型是int。如： [0-9]+ {yylval = atoi(yytext);return INTEGER;}标志0-255被保留作为字符值，一般产生的token标志从258开始。如： 1[-+] return *yytext; /* return operator */ 返回加号或减号。注意要把减号放在前面，避免被认作是范围符号。 对于操作符，可以定义%left和%right：%left表示左相关(left-associative)，%right表示右相关(right-associative)。可以定义多组%left或%right，在后面定义的组有更高的优先级。如：12%left ‘+’ ‘-‘%left ‘*’ ‘/’ 上面定义的乘法和除法比加法和减法有更高的优先级。 Yacc内部维持着两个栈：符号栈(parse stack)和值栈(value stack)，这两个栈始终是同步的。 改变YYSTYPE的类型。如这样定义TTSTYPE：12345%union &#123; int iValue; /* integer value */ char sIndex; /* symbol table index */ nodeType *nPtr; /* node pointer */&#125;; 则生成的头文件中的内容是：123456typedef union &#123; int iValue; /* integer value */ char sIndex; /* symbol table index */ nodeType *nPtr; /* node pointer */&#125; YYSTYPE;extern YYSTYPE yylval; 可以把标志(token)绑定到YYSTYPE的某个域。如：12%token &lt;iValue&gt; INTEGER%type &lt;nPtr&gt; expr 把expr绑定到nPtr，把INTEGER绑定到iValue。yacc处理时会做转换。如： expr: INTEGER { $ = con($1); }转换结果为： yylval.nPtr = con(yyvsp[0].iValue);其中yyvsp[0]是值栈(value stack)当前的头部。 定义一元减号符有更高的优先级的方法：1234%left GE LE EQ NE &apos;&gt;&apos; &apos;&lt;&apos;%left &apos;+&apos; &apos;-&apos;%left &apos;*&apos;%nonassoc UMINUS %nonassoc的含义是没有结合性。它一般与%prec结合使用表示该操作有同样的优先级。如： expr: ‘-‘ expr %prec UMINUS { $ = node(UMINUS, 1, $2); }表示该操作的优先级与UMINUS相同，在上面的定义中，UMINUS的优先级高于其他操作符，所以该操作的优先级也高于其他操作符计算。 4.规则部分规则部分很象BNF语法。 规则中目标或非终端符放在左边，后跟一个冒号(:)，然后是产生式的右边，之后是对应的动作(用{}包含)。如：1234567891011121314151617181920%token INTEGER%%program: program expr &apos;/n&apos; &#123; printf(&quot;%d/n&quot;, $2); &#125;|;expr: INTEGER &#123; $ = $1; &#125;| expr &apos;+&apos; expr &#123; $ = $1 + $3; &#125;| expr &apos;-&apos; expr &#123; $ = $1 - $3; &#125;;%%int yyerror(char *s)&#123; fprintf(stderr, &quot;%s/n&quot;, s); return 0;&#125;int main(void)&#123; yyparse(); return 0;&#125; 其中，$1表示右边的第一个标记的值，$2表示右边的第二个标记的值，依次类推。$$表示规约后的值。 5.第三部分该部分是函数部分。当yacc解析出错时，会调用函数yyerror()，用户可自定义函数的实现。main函数是调用yacc解析入口函数yyparse()。 6.递归的处理递归处理有左递归和右递归。 左递归形式： list:item| list ‘,’ item ;右递归形式： list: item| item ‘,’ list使用右递归时，所有的项都压入堆栈里，才开始规约；而使用左递归的话，同一时刻不会有超过三个项在堆栈里。 所以，使用左递归有很大的优势。 7.If-Else的冲突当有两个IF一个ELSE时，该ELSE和哪个IF匹配是一个问题。有两中匹配方法：与第一个匹配和与第二匹配。现代程序语言都让ELSE与最近的IF匹配，这也是yacc的缺省行为。 虽然yacc行为正确，但为避免警告，可以给IF-ELSE语句比IF语句更高的优先级：1234%nonassoc IFX%nonassoc ELSEstmt: IF expr stmt %prec IFX| IF expr stmt ELSE stmt 8.出错处理当yacc解析出错时，缺省的行为是调用函数yyerror()，然后从yylex返回一个值。一个更友好的方法是忽略一段错误输入流，继续开始扫描。实现方法如下：12345678910111213stmt:&apos;;&apos;| expr &apos;;&apos;| PRINT expr &apos;;&apos;| VARIABLE &apos;=&apos; expr &apos;;| WHILE &apos;(&apos; expr &apos;)&apos; stmt| IF &apos;(&apos; expr &apos;)&apos; stmt %prec IFX| IF &apos;(&apos; expr &apos;)&apos; stmt ELSE stmt| &apos;&#123;&apos; stmt_list &apos;&#125;&apos;| error &apos;;&apos;| error &apos;&#125;&apos;; 这里的error标志表示，当yacc发现错误时，它调用yyerror()，之后是输入流往前到‘；’或‘}’，然后继续扫描 9.Yacc源程序的风格建议按照如下风格来写：终端符名全部用大写字母，非终端符全部用小写字母；把语法规则和语义动作放在不同的行；把左部相同的规则写在一起，左部只写一次，而后面所有规则都写在竖线“|”之后；把分号“；”放在规则最后，独占一行；用制表符来对齐规则和动作]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全性]]></title>
    <url>%2F2019%2F03%2F19%2FJCP-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[要编写线程安全的代码，其核心就是要对状态访问操作进行管理，尤其是对共享和可变的状态的管理 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那这个类就是线程安全的 无状态（既不包含任何域，也不包含任何对其他类中域的引用）的对象一定是线程安全的 最常见的竞态条件（Race Condition）就是先检查后执行操作，其本质就是通过一种可能失效的观察结果来做出判断或执行某个计算 为了保证线程安全性，先检查后执行（如延迟初始化）和读取-修改-写入（如递增）等操作必须是原子的，这类操作都是复合操作，必须通过加锁等机制让其变为原子性的 Java提供了一种内置的锁机制来执行原子性：Synchronize Block。其包括两个部分：一个作为锁的对象引用，一个作为由这个锁对象保护的代码块。以Synchronize修饰的方法就是横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁或监视器锁？？？ 当某个线程请求其他线程持有的锁时，会被阻塞。但是某个线程试图获得自己持有的锁时，就会成功。这种重入意味着获取锁的操作的粒度是线程，而不是调用（Pthread中互斥体的获取操作是以调用为粒度）？？？ 重入的一种实现方式就是，为每个锁关联一个获取计数值和一个所有者线程 当执行时间较长的计算或可能无法快速完成的操作时，一定不要持有锁]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Performance]]></title>
    <url>%2F2019%2F03%2F15%2Flab-performance%2F</url>
    <content type="text"><![CDATA[优化内存密集型代码 简介在本实验中，我们将考虑两个图像处理操作：旋转（旋转以$90^°$逆时针旋转图像）和平滑（“平滑”或“模糊”图像）]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2F2019%2F03%2F15%2Flab-shell%2F</url>
    <content type="text"><![CDATA[熟悉过程控制和信号 简介编写一个支持工作控制的Unix Shell程序，使自己更熟悉进程控制和信号]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cache]]></title>
    <url>%2F2019%2F03%2F15%2Flab-cache%2F</url>
    <content type="text"><![CDATA[了解cache memories可能对C程序的性能产生的影响 [参考] 第九章：虚拟内存 简介第一部分编写一个模拟缓存行为的C程序，第二部分将优化一个矩阵转置函数，最大限度地减少缓存丢失的次数 实验中只要修改csim.c和trans.c两个文件 在实验目录中有一个trace文件夹，里面包含了一系列的reference trace files，去评估编写第一部分代码的正确性。该文件由valgrind生成，生成的数据具有以下形式1[space]operation address,size 其中在operation中，I表示指令加载，L表示数据加载，S表示数据存储，M表示数据修改；address表示64位十六进制内存地址，size指定了操作访问的字节数 Part A在Part A部分中，将在csim.c中编写一个缓存模拟器，该模拟器将valgrind内存跟踪作为输入，模拟此跟踪上的缓存内存的hit/miss行为，并输出命中次数、错过次数和逐出次数。 我们为您提供了一个名为csim-ref的参考缓存模拟器的二进制可执行文件，valgrind跟踪文件上的行为。在选择要驱逐的缓存行时，它使用LRU（最近使用最少的）替换策略。编写的模拟器要能处理以下命令行参数：./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt; -h: Optional help flag that prints usage info -v: Optional verbose flag that displays trace info -s: Number of set index bits (S =2s is the number of sets) -E: Associativity (number of lines per set) -b: Number of block bits (B =2b is the block size) -t: Name of the valgrind trace to replay]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data]]></title>
    <url>%2F2019%2F03%2F15%2Flab-data%2F</url>
    <content type="text"><![CDATA[熟悉整数和浮点数的位级表示 简介本实验只需要修改bits.c，该文件包含了15个编程谜题的骨架，我们的任务是使用straightline代码（没有循环、条件语句）和有限的C算术和逻辑运算符（! ˜ &amp; ˆ | + &lt;&lt; &gt;&gt;）去完成每个函数骨架]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Lab:Booting a PC]]></title>
    <url>%2F2019%2F03%2F14%2FMIT-6-828-Lab-Booting-a-PC%2F</url>
    <content type="text"><![CDATA[实验1：启动PC MIT 6.828 Operating System Engineering 该实验原始指南 简介本实验分为三个部分 getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstrap procedure examines the boot loader for our 6.828 kernel delves into the initial template for our 6.828 kernel itself PC Bootstrap介绍x86汇编语言和PC引导程序（PC Bootstrap），并开始使用QEMU和QEMU/GDB调试 Getting Started with x86 assemblyMIT官方为我们提供了一个关于汇编语言的参考资料pcasm-book，里面基本介绍了汇编语言的方方面面，你可以把这本书作为一个备查，遇到没看过的命令就上里面查，或者直接上网查。如果没有任何汇编基础，建议还是看一看书，把一些基础的指令看懂 本书中的示例是为NASM汇编程序编写的，而我们将使用GNU汇编程序。NASM使用所谓的Intel语法，而GNU使用AT＆T语法。虽然在语义上是等效的，但是程序集文件会有很大不同，至少表面上看，这取决于使用的语法。幸运的是，两者之间的转换非常简单，并且在汇编指南中有所介绍 Simulating the x86Instead of developing the operating system on a real, physical personal computer (PC), we use a program that faithfully emulates a complete PC: the code you write for the emulator will boot on a real PC too. Using an emulator simplifies debugging; you can, for example, set break points inside of the emulated x86, which is difficult to do with the silicon version of an x86. 进行该部分需要安装QEMU（MIT 6.828 Lab:Guide，该文章中有实验的所有前期准备指南）和熟悉GDB调试（GDB GCC） Everything after &#39;Booting from Hard Disk...&#39; was printed by our skeletal JOS kernel; the K&gt; is the prompt printed by the small monitor, or interactive control program, that we&#39;ve included in the kernel. These lines printed by the kernel will also appear in the regular shell window from which you ran QEMU. This is because for testing and lab grading purposes we have set up the JOS kernel to write its console output not only to the virtual VGA display (as seen in the QEMU window), but also to the simulated PC&#39;s virtual serial port, which QEMU in turn outputs to its own standard output. 启动给内核之后，所有字符就是由JOS kernel产生 There are only two commands you can give to the kernel monitor, help and kerninfo. 现在只有两个命令可以使用：help kerninfo Although simple, it&#39;s important to note that this kernel monitor is running &quot;directly&quot; on the &quot;raw (virtual) hardware&quot; of the simulated PC. This means that you should be able to copy the contents of obj/kern/kernel.img onto the first few sectors of a real hard disk, insert that hard disk into a real PC, turn it on, and see exactly the same thing on the PC&#39;s real screen as you did above in the QEMU window 虽然该内核还比较简单，但只要愿意，可以将该内核镜像写入硬盘前几个扇区，就能想真正启动PC一样启动它，并能看到完全一样的东西 The PC’s Physical Address SpaceA PC&#39;s physical address space is hard-wired to have the following general layout: 早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为Low memory，这只能被随机存储器(RAM)使用 从0x000A0000到0x000FFFFF的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从0x000F0000到0x000FFFFF占据64KB区域的部分是最重要的BIOS 现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了0xFFFFFFFF。JOS这里只用开始的256MB，所以假设PC只有32位地址空间 The ROM BIOS这部分研究计算机如何启动 在一个终端中输入make qemu-gdb，这将启动QEMU，但QEMU在处理器执行第一条指令之前停止，并等待来自GDB的调试连接，另一个终端输入make gdb [f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b是GDB反汇编出的第一条执行指令，表明： IBM PC从物理地址0x000ffff0处执行，该地址位于为ROM BIOS保留的64KB区域的最顶端 PC从地址CS=0xf000,IP=0xfff0开始执行 执行的第一条指令是jmp指令，它跳转到分段地址CS = 0xf000,IP=0xe05b 由于PC中的BIOS与物理地址范围0x000f0000-0x000fffff“硬连线”，因此该设计可确保BIOS在上电或任何系统重启后始终首先控制机器。QEMU仿真器带有自己的BIOS，它放置在处理器的模拟物理地址空间中的位置。当通电后，处理器进入实模式也就是设置CS:IP两个寄存器为CS=0xf000,IP=0xfff0，为什么这个段地址指示的是0x000ffff0？ 0x000ffff0是BIOS结束前的16个字节（0x100000） 当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取Boot loader并转移控制 可以通过GDBsi命令一步步猜测BIOS正在做什么！ The Boot LoaderPC的软盘和硬盘分为512个字节区域，称为扇区。扇区是磁盘的最小传输粒度：每个读取或写入操作必须是一个或多个扇区，并在扇区边界上对齐。如果磁盘是可引导的，则第一个扇区称为引导扇区，因为这是boot loader代码所在的位置。当BIOS找到可引导的软盘或硬盘时，它将512字节的引导扇区加载到物理地址0x7c00到0x7dff的内存中，然后使用jmp指令将CS：IP设置为0000：7c00，将控制权传递给boot loader 对于6.828，boot loader包含一个汇编语言源文件boot/boot.S和一个C源文件boot/main.c，仔细查看这些源文件，确保您了解正在发生的事情 boot loader分为汇编语言和C语言两部分的原因，我想是因为最开始启动的时候使用汇编更加精准，之后使用C则使编码效率更高，语义更丰富 在main.c有以下注释，详细讲述了启动流程123456789101112131415161718192021222324252627/********************************************************************** * This a dirt simple boot loader, whose sole job is to boot * an ELF kernel image from the first IDE hard disk. * * DISK LAYOUT * * This program(boot.S and main.c) is the bootloader. It should * be stored in the first sector of the disk. * * * The 2nd sector onward holds the kernel image. * * * The kernel image must be in ELF format. * * BOOT UP STEPS * * when the CPU boots it loads the BIOS into memory and executes it * * * the BIOS intializes devices, sets of the interrupt routines, and * reads the first sector of the boot device(e.g., hard-drive) * into memory and jumps to it. * * * Assuming this boot loader is stored in the first sector of the * hard-drive, this code takes over... * * * control starts in boot.S -- which sets up protected mode, * and a stack so C code then run, then calls bootmain() * * * bootmain() in this file takes over, reads in the kernel and jumps to it. **********************************************************************/ boot loader执行两个主要功能： boot loader将处理器从实模式切换到32位保护模式，因为只有在此模式下，软件才能访问处理器物理地址空间中1MB以上的所有内存 boot loader通过x86的特殊I/O指令直接访问IDE磁盘设备寄存器，从硬盘读取内核 在了解了boot loader源代码之后，查看文件obj/boot/boot.asm。此文件是我们的GNUmakefile在编译boot loader后创建的boot loader的反汇编。这个反汇编文件可以很容易地查看所有boot loader代码所在的物理内存的确切位置，并且可以更轻松地跟踪在GDB中单步执行boot loader时发生的情况。同样，obj/kern/kernel.asm包含一个JOS内核的反汇编，它通常可用于调试 Exercise 3在地址0x7c00处设置断点，这是加载引导扇区的位置。继续执行直到该断点。通过跟踪开机代码/boot.S、使用的源代码、反汇编文件OBJ的/boot/boot.asm跟踪你在哪里。还可以使用GDB中的x/i命令来反汇编boot loader中的指令序列，并将原始boot loader代码与obj/boot/boot.asm和GDB中的反汇编进行比较 跟踪main.c/bootmain()，然后进入readsect() 。确定与readsect()中每个语句对应的精确汇编指令。跟踪readsect()的其余部分并返回到bootmain()，并识别for循环的开始和结束，从磁盘读取内核的剩余扇区。找出循环结束时将运行的代码，在那里设置断点，并继续该断点。然后逐步执行boot loader的其余部分 问题： At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode? What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded? 123456// call the entry point from the ELF header// note: does not return!((void (*)(void)) (ELFHDR-&gt;e_entry))();(gdb) si=&gt; 0x10000c: movw $0x1234,0x472 How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?通过查看ELF信息头查看 回答完这三个命令，我们再好好看一看这几段代码！123456789101112131415161718192021222324252627282930voidbootmain(void)&#123; struct Proghdr *ph, *eph; // read 1st page off disk readseg((uint32_t) ELFHDR, SECTSIZE*8, 0); // is this a valid ELF? if (ELFHDR-&gt;e_magic != ELF_MAGIC) goto bad; // load each program segment (ignores ph flags) ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; for (; ph &lt; eph; ph++) // p_pa is the load address of this segment (as well // as the physical address) readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset); // call the entry point from the ELF header // note: does not return! ((void (*)(void)) (ELFHDR-&gt;e_entry))();bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1) /* do nothing */;&#125; bootmain先读取ELF文件头信息（关于ELF文件，可以查看《目标文件》），获取文件大小，然后判断魔数，然后调用readseg函数循环读取扇区内容 12345678910111213141516171819202122232425262728// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.// Might copy more than askedvoidreadseg(uint32_t pa, uint32_t count, uint32_t offset)&#123; uint32_t end_pa; end_pa = pa + count; // round down to sector boundary pa &amp;= ~(SECTSIZE - 1); // translate from bytes to sectors, and kernel starts at sector 1 offset = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time. // We'd write more to memory than asked, but it doesn't matter -- // we load in increasing order. while (pa &lt; end_pa) &#123; // Since we haven't enabled paging yet and we're using // an identity segment mapping (see boot.S), we can // use physical addresses directly. This won't be the // case once JOS enables the MMU. readsect((uint8_t*) pa, offset); pa += SECTSIZE; offset++; &#125;&#125; 这个函数有3个参数，第一个是物理地址，第二个是页的大小，第三个是偏移量。函数先计算末尾地址，在根据字节数得出扇区号，最后循环读取扇区内容到内存地址pa处，读完之后，移动内存地址和扇区 Loading the Kernel现在，我们将对boot/main.c中的boot loader的C语言部分详细介绍 ELF头的C定义在inc / elf.h中。我们感兴趣的计划部分是： .text：程序的可执行指令 .rodata：只读数据，例如C编译器生成的ASCII字符串常量（但是，我们不会费心设置硬件来禁止写入。） .data：数据部分保存程序的初始化数据，例如使用初始化器（如int x = 5）声明的全局变量 通过objdump -h obj/kern/kernel，检查内核可执行文件中所有段的名称，大小和链接地址 请特别注意.text部分的VMA（或链接地址）和LMA（或加载地址） 。段的加载地址是应该将该段加载到内存中的内存地址。段的链接地址是段期望执行的内存地址 通常链接和加载地址是相同的。查看boot loader的.text部分：objdump -h obj/boot/boot.out boot loader使用ELF 程序头来决定如何加载节。程序头指定要加载到内存中的ELF对象的哪些部分以及每个应占用的目标地址。您可以通过键入以下内容来检查程序标题objdump -x obj/kern/kernel 程序头在objdump的输出中的Program Headers下列出。需要加载到内存中的ELF对象的区域是标记为LOAD的区域。给出了每个程序头的其他信息，例如虚拟地址vaddr，物理地址paddr和加载区域的大小memsz filesz 回到boot/main.c，ph-&gt;p_pa是每个程序头包含的段目的物理地址 BIOS把引导扇区加载到内存地址0x7c00，这也就是引导扇区的加载地址和链接地址。在boot/Makefrag中，是通过传-Ttext 0x7C00这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址 ELF头中还有一个对我们很重要的字段，名为e_entry，该字段保存程序中入口点的链接地址，也就是程序执行的text字段中的内存地址。objdump -f obj/kern/kernel 现在应该能够理解boot/ main.c中的最小ELF加载器 。它将内核的每个部分从磁盘读入内存的部分加载地址，然后跳转到内核的入口点 Exercise 4阅读Brian Kernighan和Dennis Ritchie编写的《C程序设计语言》（称为“K＆R”）中的5.5和5.1，并理解pointers.c Exercise 5change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. 修改boot/Makefrag，把引导扇区的加载地址和链接地址从0x7c00改为0x8c00 可以发现起始地址从原来的00007c00变为00008c00 由于BIOS载入内核后，是跳转到00007c00，显然这样子就无法加载成功 Exercise 6Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.) 使用GDB的x/Nx ADDR可以打印内存地址ADDR的N个字 这里很明显是因为内核程序被加载到了0x100000地址处，使用x /8i *0x100000可以反汇编查看内存地址对应的指令，如果去查看kernel的目标文件，会发现两者一致 The Kernel我们现在将开始更详细地研究JOS内核（最后你会写一些代码！）。与boot loader一样，内核以一些汇编语言代码开始，这些代码设置正确，以便C语言代码可以正确执行 Using virtual memory to work around position dependenceboot loader的链接地址和加载地址是一样的，然而kernel 的链接地址和加载地址有些差异。查看kern/kernel.ld可以发现链接地址在0xF0100000，加载地址为0x100000 操作系统内核通常喜欢链接并在非常高的虚拟地址（例如0xf0100000）下运行，以便留下处理器虚拟地址空间的下半部分供用户程序使用 许多机器在地址0xf0100000处没有任何物理内存，因此我们无法指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址0xf0100000（内核代码期望运行的链接地址）映射到物理地址0x00100000（boot loader将内核加载到物理内存中）。这样，虽然内核的虚拟地址足够高，可以为用户进程留出足够的地址空间，但它将被加载到PC RAM的1MB点的物理内存中，就在BIOS ROM上方。这种方法要求PC至少有几兆字节的物理内存（因此物理地址0x00100000可以工作） 在下一个实验中，我们将把物理地址0x00000000到0x0fffffff的整个底部256MB的物理地址空间分别映射到虚拟地址0xf0000000到0xffffffff。您现在应该明白为什么JOS只能使用前256MB的物理内存 我们使用kern/entrypgdir.c中手写的、静态初始化的页面目录和页表来完成 映射前4MB的物理内存的操作 如果kern/entry.S中没有设置CR0_PG标志，内存引用被视为物理地址（严格来说，它们是线性地址，但boot/boot.S设置从线性地址到物理地址的身份映射，我们永远不会要改变那个）；如果设置，内存引用就变为虚拟地址，由虚拟内存硬件转换为物理地址的虚拟地址。 entry_pgdir将0xf0000000到0xf0400000范围内的虚拟地址转换为物理地址0x00000000到0x00400000，以及虚拟地址0x00000000到0x00400000到物理地址0x00000000到0x00400000。任何不属于这两个范围之一的虚拟地址都会导致硬件异常，因为我们尚未设置中断处理，将导致QEMU转储机器状态并退出 Exercise 7Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened. What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren&#39;t in place? Comment out the movl %eax, %cr0 in kern/entry.S, trace into it, and see if you were right. 第一部分没能成功，不知道为什么，不管是在movl %eax, %cr0之前还是之后，两个地址的值都是一样的，照理说应该是不一样的。原因就是之前还没有建立分页机制，高地址内核区域还没有映射到内核的物理地址，而只有低地址有效的．开启分页之后，由于有静态映射表的存在(kern/enterpgdir.c)，两块虚拟地址都指向同一块物理地址区域。但是第二阶段却可以完成 在注释掉movl %eax, %cr0，也就是关闭虚拟内存之后，就会出现以下错误，因为物理内存只有0x001002c，无法获取0xf01002c Formatted Printing to the Console大多数人认为像printf()这样的函数是理所当然的，有时甚至认为它们是C语言的“原语”。但在OS内核中，我们必须自己实现所有I/O 通读kern/printf.c lib/printfmt.c kern/console.c，确保了解它们之间的关系。在后面的实验中将清楚为什么printfmt.c位于单独的lib目录中 kern/printf.c 和 lib/printfmt.c 依赖 kern/console.c 现在回答一下问题 Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c? 12345678910111213141516171819202122232425262728static voidputch(int ch, int *cnt)&#123; cputchar(ch); *cnt++;&#125;intvcprintf(const char *fmt, va_list ap)&#123; int cnt = 0; vprintfmt((void*)putch, &amp;cnt, fmt, ap); return cnt;&#125;intcprintf(const char *fmt, ...)&#123; va_list ap; int cnt; va_start(ap, fmt); cnt = vcprintf(fmt, ap); va_end(ap); return cnt;&#125; 上图显示了printf.c实现的接口，下图显示了console.c提供的接口123456789101112131415161718192021222324// `High'-level console I/O. Used by readline and cprintf.voidcputchar(int c)&#123; cons_putc(c);&#125;intgetchar(void)&#123; int c; while ((c = cons_getc()) == 0) /* do nothing */; return c;&#125;intiscons(int fdnum)&#123; // used by readline return 1;&#125; 从中可以看出关键函数是cons_putc()，其功能就是输出字符到控制台，而该函数又是由三个函数组成12345678// output a character to the consolestatic voidcons_putc(int c)&#123; serial_putc(c); lpt_putc(c); cga_putc(c);&#125; 我们一个个来看，先看serial_putc(c)，由名字看是串行输出的意思 1234567891011121314151617#define COM1 0x3F8#define COM_LSR 5 // In: Line Status Register#define COM_LSR_TXRDY 0x20 // Transmit buffer avail#define COM_TX 0 // Out: Transmit buffer (DLAB=0)static voidserial_putc(int c)&#123; int i; for (i = 0; !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; 12800; i++) delay(); outb(COM1 + COM_TX, c);&#125; 它控制的是端口0x3F8，inb读取的是COM1 + COM_LSR = 0x3FD端口，outb输出到COM1 + COM_TX = 0x3F8 !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY)则是判断传输缓存是否avail，outb是将字符c输出到传输缓存COM1 + COM_TX 再来看 lpt_putc()，是并行输出的意思，把字符c传输给并口设备端口123456789101112131415/***** Parallel port output code *****/// For information on PC parallel port programming, see the class References// page.static voidlpt_putc(int c)&#123; int i; for (i = 0; !(inb(0x378+1) &amp; 0x80) &amp;&amp; i &lt; 12800; i++) delay(); outb(0x378+0, c); outb(0x378+2, 0x08|0x04|0x01); outb(0x378+2, 0x08);&#125; 最后是cga_putc(c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static voidcga_putc(int c)&#123; // if no attribute given, then use black on white if (!(c &amp; ~0xFF)) c |= 0x0700; switch (c &amp; 0xff) &#123; case '\b': if (crt_pos &gt; 0) &#123; crt_pos--; crt_buf[crt_pos] = (c &amp; ~0xff) | ' '; &#125; break; case '\n': crt_pos += CRT_COLS; /* fallthru */ case '\r': crt_pos -= (crt_pos % CRT_COLS); break; case '\t': cons_putc(' '); cons_putc(' '); cons_putc(' '); cons_putc(' '); cons_putc(' '); break; default: crt_buf[crt_pos++] = c; /* write the character */ break; &#125; // What is the purpose of this? if (crt_pos &gt;= CRT_SIZE) &#123; int i; memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t)); for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++) crt_buf[i] = 0x0700 | ' '; crt_pos -= CRT_COLS; &#125; /* move that little blinky thing */ outb(addr_6845, 14); outb(addr_6845 + 1, crt_pos &gt;&gt; 8); outb(addr_6845, 15); outb(addr_6845 + 1, crt_pos);&#125; 首先 !(c &amp; ~0xFF) 是否在 0 ~ 255 之前。\b就是退格键，让缓冲区 crt_buf 的下标 crt_pos 减1。其他的同理，case都是格式操作。default就是往缓冲区里写入字符c。之后就是当缓存超过CRT_SIZE，就是用memmove复制内存内容，证明屏幕放不下了，需要页面向上滚动一行。最后四句代码是将缓冲区的内容输出到显示屏 Explain the following from console.c 1234567if (crt_pos &gt;= CRT_SIZE) &#123; int i; memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t)); for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++) crt_buf[i] = 0x0700 | ' '; crt_pos -= CRT_COLS;&#125; 主要是检测当前屏幕的输出buffer是否满了，这里注意memmove是把第二个参数crt_buf + CRT_COLS指向的地址加上(CRT_SIZE - CRT_COLS) * sizeof(uint16_t))后的地址赋值给第一个参数crt_buf 如果buffer满了,把屏幕第一行覆盖掉逐行上移，空出最后一行，并由for循环填充以，最后把crt_pos置于最后一行的行首 For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.Trace the execution of the following code step-by-step.In the call to cprintf(), to what does fmt point? To what does ap point? 12int x = 1, y = 3, z = 4;cprintf("x %d, y %x, z %d\n", x, y, z); fmt指向的就是字符串&quot;x %d, y %x, z %d\n&quot;，ap指向一个参数列表，在这里就是x,y,z List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments. 这里的问题就是c语言中的变长参数的实现，先跳过！！！！ Run the following code.What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here’s an ASCII table that maps bytes to characters.The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value? 将下述代码加入kern/monitor.c，并重新编译运行就能看到结果12unsigned int i = 0x00646c72;cprintf("H%x Wo%s\n", 57616, &amp;i); 我们看到输出了He110 World，原理就是根据ASCII码输出。首先%x是指十六进制，所以将 57616转为十六进制就是e110。这里的%s部分是打印的i地址处的值，由于是little-endian机器，所以i的值在储存的时候是72 6c 64 00.这样对应的ASCII码就是rld。如果是大端机器，不需要改变57616，但是i要变为0x726c6400 In the following code, what is going to be printed after ‘y=’? (note: the answer is not a specific value.) Why does this happen?1cprintf("x=%d y=%d",3); 看到输出为y因为没有被指定值，所以输出的是不确定的 Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments? 这道题目需要明白怎么实现变长数组才能回答！ 123456789101112intcprintf(const char *fmt, ...)&#123; va_list ap; int cnt; va_start(ap, fmt); cnt = vcprintf(fmt, ap); va_end(ap); return cnt;&#125; ...表示参数的数量和类型可能会改变，这个符号只会出现在参数列表的末尾 实现这个的困难在于函数不知道参数的名字，在标准头库&lt;stdarg.h&gt;包含了一系列定义如何遍历参数列表的宏定义 1234567891011121314151617181920212223242526272829#ifndef _STDARG_H#define _STDARG_H typedef char *va_list; /* Amount of space required in an argument list for an arg of type TYPE. TYPE may alternatively be an expression whose type is used. */ #define __va_rounded_size(TYPE) (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int)) #ifndef __sparc__#define va_start(AP, LASTARG) (AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))#else#define va_start(AP, LASTARG) (__builtin_saveregs (), AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))#endif void va_end (va_list); /* Defined in gnulib */#define va_end(AP) #define va_arg(AP, TYPE) (AP += __va_rounded_size (TYPE), *((TYPE *) (AP - __va_rounded_size (TYPE)))) #endif /* _STDARG_H */ va_list轮流指向每个未命名的变量，这个变量暂时就叫ap（argument pointer），宏va_start初始化使得ap指向第一个未命名参数，va_arg(ap, type)返回一个参数并使ap指向下一个，type表明返回类型和移动距离，最后va_end清理内存 变长函数的实现得益于C默认的cdecl调用惯例的自右向左压栈的参数传递方式，因为栈是以从高往低的方向增长的，va_arg每次是以地址往后增长取出下一参数变量的地址 回到这个问题本身，如果GCC按照声明的顺序压入参数，即自左向右， 那么需要修改上面代码中的 va_start 和 va_arg 两个宏,将其改成用减法得到新地址即可 Exercise 8We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form &quot;%o&quot;. Find and fill in this code fragment. 12345678910// (unsigned) octalcase 'o': // Replace this with your code. //putch('X', putdat); //putch('X', putdat); //putch('X', putdat); num = getuint(&amp;ap,lflag); base = 8; goto number; break; 找到lib/printfmt.c并照着之前的画个葫芦就行，修改之后启动界面就能显示十进制数6828对应的八进制数15254 ChallengeEnhance the console to allow text to be printed in different colors. If you&#39;re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer. 对于将VGA切换成图形模式就略过，不是我们的重点 回到cga_putc(c)函数，这里有这样一段注释// if no attribute given, then use black on white，对应代码是12if (!(c &amp; ~0xFF)) c |= 0x0700; 检测c的8bit以上是否为0，如果是，那么黑白显示打印的字符，int c这个变量低8位控制显示的ASCII码。接着8-15bits用来控制颜色输出 因此我们将输出字符修改成1234// charactercase 'c': putch(va_arg(ap, int) + 0x1200, putdat); break; 此时输出的字符X就变成了紫色 The Stack我们将更详细地探讨C语言在x86上使用堆栈的方式，并在此过程中编写一个有用的新内核监视器函数，用于打印堆栈的回溯，即查看指令寄存器（IP）的值的变化 x86堆栈指针（esp寄存器）指向当前正在使用的堆栈上的最低位置。低于这个位置的空间还没使用将值压入堆栈涉及减少堆栈指针，然后将值写入堆栈指针指向的位置。从堆栈中弹出一个值包括读取堆栈指针指向的值，然后增加堆栈指针。在32位模式下，堆栈只能保存32位值，esp总是可以被4整除。各种x86指令（例如调用）被“硬连线”以使用堆栈指针寄存器 Exercise 9Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which &quot;end&quot; of this reserved area is the stack pointer initialized to point to? 在kern/entry.S中找到下面的代码123456789101112131415161718192021222324252627relocated: # Clear the frame pointer register (EBP) # so that once we get into debugging C code, # stack backtraces will be terminated properly. movl $0x0,%ebp # nuke frame pointer # Set the stack pointer movl $(bootstacktop),%esp # now to C code call i386_init # Should never get here, but in case we do, just spin.spin: jmp spin.data#################################################################### boot stack################################################################### .p2align PGSHIFT # force page alignment .globl bootstackbootstack: .space KSTKSIZE .globl bootstacktopbootstacktop: bootstacktop就是栈顶，bootstack应该指的就是栈的位置，大小为KSTKSIZE，且恰好在数据段开头位置对齐之后 Exercise 10To become familiar with the C calling conventions on the x86, find the address of the test_backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words? 这个联系其实不难，因为在CSAPP的拆炸弹实验中都是类似的 Exercise 11Implement the backtrace function(kern/monitor.c/mon_backtrace()) as specified above1234Stack backtrace: ebp f0109e58 eip f0100a62 args 00000001 f0109e80 f0109e98 f0100ed2 00000031 ebp f0109ed8 eip f01000d6 args 00000000 00000000 f0100058 f0109f28 00000061 ... 123456789101112131415161718192021intmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; // Your code here. int j; uint32_t ebp = read_ebp(); uint32_t eip = *((uint32_t *)ebp+1); cprintf("Stack backtrace:\n"); while ((int)ebp != 0) &#123; cprintf(" ebp 0x%08x eip 0x%08x args ", ebp, eip); uint32_t *args = (uint32_t *)ebp + 2; for (j = 0; j &lt; 5; j ++) &#123; cprintf("%08x ", args[j]); &#125; cprintf("\n"); eip = ((uint32_t *)ebp)[1]; ebp = ((uint32_t *)ebp)[0]; &#125; return 0;&#125; 打印的第一行反映当前正在执行的函数，即mon_backtrace本身，第二行反映调用的函数，mon_backtrace第三行反映调用该函数的函数，依此类推 在每一行中，ebp值表示进入该函数使用的堆栈的基指针：即，在输入函数之后堆栈指针的位置和函数序言代码设置基指针。列出的eip值是函数的返回指令指针：当函数返回时控件将返回的指令地址。返回指令指针通常指向调用指令之后的指令（为什么？）。最后，args之后列出的五个十六进制值 是有问题的函数的前五个参数，它们在调用函数之前就被推到了堆栈上？？？ 可以将此新函数挂钩到内核监视器的命令列表中，以便用户可以交互地调用它 Exercise 12Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip 已经提供debuginfo_eip()，其在符号表中查找EIP，并返回该地址的调试信息，就如注释所示，从特定的指令地址中读取信息填充到Stab结构体中，用于调试。该函数在kern/kdebug.c中定义 下面的结构则保存着该函数读取的信息1234567891011// Debug information about a particular instruction pointerstruct Eipdebuginfo &#123; const char *eip_file; // Source code filename for EIP int eip_line; // Source code linenumber for EIP const char *eip_fn_name; // Name of function containing EIP // - Note: not null terminated! int eip_fn_namelen; // Length of function name uintptr_t eip_fn_addr; // Address of start of function int eip_fn_narg; // Number of function arguments&#125;; 在文件kern / kernel.ld中查找__STAB_ *（即Symbol Table） objdump -h obj/kern/kernel objdump -G obj/kern/kernel gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c，看init.s. 查看boot loader是否在内存中加载符号表作为加载内核二进制文件的一部分 回到这道练习题，要我们在Exercise 11基础之上，显示更多调试信息1234567891011121314151617181920212223242526272829303132intmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; // Your code here. int j; uint32_t ebp = read_ebp(); uint32_t eip = *((uint32_t *)ebp+1); struct Eipdebuginfo info; cprintf("Stack backtrace:\n"); while ((int)ebp != 0) &#123; cprintf(" ebp 0x%08x eip 0x%08x args ", ebp, eip); uint32_t *args = (uint32_t *)ebp + 2; for (j = 0; j &lt; 5; j ++) &#123; cprintf("%08x ", args[j]); &#125; cprintf("\n"); memset(&amp;info,0,sizeof(struct Eipdebuginfo)); if(!debuginfo_eip(eip,&amp;info)) cprintf("\t%s:%d:%s+%u\n",info.eip_file,info.eip_line,info.eip_fn_name,eip-info.eip_fn_addr); else cprintf("failed to get debufinfo for eip %x\n",eip); eip = ((uint32_t *)ebp)[1]; ebp = ((uint32_t *)ebp)[0]; &#125; return 0;&#125; 每行给出堆栈帧eip对应文件名和行，后跟函数的名称和eip与函数的第一条指令的偏移量 实模式和保护模式区别及寻址方式我们先来说一下实模式和保护模式的区别。最早期的8086 CPU只有一种工作方式，那就是实模式，而且数据总线为16位，地址总线为20位，实模式下所有寄存器都是16位。而从80286开始就有了保护模式，从80386开始CPU数据总线和地址总线均为32位，而且寄存器都是32位。但80386以及现在的奔腾，酷睿等等CPU为了向前兼容都保留了实模式，现代操作系统在刚加电时首先运行在实模式下，然后再切换到保护模式下运行 相关链接《程序员的自我修养》 实模式寻址方式刚才说了8086 CPU数据总线为16位，也就是一次最多能取$2^{16}=64KB$数据，这个数据也解释了实模式下为什么每个段最大只有64KB。但刚才还说了其地址总线为20位，这样它能寻址的能力其实是$2^{20}=1MB$，这也就是实模式下CPU的最大寻址能力。段寄存器明明就16位，为什么说它有有$2^{20}=1MB$的寻址能力呢？ 因为芯片设计者想出了一种段地址+偏移地址的寻址方式（通常写作段地址：偏移地址）。8086内置4个段寄存器（如下文提到的%ds %es ss），每个段寄存器可以存放一个16位的段地址，在寻址时，处理器首先将段地址左移4位，然后再加上偏移地址，由此得到20位的物理地址（如 1234H:5678H所对应的物理地址为12340H+5678H=179B8H，其中， 1234H:5678H称作逻辑地址或虚地址）。当地址有溢出时（FFFFH:FFFFH 对应的物理地址是FFFF0H+FFFFH=10FFEFH，大于FFFFFH），会发生回卷（10FFEFH = FFF0H） 如此寻址会产生很多问题。一个段大小最大为$2^16=64KB$，并且，所有的段都是可读写的。这意味着不同的段存在着重叠部分（即不同的逻辑地址可以映射到相同的物理地址），无法保证程序的安全性（程序段可被修改），也不具有权限分级 保护模式寻址方式在定义“逻辑地址”时看到保护模式和实模式的区别在于它是用段选择符而非段基地址，这也许就是保护模式的真谛所在 在保护模式中，处理器将段信息存放于描述符表中。一张描述符表有$2^{13}$个条目（描述符），每条目8字节长，其中包括24位长的段起始物理地址、16位长的段长（因此段的长度范围从1 B到216 B，即不超过64 KiB），其余为属性信息。每一段的地址范围为 段首～段首+段长，每一个段的大小不一定相同（由段长确定）。描述符表有两个，一个是全局描述符表（GDT），一个是局部描述符表（LDT），也就是说，总共可以有$2 * 2^{13}$个段 保护模式下，段寄存器保存的内容称作选择器（selector），其本质是索引（13位，即在表中的偏移量）、TI位（1位，表示是使用GDT还是LDT）和优先级信息（2位，0-3值越小优先级越高） 在寻址时，首先拿出选择器（段寄存器）的高13位作为偏移量（索引），结合TI位找到描述符。取出其中24位长的段首地址信息，再加上偏移量（这个偏移量是段地址:偏移量 中的偏移量，前面提到的描述符表的偏移量是段地址的高13位），得到实际物理地址 分页机制它把物理内存分成相同固定大小$2^{12}=4KB$的页面。在分页寻址模式中，CPU维护一张页目录（page directory）与多张页表（page table），其中，页目首地址由CR3寄存器给出，而页表的首地址存放在页目中。页目与页表中的条目每条均为4字节，而每个页目页表最多能容纳1024个条目（即每张页目页表最大空间占用4KB，4096位）。页目与页表存放信息的方式相似，在每条目的32位中，最高20位（31-12）存放地址信息，剩余12位存放属性信息 从一个逻辑地址经过分段和分页寻址物理地址的整个过程就如下图所示。总的来说整个过就是逻辑地址经分段机制变成线性地址，如果不启用分页的情况下，此线性地址就是物理地址;如果启用分页，那么线性地址经分页机制变成物理地址 一个多段模型充分发挥了段机制对代码，数据结构和程序提供硬件保护的能力。每个程序都有自己的段描述符表和自己的段。段可以完全属于程序私有也可以和其它程序之间共享 访问权限的检查不仅仅用来保护地址越界，也可以保护某一特定段不允许操作。例如代码段是只读段，硬件可以阻击向代码段进行写操作 做了快一个星期，真的有点难度的哦！！]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《多机数据库的实现》]]></title>
    <url>%2F2019%2F03%2F14%2FRedis%EF%BC%9A%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[分布式开始啦！ 复制通过执行SLAVEOF命令可以让一个服务器去复制另一个服务器，进行复制的主从服务器将保存相同的数据 通过同步和命名传播两个操作实现复制。首先，从服务器发送SYNC命令，主服务器接受后将会执行BGSAVE，生成RDB文件，并返回。在生成RDB期间，主服务器将执行的写命令写入缓冲区，并发送给从服务器 当完成上述同步命令后，主从数据库的一致性只是暂时的。主服务器需要通过命令传播实时将写命令发送给从服务器 上面试旧版的复制策略，这种方式的缺点在于从服务器每次执行SYNC命令时，都会得到一个RDB文件，这对于主从服务器都是一种浪费，因为主从服务器可能只是相差几个写命令，例如从服务器突然掉线几秒钟，为了同步这几秒期间的数据，要同步整个RDB，显然不值得 新版的复制功能使用PSYNC命令， 该命令具有完整重同步和部分重同步（Partial），就是为了解决上面断线后同步时的低效情况 部分重同步SentinelSentinel是Redis高可用的解决方案 由一个或多个Sentinel instance组成的Sentinel System可以监视任意多个主从服务器，当被监视的主服务器进入下线状态时，Sentinel System会自动将下线的主服务器下属的某个从服务器升级为主服务器，代替原来的主服务器继续执行命令 集群集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Appendix A]]></title>
    <url>%2F2019%2F03%2F14%2FMIT-6-828-book-xv6-Appendix-A%2F</url>
    <content type="text"><![CDATA[xv6:附录 A MIT 6.828 Operating System Engineering PC硬件本目录介绍xv6的运行平台，PC硬件。 PC是一种符合多个行业标准的计算机，其目标是给定的软件可以在多个供应商销售的PC上运行。这些标准随着时间的推移而演变，从上世纪九十年代开始的PC现在看起来并不像个人电脑 从外部看，PC是一个带有键盘、屏幕和各种设备（CD-rom等）的盒子。盒子里有一个电路板（主板），带有CPU、内存、显卡、I/O控制芯片和总线，芯片通过这些电路板进行通信。总线遵循标准协议（如PCI和USB），以便设备与各个供应商的PC一起协作 从我们的角度看，我们可以将PC抽象为三个组件：CPU、内存和I/O设备。CPU执行计算，内存包含该计算所需的指令和数据，设备允许CPU与硬件相互交互以进行存储、通信和其他功能 您可以将主存视为连接到CPU的一组电线或线路，一些用于地址位，一些用于数据位，一些用于控制标志。要从主存中读取值，CPU在规定的时间内发送高或低电压，在地址线上表示1或 0位，在“读取”行上发送1，然后通过解释数据线上的电压来读回该值。要将值写入主内存，CPU将在地址和数据行上发送适当的位，并在规定的时间内在“写入”行上发送1。真正的内存接口比这更复杂，但只有在需要实现高性能的情况下，这些细节才很重要 处理器与内存计算机的CPU（中央处理单元或处理器）运行一个概念上的简单循环：它从一个叫做程序计数器的寄存器中查询一个地址，从内存中的该地址读取计算机指令，通过该指令改变程序计数器，并执行指令，然后重复该循环。如果指令的执行没有改变程序计数器，此循环将把程序计数器指向的内存解释为一个接一个运行的机器指令序列。更改程序计数器的指令包括分支和函数调用？？？ 如果没有存储和修改程序数据的能力，执行引擎是没有用的。处理器的寄存器集提供了最快的数据存储。寄存器是处理器内部的存储单元。能够容纳计算机以字为单位的值（通常为16、32或64位）。存储在寄存器中的数据通常可以在单个CPU周期中快速读取或写入 PC都有一个实现了x86指令集的处理器，这最早由Intel定义，现在已经成为了一个标准。一些制造商就根据该标准去生产相应的处理器。就像其他PC标准，该标准也在不断发展，而且新的标准会兼容旧的标准。引导装载程序（The boot loader）不得不去处理其中的变化，因为每个PC处理器在开机时均模拟成因特尔的8088，这个CPU芯片最早是IBM在1981年发布的。然而，在xv6中，大部分情况是你仅需要关心现代x86指令集 现代x86指令集提供8个通用32位寄存器%eax %ebx %ecx %edx %edi %esi %ebp %esp和一个程序计数器%eip（指令指针）。前缀e表示extended（扩展），因为它们是16位寄存器%ax %bx %cx %dx %di %si %bp %sp %ip的32位扩展。这两个寄存器集互为别名（are aliased），因此,像%ax是%eax的下半部分，写入% ax会更改存储在%eax中的值，反之亦然。前四个寄存器的低字节部分的两个8位字节还有别名：%al %ah分别代表%ax的高和低8位；%bl %b %cl %ch %dl和%dh也是同样模式。除了这些寄存器，x86还有8个80位浮点寄存器和少量特殊用途的寄存器，如控制寄存器： %cr0 %cr2 %cr3 %cr4；调试寄存器：%dr0 %dr1 %dr2 %dr3；段寄存器：%cs %ds %es %fs %gs %ss；全局和本地描述符表伪寄存器%gdtr和%ldtr。控制寄存器和段寄存器对任何操作系统都非常重要。浮点寄存器和调试寄存器在xv6中，则没有得到关心和使用 寄存器速度快但是价格昂贵。大多数处理器最多提供几十个通用寄存器。存储的下一个层次就是随机存取内存（RAM）。主存一般比寄存器慢10-100倍，但要便宜得多，因此内存会更大。内存相对较慢的一个原因是它在物理上和处理器芯片分离。x86处理器有几十个寄存器，但如今典型的PC却有千兆字节的内存。由于寄存器和主内存之间在访问速度和大小方面的巨大差异, 大多数处理器 （包括x86）都会将最近访问的主内存部分的副本存储在高速缓存内存中（Cache）。高速缓存在访问时间和大小上都充当寄存器和内存之间的中间地带。如今的x86处理器通常都有二级缓存，较小的一级缓存，其访问速度相对接近处理器的时钟频率，较大的第二级缓存的访问时间在第一级缓存和主存之间。下表显示了Intel Core 2 Duo芯片的真实数据： 大多数情况下，x86处理器对操作系统隐藏了缓存（Cache），因此我们可以将处理器视为只有两种存储类型：寄存器和主存，不用关心不同内存层级的不同级别之间的区别 I/O处理器需要与设备和内存通信。x86处理器提供特殊的读取和写入指令，用于从称为I/O 端口的设备地址读取值。这些指令的硬件实现与读取和写入内存基本相同。早期x86处理器有一个额外的地址行：0表示从I/O端口读写，1表示从主内存读写。每个硬件设备监视这些地址行，以获取分配的读写I/O端口的范围。设备的端口允许软件配置设备，检查状态，并导致设备执行操作。例如，软件使用I/O端口去读写来控制磁盘接口硬件去读写磁盘扇区 很多计算机体系结构没有单独的设备访问指令。相反，这些设备有固定的内存地址，处理器通过读写这些地址的值和设备通信（在操作系统的命令下）。事实上，现代x86结构在大多数高速设备（如网络、磁盘和图形控制器）中使用了这种称为内存映射 I/O（memory-mapped I/O）的技术。不过，处于向后兼容的原因，旧的in和out指令保留下来，对legacy硬件设备使用它们，比如xv6中使用的IDE磁盘控制器]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表]]></title>
    <url>%2F2019%2F03%2F13%2FMySQL-%E3%80%8A%E8%A1%A8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[表是关于特定实体的数据集合，这也是关系型数据库模型的核心。本章介绍InnoDB的逻辑存储及其实现分析数据在表中如何组织和存放 索引组织表表都是根据主键顺序组织存放的，如果创建表时没有显示定义主键，InnoDB会按照下面方式选择或者创建主键。首先判断表中是否有非空的唯一索引（UNIQUE NOT NULL），如果有则为主键，如果没有InnoDB会创建一个6字节的指针 如果有多个非空唯一索引，InnoDB选择建表时第一个定义的非空唯一索引作为主键，而不是按照列的顺序 1mysql&gt; SELECT *,_rowid from test; _rowid可以显示表的主键，但是该值只能用于查看单个列作为主键的情况，对于多列组成的主键就无能为力 逻辑存储结构 表空间表空间看作是存储引擎逻辑结构的最高层，所有数据都放在表空间中 即使如上一章所述，启用innodb_file_per_table，每章单独的表也只保存数据、索引和插入Bitmap页，其他数据，如回滚（undo）信息、插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在共享表空间中。这也意味着即使表单独放在一个表中，共享表依旧会增加大小 段表空间由各个段组成，常见的段有数据段、索引段、回滚段。因为InnoDB的表是索引组织的，因此数据即索引，索引即数据。因此数据段即为B+树的叶子节点（Leaf node segment），索引段即为B+树的非索引节点（Non-leaf node segment） 区区（Extent）是连续页组成的空间，区的大小都为1MB。为了保证连续性，InnoDB存储引擎一次想磁盘申请4-5个区默认情况下，InnoDB的页大小都为16KB，因此一个区一共有64个连续的页。当然可以通过参数设置页的大小，如innodb_page_size，但是区的大小固定不变 页？？？页是InnoDB磁盘管理的最小单位，每个页默认为16KB。常见页的类型如数据页、undo页、系统页、事务数据页等 行？？？数据是按照行进行存放的，每个页存放的行记录都是有硬性定义的，最多存放16KB/2-100行，即7992记录 行记录格式CompactMySQL默认的格式是Compact，只要知道页中行记录的组织规则，也能自己编写工具读取记录 Compact行记录格式的首部是一个非NULL变长字段长度列表（变长字段如varchar，定长数据类型利用空格来填充字段里的空白，但如果某个变长字段的长度定义为10，而输入的字符串长度为5，那么这个值的总长度也就是5），并且按照列的顺序逆序放置 第二个部分是NULL标志位，指示该行数据是否有NULL值 第三个部分共40位，记录如下一条记录的相对位置、记录类型、是否删除等等信息 第四部分就是实际存储每个列的数据，NULL不占用该部分任何空间，只占有NULL标记位 另外还有两个隐藏列，事务ID列和回滚指针列，如果没有指定主键，还有rowid列 创建一个测试表 并使用命令hexdump -C -v mytest.ibd &gt; mytest.txt就能查看表的信息 从地址0xc078开始就是记录数据库信息，即下面的数字03 02 01 00 00 00 10 00 2c 00 00 00 00 04 00 00 00 00 00 13 08 a8 00 00 01 1c 01 10 61 62 62 62 62 20 20 20 20 20 20 20 20 63 63 63 03 02 01：变长字段长度列表，逆序 00：NULL标志，第一行没有NULL，因此为0，而对于有NULL的第三行，此值就为06，转换成二进制就是00000110，即表示第2、3列有NULL值 00 00 10 00 2c：记录头信息，固定为5字节，最后两个字节2c表示下一条记录的偏移量，因此在页内部是通过链表来串联各个行记录的 00 00 00 00 04 00：RowID 00 00 00 00 13 08：TransactionID a8 00 00 01 1c 01 10：Roll Pointer 61 62 62：对应前两列的数据a bb 62 62 20 20 20 20 20 20 20 20：由于第三列数据定义为定长，因此需要填充 63 63 63：对应数据ccc Redundant结构大同小异，不做分析 行溢出？？？一般情况下，InnoDB的数据都是放在页种类为B-tree Node中，当发送行溢出时，数据存放在类型为UNcompress BLOG页中 = 数据页结构？？？约束为了保证数据的完整性，InnoDB通常提供以下几种约束方式 Primary Key Unique Key Foreign Key Default NOT NULL 约束更像是逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，具有逻辑上的概念，在数据库上还代表物理存储的方式 通过触发器也可以实现对数据的完整性。还可以实现对传统CHECK约束的支持、物化视图、高级复制、审计等高级特性 视图View是一个命名的虚表，由一个SQL查询来定义，但其中没有实际的物理存储 视图的主要用途之一是被用作一个抽象装置，对于一些应用程序，程序不关心基表的结构，只要按照视图定义来获取更新数据，View在一定程序起到了保护层的作用 物化视图的数据存储在非易失的存储设备上，可以保存复杂查询的结果，从而直接查出结果 MySQL本身不支持物化视图，但可以通过一定机制实现物化视图的功能。即通过触发器来实现当表变化时，就更新物化视图的基表来实现 分区表分区的过程是将一个表或索引分解为更小、更可管理的部分。在物理上这个表或索引可能由数十个物理分区组成。每个分区可以独立处理，也可以作为更大对象的一部分处理 MySQL仅支持水平分区（即将同一个表不同行的记录分配到不同的物理文件中）。同时还是局部分区索引，一个分区既存放数据也存放索引，而全局分区则是索引放在一个对象，数据存放在各个分区中 MySQL支持以下类型的分区 RANGE：行数据基于一个给定连续区间的列值被放入分区 LIST：和RANGE类似，但是LIST分区面向的是离散的值 HASH：根据用户自定义的表达式的返回值来分区 KEY：根据MySQL提供的哈希函数来进行分区 RANGE1234567mysql&gt; create table t( -&gt; id int -&gt; )engine=innodb -&gt; partition by range(id)( -&gt; partition p0 values less than (10), -&gt; partition p1 values less than (20));Query OK, 0 rows affected (0.01 sec) 查看表在磁盘上的物理文件，启动分区之后，就不止一个idb文件，如下所示 之后插入的数据就会根据id值，分配到不同的分区，如果插入不在定义范围的值，就会抛出异常 RANGE分区主要用于日期列的分区，根据年份来保存记录，这样查询特定年份的数据，就只需要查询特定分区，而不会搜索所有分区，这叫做Partition Pruning（分区修剪） LIST1234567mysql&gt; create table t( -&gt; a int, -&gt; b int)engine=innodb -&gt; partition by list(b)( -&gt; partition p0 values in (1,3,5), -&gt; partition p1 values in (0,2,4));Query OK, 0 rows affected (0.01 sec) 同样插入未定义的值，也会抛出异常 HASH在HASH分区中，只要指定列值或表达式，以及要分割的分区数量即可 123456mysql&gt; create table t_hash( -&gt; a int, -&gt; b datetime)engine=innodb -&gt; partition by hash(year(b)) -&gt; partitions 4;Query OK, 0 rows affected (0.02 sec) 该hash函数其实就是对分区数量取余，例如表达式year(b)表示取出b的年份，如果b为2010-4-10，则hash函数得到的值就是2010%4 = 2，也就是说这条数据会被放到分区2 MySQL还提供另一种hash函数linear hash，对于增加删除合并拆分更加快捷，有利于处理含有大量数据的表，缺点是分布可能不太均衡 KEY和HASH类似，不同之处在于KEY分区使用MySQL数据库提供的函数进行分区，而HASH分区使用用户定义的函数进行分区 COLUMNS上述分区的数据都必须是整型，所以对于DATATIME，需要通过year()函数转化成整型，而COLUMNS分区可以直接使用非整型数据进行分区，而且支持对多个列的值进行分区 12345678910mysql&gt; create table rxv( -&gt; a int, -&gt; b int, -&gt; c char(5), -&gt; d int)engine=innodb -&gt; partition by range columns(a,d,c)( -&gt; partition p0 values less than (5,10,&apos;hhh&apos;), -&gt; partition p2 values less than (10,20,&apos;dasdf&apos;), -&gt; partition p3 values less than (maxvalue,maxvalue,maxvalue));Query OK, 0 rows affected (0.01 sec) 子分区MySQL允许在RANGE和LIST分区上再进行HASH和KEY的子分区 123456789101112mysql&gt; create table ts( -&gt; a int, -&gt; b date) -&gt; partition by range(year(b)) -&gt; subpartition by hash(to_days(b)) ( -&gt; partition p0 values less than (1990)( -&gt; subpartition s0, -&gt; subpartition s1), -&gt; partition p1 values less than (2000)( -&gt; subpartition s2, -&gt; subpartition s3));Query OK, 0 rows affected (0.04 sec) 对于RANGE分区，如果向分区列插入NULL值，MySQL会选择将其放在最左边的分区；对于LIST分区，要使用NULL值，必须显式指定放在哪个分区；对于HASH和KEY分区，hash函数将NULL值的记录看做是0，在选择分区 分区性能并不是将数据分区，就能提供查询效率 对于需要频繁扫描一张很大的表的数据库，如上亿行数据，用户如果要查询某一年的数据，那按照时间戳分区，将会提高效率 此处涉及B+树，暂时略过 交换分区MySQL还支持分区或子分区的数据与另一个非分区的表中的数据进行交换123456789101112131415161718192021mysql&gt; create table t1( -&gt; a int, -&gt; b char(10)) -&gt; partition by range(a)( -&gt; partition p0 values less than (10), -&gt; partition p1 values less than (20));Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into t1 values (4,&quot;dasda&quot;), (11,&quot;dasda&quot;);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from t1;+------+-------+| a | b |+------+-------+| 4 | dasda || 11 | dasda |+------+-------+2 rows in set (0.00 sec) 我们先创建一个表，并有两个分区，每个分区一条记录，之后我们创建一个相同表结构的表t21234mysql&gt; create table t2( -&gt; a int, -&gt; b char(10));Query OK, 0 rows affected (0.01 sec) 我们将分区p0的数据转移到t2表123456789101112131415161718mysql&gt; alter table t1 exchange partition p0 with table t2;Query OK, 0 rows affected (0.02 sec)mysql&gt; select * from t1;+------+-------+| a | b |+------+-------+| 11 | dasda |+------+-------+1 row in set (0.00 sec)mysql&gt; select * from t2;+------+-------+| a | b |+------+-------+| 4 | dasda |+------+-------+1 row in set (0.00 sec) 要交换的表和分区表需要有相同的表结构，并且不能含有分区]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习笔记]]></title>
    <url>%2F2019%2F03%2F09%2FServlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习Javaweb真的阐述了基础不牢，地动山摇，太吃力了，啥都不知道，就上框架，因此回炉重修 简介用户使用浏览器访问网页就是发送HTTP请求，web服务器响应请求的过程。所以解析HTTP的工作就交给web服务器了。web服务器有很多，Tomcat是一款小巧灵活并使用最多的Web应用服务器 因此像网络协议、HTTP，servlet根本不管！也管不着！那servlet是干嘛的？很简单，接口的作用是什么？规范呗！servlet接口定义的是一套处理网络请求的规范，所有实现servlet的类，都需要实现它那五个方法，其中最主要的是两个生命周期方法init()和destroy()，还有一个处理请求的service()，也就是说，所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题： 你初始化时要做什么 你销毁时要做什么 你接受到请求时要做什么 servlet是一个规范，那实现了servlet的类，就能处理请求了吗？servlet不会直接和客户端打交道！那请求怎么来到servlet呢？ 答案是servlet容器。Servlet与Servlet容器的关系有点像枪和子弹的关系。从技术角度来说是为了解耦，通过标准化接口来相互协作。Servlet容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展 但最常用还是Tomcat。Tomcat才是与客户端直接打交道的家伙，他监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端 Java Servlet通常情况下与使用CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于CGI，Servlet有以下几点优势： 性能明显更好 Servlet在Web服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求 Servlet是独立于平台的，因为它们是用Java编写的 服务器上的Java安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet是可信的 Java类库的全部功能对Servlet来说都是可用的。它可以通过sockets和RMI机制与applets、数据库或其他软件进行交互 Servlet执行以下主要任务： 读取客户端（浏览器）发送的显式的数据。这包括网页上的HTML表单，或者也可以是来自applet或自定义的HTTP客户端程序的表单 读取客户端（浏览器）发送的隐式的HTTP请求数据。这包括cookies、媒体类型和浏览器能理解的压缩格式等等 处理数据并生成结果。这个过程可能需要访问数据库，执行RMI或CORBA调用，调用Web服务，或者直接计算得出对应的响应 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML或XML）、二进制文件（GIF图像）、Excel等 发送隐式的HTTP响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置cookies和缓存参数，以及其他类似的任务 生命周期Servlet生命周期可被定义为从创建直到毁灭的整个过程。以下是Servlet遵循的过程： Servlet通过调用init()方法进行初始化 Servlet 调用service()方法来处理客户端的请求 Servlet 通过调用destroy()方法终止（结束） 最后，Servlet是由JVM的垃圾回收器进行垃圾回收的 init()init方法被设计成只调用一次。它在第一次创建Servlet时被调用，在后续每次用户请求时不再调用 Servlet创建于用户第一次调用对应于该Servlet的URL时，但是您也可以指定Servlet在服务器第一次启动时被加载 当用户调用一个Servlet时，就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程，适当的时候移交给doGet或doPost方法。init() 方法简单地创建或加载一些数据，这些数据将被用于Servlet的整个生命周期 service()service()方法是执行实际任务的主要方法。Servlet容器（即Web服务器）调用service()方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端 每次服务器接收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。service() 方法检查HTTP请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用doGet、doPost、doPut、doDelete等方法 service()方法由容器调用，service方法在适当的时候调用 doGet、doPost、doPut、doDelete等方法。所以，您不用对service()方法做任何动作，您只需要根据来自客户端的请求类型来重写doGet()或doPost()即可 doGet()：GET请求来自于一个URL的正常请求，或者来自于一个未指定METHOD的HTML表单，它由doGet()方法处理 doPost()：POST请求来自于一个特别指定了METHOD为POST的HTML表单，它由doPost()方法处理 destroy()destroy()方法只会被调用一次，在Servlet生命周期结束时被调用。destroy()方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把Cookie列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用destroy()方法之后，servlet对象被标记为垃圾回收 表单数据浏览器使用两种方法可将这些信息传递到Web服务器，分别为GET方法和POST方法 Servlet处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析： getParameter()：您可以调用request.getParameter()方法来获取表单参数的值。 getParameterValues()：如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框 getParameterNames()：如果您想要得到当前请求中的所有参数的完整列表，则调用该方法 表单&lt;form&gt;标签是HTML的原生标签，主要用来向服务器传输数据，一个form表单如下：1&lt;form action=&quot;url&quot; method=&quot;GET&quot;&gt;&lt;/form&gt; 其中action代表该表单数据要提交到的服务器地址，method表示提交方式，一般有 GET、POST。&lt;form&gt;只是包裹输入数据的标签而已，要有输入框才能提交，所以这时候需要有input GETGET方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用?字符分隔 GET方法是默认的从浏览器向Web服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用GET方法。GET方法有大小限制：请求字符串中最多只能有1024个字符 这些信息使用QUERY_STRING头传递，并可以通过QUERY_STRING环境变量访问，Servlet使用 doGet()方法处理这种类型的请求 POST另一个向后台程序传递信息的比较可靠的方法是POST方法。POST方法打包信息的方式与GET方法基本相同，但是POST方法不是把信息作为URL中?字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet使用doPost()方法处理这种类型的请求 客户端HTTP请求当浏览器请求网页时，它会向Web服务器发送特定信息，这些信息不能被直接读取，因为这些信息是作为HTTP请求的头的一部分进行传输的 HTTP头信息 头信息 描述 Accept 这个头信息指定浏览器或其他客户端可以处理的 MIME 类型。值 image/png 或 image/jpeg 是最常见的两种可能值 Accept-Charset 这个头信息指定浏览器可以用来显示信息的字符集。例如 ISO-8859-1。 Accept-Encoding 这个头信息指定浏览器知道如何处理的编码类型。值 gzip 或 compress 是最常见的两种可能值。 Accept-Language 这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果。例如，en、en-us、ru 等。 Authorization 这个头信息用于客户端在访问受密码保护的网页时识别自己的身份。 Connection 这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件。值 Keep-Alive 意味着使用了持续连接。 Content-Length 这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。 Cookie 这个头信息把之前发送到浏览器的 cookies 返回到服务器。 Host 这个头信息指定原始的 URL 中的主机和端口。 If-Modified-Since 这个头信息表示只有当页面在指定的日期后已更改时，客户端想要的页面。如果没有新的结果可以使用，服务器会发送一个 304 代码，表示 Not Modified 头信息。 If-Unmodified-Since 这个头信息是 If-Modified-Since 的对立面，它指定只有当文档早于指定日期时，操作才会成功。 Referer 这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。 User-Agent 这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。 读取头信息这些方法通过HttpServletRequest对象获得 方法 描述 Cookie[] getCookies() 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。 Enumeration getAttributeNames() 返回一个枚举，包含提供给该请求可用的属性名称。 Enumeration getHeaderNames() 返回一个枚举，包含在该请求中包含的所有的头名。 Enumeration getParameterNames() 返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。 HttpSession getSession() 返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。 HttpSession getSession(boolean create) 返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。 Locale getLocale() 基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。 Object getAttribute(String name) 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。 ServletInputStream getInputStream() 使用 ServletInputStream，以二进制数据形式检索请求的主体。 String getAuthType() 返回用于保护 Servlet 的身份验证方案的名称，例如，”BASIC” 或 “SSL”，如果JSP没有受到保护则返回 null。 String getCharacterEncoding() 返回请求主体中使用的字符编码的名称。 String getContentType() 返回请求主体的 MIME 类型，如果不知道类型则返回 null。 String getContextPath() 返回指示请求上下文的请求 URI 部分。 String getHeader(String name) 以字符串形式返回指定的请求头的值。 String getMethod() 返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。 String getParameter(String name) 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。 String getPathInfo() 当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。 String getProtocol() 返回请求协议的名称和版本。 String getQueryString() 返回包含在路径后的请求 URL 中的查询字符串。 String getRemoteAddr() 返回发送请求的客户端的互联网协议（IP）地址。 String getRemoteHost() 返回发送请求的客户端的完全限定名称。 String getRemoteUser() 如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。 String getRequestURI() 从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。 String getRequestedSessionId() 返回由客户端指定的 session 会话 ID。 String getServletPath() 返回调用 JSP 的请求的 URL 的一部分。 String[] getParameterValues(String name) 返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。 boolean isSecure() 返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。 int getContentLength() 以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。 int getIntHeader(String name) 返回指定的请求头的值为一个 int 值。 int getServerPort() 返回接收到这个请求的端口号。 int getParameterMap() 将参数封装成 Map 类型。 服务器HTTP响应当一个Web服务器响应一个HTTP请求时，响应通常包括一个状态行、一些响应报头、一个空行和文档 响应报头 头信息 描述 Allow 这个头信息指定服务器支持的请求方法（GET、POST 等）。 Cache-Control 这个头信息指定响应文档在何种情况下可以安全地缓存。可能的值有：public、private 或 no-cache 等。Public 意味着文档是可缓存，Private 意味着文档是单个用户私用文档，且只能存储在私有（非共享）缓存中，no-cache 意味着文档不应被缓存。 Connection 这个头信息指示浏览器是否使用持久 HTTP 连接。值 close 指示浏览器不使用持久 HTTP 连接，值 keep-alive 意味着使用持久连接。 Content-Disposition 这个头信息可以让您请求浏览器要求用户以给定名称的文件把响应保存到磁盘。 Content-Encoding 在传输过程中，这个头信息指定页面的编码方式。 Content-Language 这个头信息表示文档编写所使用的语言。例如，en、en-us、ru 等。 Content-Length 这个头信息指示响应中的字节数。只有当浏览器使用持久（keep-alive）HTTP 连接时才需要这些信息。 Content-Type 这个头信息提供了响应文档的 MIME（Multipurpose Internet Mail Extension）类型。 Expires 这个头信息指定内容过期的时间，在这之后内容不再被缓存。 Last-Modified 这个头信息指示文档的最后修改时间。然后，客户端可以缓存文件，并在以后的请求中通过 If-Modified-Since 请求头信息提供一个日期。 Location 这个头信息应被包含在所有的带有状态码的响应中。在 300s 内，这会通知浏览器文档的地址。浏览器会自动重新连接到这个位置，并获取新的文档。 Refresh 这个头信息指定浏览器应该如何尽快请求更新的页面。您可以指定页面刷新的秒数。 Retry-After 这个头信息可以与 503（Service Unavailable 服务不可用）响应配合使用，这会告诉客户端多久就可以重复它的请求。 Set-Cookie 这个头信息指定一个与页面关联的cookie。 设置响应报头下面的方法可用于在Servlet程序中设置HTTP响应报头。这些方法通过 HttpServletResponse对象可用 方法 描述 String encodeRedirectURL(String url) 为sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。 String encodeURL(String url) 对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。 boolean containsHeader(String name) 返回一个布尔值，指示是否已经设置已命名的响应报头。 boolean isCommitted() 返回一个布尔值，指示响应是否已经提交。 void addCookie(Cookie cookie) 把指定的 cookie 添加到响应。 void addDateHeader(String name, long date) 添加一个带有给定的名称和日期值的响应报头。 void addHeader(String name, String value) 添加一个带有给定的名称和值的响应报头。 void addIntHeader(String name, int value) 添加一个带有给定的名称和整数值的响应报头。 void flushBuffer() 强制任何在缓冲区中的内容被写入到客户端。 void reset() 清除缓冲区中存在的任何数据，包括状态码和头。 void resetBuffer() 清除响应中基础缓冲区的内容，不清除状态码和头。 void sendError(int sc) 使用指定的状态码发送错误响应到客户端，并清除缓冲区。 void sendError(int sc, String msg) 使用指定的状态发送错误响应到客户端。 void sendRedirect(String location) 使用指定的重定向位置 URL 发送临时重定向响应到客户端。 void setBufferSize(int size) 为响应主体设置首选的缓冲区大小。 void setCharacterEncoding(String charset) 设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。 void setContentLength(int len) 设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。 void setContentType(String type) 如果响应还未被提交，设置被发送到客户端的响应的内容类型。 void setDateHeader(String name, long date) 设置一个带有给定的名称和日期值的响应报头。 void setHeader(String name, String value) 设置一个带有给定的名称和值的响应报头。 void setIntHeader(String name, int value) 设置一个带有给定的名称和整数值的响应报头。 void setLocale(Locale loc) 如果响应还未被提交，设置响应的区域。 void setStatus(int sc) 为该响应设置状态码。 HTTP状态码状态码含义 代码 消息 描述 100 Continue 只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。 101 Switching Protocols 服务器切换协议。 200 OK 请求成功。 201 Created 该请求是完整的，并创建一个新的资源。 202 Accepted 该请求被接受处理，但是该处理是不完整的。 203 Non-authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。 301 Moved Permanently 所请求的页面已经转移到一个新的 URL。 302 Found 所请求的页面已经临时转移到一个新的 URL。 303 See Other 所请求的页面可以在另一个不同的 URL 下被找到。 304 Not Modified 305 Use Proxy 306 Unused 在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。 307 Temporary Redirect 所请求的页面已经临时转移到一个新的 URL。 400 Bad Request 服务器不理解请求。 401 Unauthorized 所请求的页面需要用户名和密码。 402 Payment Required 您还不能使用该代码。 403 Forbidden 禁止访问所请求的页面。 404 Not Found 服务器无法找到所请求的页面。. 405 Method Not Allowed 在请求中指定的方法是不允许的。 406 Not Acceptable 服务器只生成一个不被客户端接受的响应。 407 Proxy Authentication Required 在请求送达之前，您必须使用代理服务器的验证。 408 Request Timeout 请求需要的时间比服务器能够等待的时间长，超时。 409 Conflict 请求因为冲突无法完成。 410 Gone 所请求的页面不再可用。 411 Length Required “Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。 412 Precondition Failed 请求中给出的先决条件被服务器评估为 false。 413 Request Entity Too Large 服务器不接受该请求，因为请求实体过大。 414 Request-url Too Long 服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。 415 Unsupported Media Type 服务器不接受该请求，因为媒体类型不被支持。 417 Expectation Failed 500 Internal Server Error 未完成的请求。服务器遇到了一个意外的情况。 501 Not Implemented 未完成的请求。服务器不支持所需的功能。 502 Bad Gateway 未完成的请求。服务器从上游服务器收到无效响应。 503 Service Unavailable 未完成的请求。服务器暂时超载或死机。 504 Gateway Timeout 网关超时。 505 HTTP Version Not Supported 服务器不支持”HTTP协议”版本。 设置状态码下面的方法可用于在Servlet程序中设置HTTP状态码。这些方法通过HttpServletResponse 对象获取 public void setStatus (int statusCode)：该方法设置一个任意的状态码。setStatus方法接受一个 int（状态码）作为参数。如果您的响应包含了一个特殊的状态码和文档，请确保在使用 PrintWriter 实际返回任何内容之前调用setStatus public void sendRedirect(String url)：该方法生成一个 302 响应，连同一个带有新文档 URL 的 Location 头。 public void sendError(int code, String message)：该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。 过滤器Servlet过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息 Servlet过滤器是可用于Servlet编程的Java类，可以实现以下目的： 在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 过滤器通过Web部署描述符（web.xml）中的XML 标签来声明，然后映射到您的应用程序的部署描述符中的Servlet名称或URL模式。当Web容器启动Web应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例 Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前 过滤器是一个实现了javax.servlet.Filter接口的Java类。javax.servlet.Filter 接口定义了三个方法： public void doFilter (ServletRequest, ServletResponse, FilterChain)：该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器 public void init(FilterConfig filterConfig)：web应用程序启动时，web服务器将创建Filter的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象，如下图所示 123456public void init(FilterConfig config) throws ServletException &#123; // 获取初始化参数 String site = config.getInitParameter("Site"); // 输出初始化参数 System.out.println("网站名称: " + site); &#125; public void destroy()：Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源 web.xml配置参数 &lt;filter&gt;指定一个过滤器。 &lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。 &lt;filter-class&gt;元素用于指定过滤器的完整的限定类名。 &lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;param-name&gt;指定参数的名字，&lt;param-value&gt;指定参数的值。 在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。 &lt;filter-mapping&gt;元素用于设置一个Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径 &lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名字 &lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式) &lt;servlet-name&gt;指定过滤器所拦截的Servlet名称。 &lt;dispatcher&gt;指定过滤器所拦截的资源被Servlet容器调用的方式，可以是REQUEST、INCLUDE、FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt;子元素用来指定Filter对资源的多种调用方式进行拦截。&lt;dispatcher&gt;子元素可以设置的值及其意义？？？ REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 过滤器的常见功能是可以完成编码过滤及登陆验证 异常处理当一个Servlet抛出一个异常时，Web容器在使用了exception-type元素的web.xml中搜索与抛出异常类型相匹配的配置。您必须在web.xml中使用error-page元素来指定对特定异常或HTTP状态码作出相应的Servlet调用，例如12345678910111213141516171819202122232425262728&lt;!-- error-code 相关的错误页面 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/ErrorHandler&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;403&lt;/error-code&gt; &lt;location&gt;/ErrorHandler&lt;/location&gt;&lt;/error-page&gt;&lt;!-- exception-type 相关的错误页面 --&gt;&lt;error-page&gt; &lt;exception-type&gt; javax.servlet.ServletException &lt;/exception-type &gt; &lt;location&gt;/ErrorHandler&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;exception-type&gt;java.io.IOException&lt;/exception-type &gt; &lt;location&gt;/ErrorHandler&lt;/location&gt;&lt;/error-page&gt;&lt;!-- 对所有的异常有一个通用的错误处理程序 --&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type &gt; &lt;location&gt;/ErrorHandler&lt;/location&gt;&lt;/error-page&gt; javax.servlet.error.status_code：该属性给出状态码，状态码可被存储，并存储为java.lang.Integer javax.servlet.error.exception_type：该属性给出异常类型的信息，异常类型可被存储，并存储为java.lang.Class javax.servlet.error.message：该属性给出确切错误消息的信息，信息可被存储，并存储为java.lang.String javax.servlet.error.request_uri：该属性给出有关URL调用Servlet 的信息，信息可被存储，并存储为java.lang.String javax.servlet.error.exception：该属性给出异常产生的信息，信息可被存储，并存储为java.lang.Throwable javax.servlet.error.servlet_name：该属性给出Servlet的名称，名称可被存储，并存储为java.lang.String 在理解异常的时候碰到一个问题123Throwable throwable = (Throwable)request.getAttribute("javax.servlet.error.exception");Integer statusCode = (Integer)request.getAttribute("javax.servlet.error.status_code");String servletName = (String)request.getAttribute("javax.servlet.error.servlet_name"); 一直没想明白：为什么request中会莫名多出来javax.servlet.error.***属性，后来查找资料，流程终于理清、 一个用来向服务器提供客户端请求信息的对象。servlet container产生一个ServletRequest，然后将它作为参数传递给servlet的service方法 属性值可以通过两种方法设置: servlet container可以设置属性,以便请求的特定信息可以被访问；属性同样可以使用setAttribute()方法进行设置。这可以在调用RequestDispatcher之前将信息嵌入到request中 因此如果输入错误的URL，没有对应的Servlet，servlet container就会产生404，并设置javax.servlet.error.status_code，此时由于存在处理异常的servlet，就会调用设置了状态码的ServletRequest传递给该Servlet，接着做出针对该状态码的行为 CookieCookie是存储在客户端计算机上的文本文件，并保留了各种跟踪信息 识别返回用户包括三个步骤： 服务器脚本向浏览器发送一组Cookie。例如：姓名、年龄或识别号码等。 浏览器将这些信息存储在本地计算机上，以备将来使用。 当下一次浏览器向Web服务器发送任何请求时，浏览器会把这些Cookie信息发送到服务器，服务器将使用这些信息来识别用户 Cookie通常设置在HTTP头信息中。设置Cookie的Servlet会发送头信息12Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=runoob.com Set-Cookie头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被URL编码。expires字段是一个指令，告诉浏览器在给定的时间和日期之后”忘记”该Cookie 如果浏览器被配置为存储 Cookie，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该Cookie的路径和域的页面，它会重新发送Cookie到服务器 设置Cookiepublic void setDomain(String pattern)：该方法设置cookie适用的域，例如 runoob.com。public String getDomain()：该方法获取cookie适用的域，例如runoob.com。public void setMaxAge(int expiry)：该方法设置cookie过期的时间（以秒为单位）。如果不这样设置，cookie只会在当前 session 会话中持续有效。public int getMaxAge()：该方法返回cookie的最大生存周期（以秒为单位），默认情况下，-1 表示cookie将持续下去，直到浏览器关闭。public String getName()：该方法返回cookie的名称。名称在创建后不能改变。public void setValue(String newValue):该方法设置与cookie关联的值。public String getValue()：该方法获取与cookie关联的值。public void setPath(String uri)：该方法设置cookie适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有URL都会返回cookie。public String getPath()：该方法获取cookie适用的路径。public void setSecure(boolean flag)：该方法设置布尔值，表示cookie是否应该只在加密的（即SSL）连接上发送。public void setComment(String purpose)：设置cookie的注释。该注释在浏览器向用户呈现cookie时非常有用。public String getComment()：获取cookie的注释，如果cookie没有注释则返回null。 读取Cookie要读取Cookie，您需要通过调用HttpServletRequest的getCookies()方法创建一个 javax.servlet.http.Cookie对象的数组。然后循环遍历数组，并使用getName()和getValue()方法来访问每个cookie和关联的值 删除Cookie删除Cookie是非常简单的 读取一个现有的cookie，并把它存储在Cookie对象中。 使用setMaxAge()方法设置cookie的年龄为零，来删除现有的cookie。 把这个cookie添加到响应头。 SessionHTTP是一种”无状态”协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web服务器，服务器不保留之前客户端请求的任何记录 以下三种方式来维持Web客户端和Web服务器之间的session会话 Web服务器可以分配一个唯一的session会话ID作为每个Web客户端的cookie，对于客户端的后续请求可以使用接收到的cookie来识别。这可能不是一个有效的方法，因为很多浏览器不支持cookie 隐藏的表单字段。一个Web服务器可以发送一个隐藏的HTML表单字段，以及一个唯一的session 会话ID，如下所示。该条目意味着，当表单被提交时，指定的名称和值会被自动包含在GET或 POST 数据中。每次当Web浏览器发送请求时，session_id值可以用于保持不同的Web浏览器的跟踪。这可能是一种保持session会话跟踪的有效方式，但是点击常规的超文本链接（&lt;A HREF...&gt;）不会导致表单提交，因此隐藏的表单字段也不支持常规的session会话跟踪。&lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;12345&quot;&gt; URL重写:您可以在每个URL末尾追加一些额外的数据来标识session会话，服务器会把该session会话标识符与已存储的有关session会话的数据相关联例如，http://w3cschool.cc/file.htm;sessionid=12345，session会话标识符被附加为sessionid=12345，标识符可被Web服务器访问以识别客户端。URL重写是一种更好的维持session会话的方式，它在浏览器不支持cookie时能够很好地工作，但是它的缺点是会动态生成每个URL来为页面分配一个session 会话 ID，即使是在很简单的静态HTML页面中也会如此 HTTPSession除了上述的三种方式，Servlet还提供了HttpSession接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式 Servlet容器使用这个接口来创建一个HTTP客户端和HTTP服务器之间的session会话。会话持续一个指定的时间段，跨多个连接或页面请求 通过调用HttpServletRequest的公共方法getSession()来获取HttpSession对象 数据库Java类库的全部功能对Servlet来说都是可用的。它可以通过sockets和RMI机制与applets、数据库或其他软件进行交互。即使用JDBC来进行了解数据库并访问数据 文件上传Servlet可以与HTML form标签一起使用，来允许用户上传文件到服务器。上传的文件可以是文本文件或图像文件或任何文档 Servlet3.0已经内置了文件上传这一特性，开发者不再需要将Commons FileUpload组件导入到工程中去（在Servlet包的META-INF文件下可以查看版本） 网页重定向当文档移动到新的位置，我们需要向客户端发送这个新位置时，我们需要用到网页重定向。当然，也可能是为了负载均衡，或者只是为了简单的随机，这些情况都有可能用到网页重定向 重定向请求到另一个网页的最简单的方式是使用response对象的sendRedirect()方法；也可以通过把setStatus()和setHeader()方法一起使用来达到同样的效果 参考菜鸟教程]]></content>
      <tags>
        <tag>web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 book_xv6:Chapter 0]]></title>
    <url>%2F2019%2F03%2F08%2FMIT-6-828-book-xv6-Chapter-0%2F</url>
    <content type="text"><![CDATA[概述。一次大胆的尝试！尝试将这本小册子翻译出来！ MIT 6.828 Operating System Engineering 这本书要和xv6源码一起阅读 操作系统接口操作系统的任务是在多个程序之间共享计算机，并提供比硬件单独支持更有用的服务集合。操作系统管理和抽象低级硬件，因此像文字处理机就不需要考虑使用哪种类型的磁盘。它还支持多路复用硬件，允许程序间共享计算机（或近似于）并发运行。最后，操作系统提供了程序交互的受控方式，以便程序之间可以共享数据或者协同工作。 OS通过接口向用户程序提供服务，而设计好的接口是很困难的。一方面，我们希望接口简单和紧凑（窄接口比较容易确保对某一特定点的关注。这点很像铺设自来水管道。管路最初阶段可能从需求和效率考虑需要大口径的，但要入户的时候就要转成小口径，译者注），因为这样更容易正确实现。 另一方面，我们倾向于向应用程序提供更多巧妙的功能。解决这种紧张关系的技巧是设计依赖提供更大的通用性的机制的接口。 这本书使用一个简单OS作为具体示例来阐述OS相关概念。这个OS，即xv6，提供的简单接口，来自于Ken Thompson and Dennis Ritchie的Unix操作系统，并且模拟了Unix的内部设计。Unix的接口提供的窄接口，其机制很好的融合在了一起，提供了令人惊讶的通用性。这些接口很成功，以至于像BSD、Linux，Mac OS X、Solaris，甚至一部分Windows，都有类Unix接口。理解xv6是理解其他任何系统的良好开始。 如图0-1所示，xv6采用了传统形式的内核，内核是为运行程序提供服务的特殊程序。每个运行程序（称为进程）的内存中都包含了指令、数据和栈。指令实现了程序的运算，数据则是运算所依赖的变量，栈则组织了程序的调用过程。 当进程需要调用内核服务时，将调用操作系统接口中的过程调用。这种过程称为系统调用。系统调用会陷入内核态，内核执行完服务并返回用户态。因此进程在用户空间和内核空间之间交替变换。 内核使用CPU的硬件保护机制来确保在用户空间的每个进程只能访问自己的内存。内核在硬件特权上运行，因此需要实现这些保护；用户程序在执行时则没有这些特权。当用户程序调用系统调用时，硬件会提升权限级别，并开始执行在内核中预先写好的函数。 内核提供的系统调用集合就是用户程序可见的接口。xv6内核提供了Unix内核传统提供的服务和系统调用的子集。图 0-2列出了xv6的所有系统调用。 本章其余部分概述了xv6的服务：进程、内存、文件描述、管道和文件系统，并通过代码段来说明shell如何使用它们。shell对系统调用的使用将说明系统调用设计的是多么精巧。 shell是一个从用户读取命令并执行他们的普通程序，而且是传统类Unix的主要用户界面。shell只是一个用户程序，而不是内核的一部分，shell没有什么特别之处反倒说明了系统调用接口的力量。这也意味着shell很容易更换，因此现代Unix系统都有各种各样shell去选择，每种shell都有自己的界面和脚本功能。xv6的shell本质上就是Unix Bourne shell的简单实现。其实现源码从第8350行开始。 进程和内存xv6进程由用户空间内存（指令、数据和栈）和内核的每个进程私有状态组成。xv6可以分时（time-share）处理进程，它透明地在等待执行的进程组之间切换，来分配可用的CPU。当进程未执行时，xv6会保存其CPU寄存器，并在下次运行时还原。内核将进程标识符（pid）和每个进程关联。 进程可以使用fork系统调用来创建新的进程。fork创建的子进程（chile process）和调用进程（父进程，parent process）有着一样的内存信息。fork返回父进程和子进程中都返回，在父进程中返回子进程的pid，在子进程中则返回0。例如考虑下面这个程序片段12345678910111213int pid = fork(); if(pid &gt; 0)&#123; printf("parent: child=%d\n", pid); pid = wait(); printf("child %d is done\n", pid);&#125; else if(pid == 0)&#123; printf("child: exiting\n"); exit();&#125; else&#123; printf("fork error\n");&#125; exit系统调用会导致调用进程结束执行并释放如内存和文件这样的资源。wait系统调用返回当前进程的退出子进程的pid。如果调用者没有子进程退出，则等待。在实例中，命令行输出：12child=1234chileL:exiting 上面两句话会按任意顺序出现，这取决于父进程还是子进程先接收到printf调用。当子进程退出后，父进程的wait返回，因此打印出1parent:child 1234 is done 注意父进程和子进程在不同的内存和寄存器中运行，改变变量值不会影响另外一个。 exec系统调用用从存储在文件系统的文件加载的新内存镜像来替换调用进程的内存。该文件必须具有特定格式，其指明文件的那部分是指令，那部分是数据，从哪里开始执行等。xv6使用ELF格式，第二章将详细讨论该格式。 当exex成功调用后，不会返回调用程序，而是从ELF头部声明的入口开始执行。exec需要两个参数：可执行文件名和字符串参数数组，例如123456char *argv[3];argv[0] = "echo"; argv[1] = "hello"; argv[2] = 0; exec("/bin/echo", argv); printf("exec error\n"); 这个片段将调用程序替换成参数为echo hello的/bin/echo程序实例。大多数程序会忽略第一个参数，这通常是程序名称。 xv6使用上述调用来代替用户运行程序。shell的主体结构很简单，见main（8501行）。主循环使用getcmd读取命令行上的输入。然后调用fork，创建shell进程的副本。父进程调用wait，子进程运行命令。例如，如果用户在提示符下输入echo hello，runcmd将被调用，并以echo hello为参数。runcmd（8406行）执行实际命令。对于echo hello，将调用echo（8426行）。如果exec成功执行，子进程会执行echo的指令，而不是runcmd。在某些点，echo会调用exit，这会导致父进程从wait返回。也许你想知道fork和exec为什么没有合成一个调用，稍后我们将看到，单独调用创建进程和加载程序是一个巧妙的设计。 xv6隐式分配大多数用户空间的内存，fork分配子进程需要的内存，exec分配足够的内存去保存可执行文件。在运行时进程可能需要更多的内存，例如malloc这时候可以调用sbrk(n)将内存扩展n字节。sbrk返回新内存的地址。 xv6不提供用户的概念，也不提供保护一个用户免受一个用户影响的概念，在unix中，所有xv6都以root身份运行。 I/O和文件描述符文件描述符是只是一个小整数值，代表一个进程读取或写入的内核管理对象。进程可以通过打开文件、目录、设备、创建管道、复制存在的描述符来获取文件描述符。简单起见我们通常把文件描述符就当做文件，但其实文件描述符接口是文件、管道和设备的抽象，使它们看起来都是字节流。 xv6内部将文件描述符作为每个预处理表（per—process table）的索引，因此每个进程都有一个从零开始的文件描述符的专有空间。按照惯例，进程从文件描述符0（标准输入）读取，将输出写入到文件描述符1（标准输出），并将错误信息写入文件描述符2（标准错误）。正如我们将看到的，shell利用这个约定（exploits the convention）来实现I/O重定向和管道。shell保证始终打开三个文件描述符（8507），这是控制台的默认文件描述符。 read和write系统调用从描述符命令的打开文件中读取和写入字节。read(fd,buf,n)最多从文件描述符fd读取n字节，将其复制到buf，并返回读取的字节数。每个文件描述符都有一个偏移量，其和引用的文件相关。read从当前文件偏移处读取数据，然后将偏移量向前移动所要读取的n字节数，后续的read将从新的位置继续读取字节。当没有更多的字节能读时，返回0，标志着读到了文件末尾。 write(fd,buf,n)从buf中写入n字节到文件描述符fd，并返回写入的字节数。只有在发生错误时，才会写入少于n字节。像read、write在当前文件偏移处写入数据，并将偏移量向前移动写入的n字节，每次write都会从前一个写入位置写入。 下面的程序片段（构成了cat的本质）从标准输入复制数据到标准输出。如果发生错误，将信息写入标准错误。 123456789101112char buf[512]; int n;for(;;)&#123; n = read(0, buf, sizeof buf); if(n == 0) break; if(n &lt; 0)&#123; fprintf(2, "read error\n"); exit(); &#125; if(write(1, buf, n) != n)&#123; fprintf(2, "write error\n"); exit(); &#125;&#125; 在代码段中需要注意的是cat并不知道它是从文件、控制台还是管道读取。同样，cat也不知道它是打印到控制台、文件还是其他地方。文件描述符的使用，文件描述符0是输入，1是输出，这整个约定使得cat能简单实现。 close系统调用释放文件描述符，使其可被cat、open、pipe和dup重用。新分配的文件描述符始终是当前进程的最小未使用编号。 文件描述符和fork的相互交互使得I/O重定向变得易于实现。fork复制父进程的文件描述符表和内存，使得子进程从和父进程有着相同的打开文件。exec替换调用进程的内存，但是保留其文件表。此行为允许shell通过fork，重新打开选定的文件并执行新的程序来实现I/O重定向。下面是shell命令为cat &lt; input.txt简化代码12345678char *argv[2];argv[0] = "cat";argv[1] = 0;if(fork() == 0) &#123; close(0); open("input.txt", O_RDONLY); exec("cat", argv);&#125; 子进程关闭文件描述符0之后，保证open能将其用于新打开的input.txt，此时0就是最小的可用文件描述符。cat使用引用input.txt的文件描述符0（标准输入）执行。 xv6 shell中的I/O重定向就是以上述方式工作（8430）。回想一下，shell已经fork了child shell，并且runcmd将调用exec加载新程序。现在应该清楚为什么fork和exec单独调用是一个好主意。这种分离允许shell在子程序运行所需要的程序之前修复子进程。 尽管fork复制文件描述符表，但每个基础文件偏移量都在父进程和子进程之间分享。看下面这个实例：1234567if(fork() == 0) &#123; write(1, "hello ", 6); exit();&#125; else &#123; wait(); write(1, "world\n", 6);&#125; 在这个片段的末尾，附加到文件描述符1的文件将包含数据hello world。父进程的write（由于wait，只能在子进程结束之后才会运行）会在子进程write中断的地方继续执行。这种行为将有助于从shell命令序列中产生有序输出，如(echo hello;echo world) &gt; output.txt dup复制现有的文件描述符，返回一个指向相同I/O对象的新文件描述符。这两个文件描述符共享偏移量，就像fork复制的文件描述符一样。这是将hello world写入文件的另一种方法：123fd = dup(1); write(1, "hello ", 6);write(fd, "world\n", 6); 如果文件描述符是通过一系列fork和dup从同一原始文件派生的，则他们共享偏移量，否则即使他们使用open打开同一个文件，也不共享偏移量。dup允许shell实现这样的命令：ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1。2&gt;&amp;1告诉shell提供一个文件描述符2，它是描述符1的副本。现有文件的名字和错误信息都保存在文件tmp1。xv6 shell不支持错误文件描述符的I/O重定向，但你应该知道如何实现。 文件描述符是一个强大的抽象，因为它隐藏了连接的细节：写入文件描述符1的进程可能正写入文件、控制台等设备或者管道。 管道pipe是一个小的内核缓冲区，以一对文件描述符的形式公开给进程，一个用于读取，另一个用于写入。将数据写入管道的一段可使数据从管道的另一端被读取。管道为进程提供了一种通信方式。 下面的示例代码使用连接到管道读取端的标准输入运行程序WC：1234567891011121314151617int p[2]; char *argv[2];argv[0] = "wc"; argv[1] = 0;pipe(p); if(fork() == 0) &#123; close(0); dup(p[0]); close(p[0]); close(p[1]); exec("/bin/wc", argv);&#125; else &#123; write(p[1], "hello world\n", 12); close(p[0]); close(p[1]);&#125; 程序调用pipe，它创建一个新管道，并在数组p中记录读取和写入的文件描述符。在fork之后，父进程和子进程都有引用管道的文件描述符。子进程将读取结果传入文件描述符0，关闭p中的文件描述符，以及执行wc。当wc从标准输入读取时，其实是从管道读取。父进程写入管道的写入端，然后关闭两个文件描述符。 如果没有可用数据，管道上的read会等待数据的写入或者关闭写入端的所有文件描述符。在后一种情况下，read返回0，就像已达到数据文件的末尾。阻塞read直到不可能到达新数据的一个原因是在执行wc之前，让子进程关闭管道的写入端非常重要。因为如果wc的一个文件描述符指向了管道的写入端，wc将永远不会看到文件末尾。 xv6 shell实现了诸如grep fork sh.c | wc -l等类似代码（8450）的管道。子进程创建一个管道，将管道的左端和右端相连，然后调用runcmd为管道的左端和右端。然后调用两次wait去等待左端和右端的完成。管道的右端可能是一个命令，该命令本身也是一个管道（如a | b | c），它本省分叉成两个子进程（一个用于b，一个用于c）。因此shell可能会创建一个进程树。树的叶节点是命令，内部节点是等待左右子进程完成的进程。原则上，你可以让内部节点运行管道的左端，但正确的完成会使得实现变得复杂。管道看起来并没有比临时文件强大，例如echo hello world | wc也可以在没有管道的情况下实现echo hello world &gt; /tmp/xyz;wc &lt; /tmp/xzy 管道和临时文件至少有三个关键区别。第一个，管道会自动清理自己，而在文件重定向时，shell必须在完成时小心的溢出/tmp/xzy。其次，管道可以通过任意长度的数据流，而文件重定向需要磁盘上足够的可用空间来存储所有数据。最后，管道允许同步，两个进程可以使用一对管道相互发送消息，每个read都会阻塞调用进程，直到另一个进程通过write写入数据。 文件系统xv6文件系统提供了数据文件，这些数据文件都是没解释的字节数组和目录，其中包含对数据文件和其他目录的命令引用。xv6将目录实现为一种特殊的文件。目录形成一个从称为root的特殊目录开始的树。像/a/b/c这样的路径指向了根目录中b目录中的命名为c的文件或目录。路径如果没有以/开始，就会改用chdir系统调用，来计算相对于调用进程的当前目录的位置。这两种方式都能打开相同的文件（假设涉及的目录都存在）：1234chdir("/a"); chdir("b"); open("c", O_RDONLY); open("/a/b/c", O_RDONLY); 第一个片段将进程的当前目录更改为/a/b，第二个既不引用也不修改进程的当前目录。 这里有多个系统调用来创建新的文件和目录：mkdir创建一个新的目录，使用O_CREAT标志的open创建一个新的数据文件，mknod创建新的设备文件。下面的示例说明了这三个方面：1234mkdir("/dir"); fd = open("/dir/file", O_CREATE|O_WRONLY); close(fd);mknod("/console", 1, 1); mknod在文件系统中创建一个文件，但是该文件没有内容。相反，该文件的元数据将其标记为设备文件，并记录主要和次要的设备编号（传给mknod的两个参数），它们惟一的标志内核设备。当进程之后打开该文件时，内核将read和write调用转移到内核实现，而不是将它们传到文件系统。 fstat检索有关文件描述符所引用对象的信息。它填充struct stat，该结构定义在stat.h1234567891011#define T_DIR 1 // Directory#define T_FILE 2 // File #define T_DEV 3 // Devicestruct stat &#123;short type; // Type of file int dev; // File system’s disk device uint ino; // Inode number short nlink; // Number of links to file uint size; // Size of file in bytes&#125;; 文件名和文件本身并不同，同一个基础文件，叫做inode，可以有多个名称，叫做links。link系统调用创建另一个文件系统名称，引用和现有文件相同的inode。下面片段创建了一个文件，其名称既可以为a，也可以为b12open(&quot;a&quot;, O_CREATE|O_WRONLY);link(&quot;a&quot;, &quot;b&quot;); 从a或者从b读取、写入是一模一样的。每个inode都是有惟一的inode number标识的。执行了上面的代码之后，可以通过fstat的结果来确定a和b指向相同的基础内容，两者都返回相同的inode number（ino），并且nlink将设置为2。 unlink将从文件系统中删除一个名称。只有当文件的链接数为0并没有文件描述符引用该文件时，才会释放文件的inode和磁盘空间，因此unlink(&quot;a&quot;);将使得inode和文件内容只能被b访问。而且下面的方法是常用的方式来创建临时inode，其在进程关闭fd或者退出时，会被清理。12fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR); unlink(&quot;/tmp/xyz&quot;); 用于文件系统操作的xv6 命令被作为用户级程序（如mkdir、ln、rm等）实现。这种设计允许任何人使用新的用户命令扩展shell。事后看来，这个计划似乎很明显，但和unix同时期设计的其他系统经常在shell中构建这样的命令（并将shell构建到内核中）。 一个例外是cd，它内置到shell (8516) 中。cd必须更改shell本身的当前工作目录。如果cd 作为常规命令运行，并且shell 将分叉子进程, 子进程将运行cd，cd将更改子进程的工作目录。父目录（即shell的）工作目录不会更改。 真实世界unix将“标准”文件描述符、管道和方便的shell语法结合起来，用于对其进行操作，这是编写通用可重用程序的一大进步。这个想法引发了整个“软件工具”的文化，它在很大程度上是unix的力量和人气的原因,，shell是第一个所谓的“脚本语言”。在BSD、Linux和Mac OS X等系统中, unix系统调用接口如今仍然存在。 与xv6相比，现代内核提供了更多的系统调用和更多种类的内核服务。在大多数情况下，现代unix派生的操作系统没有遵循早期的unix模型，即将设备公开为特殊文件，如上面讨论的控制台设备文件。unix的作者接着构建了计划9，该计划将“资源是文件”概念应用于现代设施，将网络、图形和其他资源表示为文件或文件树。 文件系统抽象是一个强大的想法，最近以万维网的形式应用于网络资源。即使如此，操作系统接口还有其他模型。multics是unix的前身，它的抽象文件存储使其看起来像内存，产生了截然不同的接口风格。multics设计的复杂性直接影响了unix的设计者，他们试图构建更简单的设计器。 这本书探讨了xv6如何实现类似unix的界面, 但这些想法和概念不仅仅适用于unix。任何操作系统都必须将进程多路复用到底层硬件上，将进程彼此隔离，并提供受控制的进程间通信机制。在研究了xv6之后，您应该能够查看其他更复杂的操作系统，并在这些系统中看到xv6的基本概念。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Lab:Guide]]></title>
    <url>%2F2019%2F03%2F08%2FMIT-6-828-Lab-Guide%2F</url>
    <content type="text"><![CDATA[实验工具指南 MIT 6.828 Operating System Engineering 此类中使用两组工具：x86模拟器，QEMU，用于运行内核; 和编译器工具链，包括汇编器，链接器，C编译器和调试器，用于编译和测试内核 安装QEMUQEMU是一款现代化的快速PC模拟器 克隆IAP 6.828 QEMU git存储库git clone https://github.com/geofft/qemu.git -b 6.828-1.7.0 在Linux上，可能需要安装SDL开发库以便获得图形VGA窗口，在Ubuntu下使用如下命令安装sudo apt-get install libsdl1.2-dev 安装sudo apt-get install python2.7 python2.7-dev，而且不支持python3以上12Python 2.4 or later is required.Note that Python 3 or later is not yet supported. 依旧有错误12345ERROR: pixman not present. Your options: (1) Preferred: Install the pixman devel package (any recent distro should have packages as Xorg needs pixman too). (2) Fetch the pixman submodule, using: git submodule update --init pixman 于是，用apt-cache查找了关于pixman的依赖包apt-cache search pixman 选择安装libpixman-1-dev的那个包，sudo apt-get install libpixman-1-dev 配置qemu代码 ./configure --disable-kvm --python=python2.7 [--prefix=PFX] [--target-list=&quot;i386-softmmu x86_64-softmmu&quot;]，prefix参数指定QEMU安装目录; 若没有该参数，默认安装到 /usr/local。target-list参数指定QEMU模拟的CPU架构。执行成功后，会显示一系列参数 123456789101112131415Install prefix /usr/localBIOS directory /usr/local/share/qemubinary directory /usr/local/binlibrary directory /usr/local/liblibexec directory /usr/local/libexecinclude directory /usr/local/includeconfig directory /usr/local/etclocal state directory /usr/local/varManual directory /usr/local/share/manELF interp prefix /usr/gnemul/qemu-%MSource path /home/xzy/qemuC compiler ccHost C compiler ccC++ compiler c++... make &amp;&amp; make install 依旧有错误123456util/qemu-sockets.c:33:18: error: ‘on’ defined but not used [-Werror=unused-const-variable=] static const int on=1, off=0; ^~cc1: all warnings being treated as errors/home/xzy/qemu/rules.mak:25: recipe for target &apos;util/qemu-sockets.o&apos; failedmake: *** [util/qemu-sockets.o] Error 1 修改util/qemu-sockets.c，删除on定义 依旧出现了问题1234567891011121314vl.c: In function ‘main’:vl.c:2778:5: error: ‘g_mem_set_vtable’ is deprecated [-Werror=deprecated-declarations] g_mem_set_vtable(&amp;mem_trace); ^In file included from /usr/include/glib-2.0/glib/glist.h:32:0, from /usr/include/glib-2.0/glib/ghash.h:33, from /usr/include/glib-2.0/glib.h:50, from vl.c:59:/usr/include/glib-2.0/glib/gmem.h:357:7: note: declared here void g_mem_set_vtable (GMemVTable *vtable); ^cc1: all warnings being treated as errorsrules.mak:57: recipe for target &apos;vl.o&apos; failedmake: *** [vl.o] Error 1 其实解决起来很简单，在Makefile文件最后加上一行QEMU_CFLAGS+=-w就可以 BUG真多1234567891011/home/xzy/qemu/hw/i386/pc.c:894:18: error: ‘parallel_irq’ defined but not used [-Werror=unused-const-variable=] static const int parallel_irq[MAX_PARALLEL_PORTS] = &#123; 7, 7, 7 &#125;; ^~~~~~~~~~~~/home/xzy/qemu/hw/i386/pc.c:893:18: error: ‘parallel_io’ defined but not used [-Werror=unused-const-variable=] static const int parallel_io[MAX_PARALLEL_PORTS] = &#123; 0x378, 0x278, 0x3bc &#125;; ^~~~~~~~~~~cc1: all warnings being treated as errors/home/xzy/qemu/rules.mak:25: recipe for target &apos;hw/i386/pc.o&apos; failedmake[1]: *** [hw/i386/pc.o] Error 1Makefile:144: recipe for target &apos;subdir-i386-softmmu&apos; failedmake: *** [subdir-i386-softmmu] Error 2 简单粗暴就是注释掉 安装的时候，还碰到了权限的问题，使用sudo su而不是su能进入root 在执行qemu-system-i386之后就能将xv6源码编译后，放入qemu执行 但这一步，意味着MIT官方的QEMU已经安装好 载入xv6先要下载lab代码 在进入lab文件夹进行编译之间，如果GCC版本是7.0以上一定要给虚拟机GCC版本降级，不然会出现奇奇怪怪的错误，我已经被这个给搞狂躁了！！！具体方法12root@ubuntu:~# sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100update-alternatives: using /usr/bin/gcc-4.8 to provide /usr/bin/gcc (gcc) in auto mode 降级好后，下载源码并进行编译（进入lab目录，执行make)，就如原文所说，需要安装gcc-multilib，使用命令sudo apt-get install gcc-4.8-multilib 完成上面的步骤后，会得到一个obj/kern/kernel.img作为模拟PC“虚拟硬盘”的内容提供。此硬盘映像包含我们的引导加载程序obj/boot/boot和我们的内核obj/kernel 编译完内核源码，我们就可以把它运行在QEMU上啦！首先在lab目录下面，输入make qemu，此时qemu就开始自动加载我们的操作系统内核映像文件 成功！！ GDB Ctrl-c：暂停机器并按当前指令进入GDB。如果QEMU有多个虚拟CPU，则会暂停所有虚拟CPU c（或continue）：继续执行直到下一个断点或Ctrl-csi（或stepi）：执行一条机器指令 b function或b file:line（或 breakpoint）：在给定的函数或行上设置断点 b *addr（或breakpoint）：在EIP地址处设置断点 set print pretty：启用数组和结构的漂亮打印 info registers：打印通用寄存器，eip eflags和段选择器 x/Nx addr：显示从虚拟地址addr开始的N个字的十六进制转储。如果省略N，则默认为1 x/Ni addr：显示从addr开始的N个汇编指令。使用$eip作为addr将在当前指令指针处显示指令 symbol-file file：（Lab 3+）切换到符号文件文件。当GDB附加到QEMU时，它没有虚拟机中的进程边界的概念，因此我们必须告诉它使用哪些符号。默认情况下，我们将GDB配置为使用内核符号文件obj/kern/kernel。如果机器正在运行用户代码，例如hello.c，则可以使用符号文件obj/user/hello切换到hello符号文件 QEMU将每个虚拟CPU表示为GDB中的线程，因此您可以使用GDB的所有线程相关命令来查看或操作QEMU的虚拟CPU thread n：GDB一次关注一个线程（即CPU）。此命令将焦点切换到线程n，从零开始编号。 info threads：列出所有线程（即CPU），包括它们的状态（活动或暂停）以及它们所处的功能。 lab源码实验要用的材料都已经上传源码，其中包括lab、qemu、homework等实验源码和答案]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Assignment:Shell]]></title>
    <url>%2F2019%2F03%2F08%2FMIT-6-828-Assignment-Shell%2F</url>
    <content type="text"><![CDATA[通过在小shell中实现多个功能，这个assignment将使我更熟悉Unix系统调用接口和shell MIT 6.828 Operating System Engineering 做作业之前先熟悉OSMIT 6.828 book_xv6:Chapter 0该作业的解释文档下载sh.c 建立t.sh文件123456ls &gt; ycat &lt; y | sort | uniq | wc &gt; y1cat y1rm y1ls | sort | uniq | wcrm y gcc，你可以编译骨架shell，如下所示：$ gcc sh.c生成一个a.out文件，你可以运行：$ ./a.out &lt;t.sh此执行将打印错误消息，因为您尚未实现多个功能。在本作业的其余部分中，您将实现这些功能 分析先看看主函数的行为12345678910111213141516171819202122intmain(void)&#123; static char buf[100]; int fd, r; // Read and run input commands. while(getcmd(buf, sizeof(buf)) &gt;= 0)&#123; if(buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' ')&#123; // Clumsy but will have to do for now. // Chdir has no effect on the parent if run in the child. buf[strlen(buf)-1] = 0; // chop \n if(chdir(buf+3) &lt; 0) fprintf(stderr, "cannot cd %s\n", buf+3); continue; &#125; if(fork1() == 0) runcmd(parsecmd(buf)); wait(&amp;r); &#125; exit(0);&#125; 循环调用getcmd函数读入命令，如果是cd命令，则先切换文件夹，因为如果在子进程切换将对父进程无效。确认不是cd之后，创建子进程并调用关键函数runcmd()，其中parsecmd(buf)无非就是解析命令，里面就是一些字符串处理，不关心。 下面就我们要完成的代码片段1234567891011121314151617181920212223242526272829303132333435363738394041// Execute cmd. Never returns.voidruncmd(struct cmd *cmd)&#123; int p[2], r; struct execcmd *ecmd; struct pipecmd *pcmd; struct redircmd *rcmd; if(cmd == 0) exit(0); switch(cmd-&gt;type)&#123; default: fprintf(stderr, "unknown runcmd\n"); exit(-1); case ' ': ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(0); fprintf(stderr, "exec not implemented\n"); // Your code here ... break; case '&gt;': case '&lt;': rcmd = (struct redircmd*)cmd; fprintf(stderr, "redir not implemented\n"); // Your code here ... runcmd(rcmd-&gt;cmd); break; case '|': pcmd = (struct pipecmd*)cmd; fprintf(stderr, "pipe not implemented\n"); // Your code here ... break; &#125; exit(0);&#125; parsecmd把命令分成了3个类型，分别是可执行命令，重定向命令，以及管道命令。也就是接下来要实现的 简单命令该题的要求就是先调用当前目录下的可执行程序，如果不存在，就去/bin文件夹下寻找，如果没有则报错 需要使用的就是execv函数，它是exec函数族的一个，exec函数族的作用就是根据pathname找到可执行文件，并用它取代调用进程的内容。虽然pid未改变，但是实际运行的内容已经不同。结合之前main函数中的内容，可以看出Shell执行某个命令实际上就是fork出一个子进程，然后把子进程替换为想要执行的程序。这个函数在小册子中也讲解过，可以通过man 3 exec去查看函数解释 除此之外，还需要一个辅助函数access，它的作用是检查能否对某个文件（pathname）执行某个操作（mode）。模式有： R_OK：测试读许可权 W_OK：测试写许可权 X_OK：测试执行许可权 F_OK：测试文件是否存在 1234567891011121314151617181920case ' ': ecmd = (struct execcmd*)cmd; if (ecmd-&gt;argv[0] == 0) exit(0); // fprintf(stderr, "exec not implemented\n"); if (access(ecmd-&gt;argv[0], F_OK) == 0) &#123; execv(ecmd-&gt;argv[0], ecmd-&gt;argv); &#125; else &#123; const char *binPath = "/bin/"; int pathLen = strlen(binPath) + strlen(ecmd-&gt;argv[0]); char *abs_path = (char *)malloc((pathLen+1)*sizeof(char)); strcpy(abs_path, binPath); strcat(abs_path, ecmd-&gt;argv[0]); if (access(abs_path, F_OK) == 0) &#123; execv(abs_path, ecmd-&gt;argv); &#125; else &#123; fprintf(stderr, "%s: Command not found\n", ecmd-&gt;argv[0]); &#125; &#125; break; 编译运行截图，嘻嘻嘻！ I/O重定向The parser already recognizes &quot;&gt;&quot; and &quot;&lt;&quot;, and builds a redircmd for you, so your job is just filling out the missing code in runcmd for those symbols. You might find the man pages for open and close useful 123456789101112case '&gt;':case '&lt;': rcmd = (struct redircmd*)cmd; // fprintf(stderr, "redir not implemented\n"); // Your code here ... close(rcmd-&gt;fd); if (open(rcmd-&gt;file, rcmd-&gt;mode, 0644) &lt; 0) &#123; fprintf(stderr, "Unable to open file: %s\n", rcmd-&gt;file); exit(0); &#125; runcmd(rcmd-&gt;cmd); break; 思路就是先关闭程序原先的标准输入/输出，打开指定文件作为新的标准输入/输出。非常容易漏掉权限位，即open的第三个参数 编译运行截图，嘻嘻嘻！ 管道You might find the man pages for pipe, fork, close, and dup useful，也就是说这次涉及的函数主要是pipe、dup、fork、close，通过输入前面创建的t.sh批处理文件，来计算当前目录下文件的大小 12345678910111213141516171819case '|': pcmd = (struct pipecmd*)cmd; // fprintf(stderr, "pipe not implemented\n"); // Your code here ... if (pipe(p) &lt; 0) fprintf(stderr,"pipe failed\n"); if (fork1() == 0) &#123; close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); &#125; else &#123; close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); &#125; break; 由于批处理文件的命令既有在/bin/下，也有在/usr/bin，因此之前的case需要修改 123456789101112131415161718192021222324252627282930case ' ': ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(0); // fprintf(stderr, "exec not implemented\n"); if(access(ecmd-&gt;argv[0], F_OK) == 0) &#123; execv(ecmd-&gt;argv[0], ecmd-&gt;argv); &#125; else &#123; // 将路径改为数组实现 const char *binPath[] = &#123;"/bin/", "/usr/bin/"&#125;; char *abs_path; int bin_count = sizeof(binPath)/sizeof(binPath[0]); int found = 0; for (int i=0; i&lt;bin_count &amp;&amp; found==0; i++) &#123; int pathLen = strlen(binPath[i]) + strlen(ecmd-&gt;argv[0]); abs_path = (char *)malloc((pathLen+1)*sizeof(char)); strcpy(abs_path, binPath[i]); strcat(abs_path, ecmd-&gt;argv[0]); if(access(abs_path, F_OK) == 0) &#123; execv(abs_path, ecmd-&gt;argv); found = 1; &#125; free(abs_path); &#125; if (found == 0) &#123; fprintf(stderr, "%s: Command not found\n", ecmd-&gt;argv[0]); &#125; &#125; break; 编译运行截图，嘻嘻嘻！]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Operating System Engineering]]></title>
    <url>%2F2019%2F03%2F08%2FMIT-6-828-Operating-System-Engineering%2F</url>
    <content type="text"><![CDATA[针对MIT 6.828课程的系列文章 MIT 6.828是一门被广泛好评的操作系统课程。它最重要的特点就是它实践第一的教学原则。在这门课程中会涉及到非常丰富的实验，也会有非常多的动手机会。而且授课者更是亲自构建了一个简化的基于Unix内核的操作系统xv6。所有的实验都是在这个操作系统上完成。虽然它功能很简单，但是它能够帮助我们真正的了解操作系统在做什么 这一系列文章会包括以下几个内容： Lab：MIT 6.828 Lab *** Exercise：MIT 6.828 Exercise *** Assignment：MIT 6.828 Assignment *** book_xv6：自己的中文翻译，MIT 6.828 book_xv6 *** 资源xv6源码：git clone https://github.com/mit-pdos/xv6-public.gitxv6_book：关于xv6的参考手册，链接课程Schedule：这个系列学习会按照这个schedule进行，链接lab guide：实验指导，链接 目录book MIT 6.828 book_xv6:Chapter 0：操作系统接口 MIT 6.828 book_xv6:Chapter 1：操作系统组成 MIT 6.828 book_xv6:Chapter 2：页表 MIT 6.828 book_xv6:Chapter 3：陷阱、中断和驱动 MIT 6.828 book_xv6:Chapter 4：锁 MIT 6.828 book_xv6:Chapter 5：调度程序 MIT 6.828 book_xv6:Chapter 6：文件系统 MIT 6.828 book_xv6:Appendix A：PC硬件 MIT 6.828 book_xv6:Appendix B：Boot loader Lab MIT 6.828 Lab:Guide MIT 6.828 Lab:Booting a PC MIT 6.828 Lab:Memory Management Assignment MIT 6.828 Assignment:Shell MIT 6.828 Assignment:Boot xv6 MIT 6.828 Assignment:System Calls]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件]]></title>
    <url>%2F2019%2F03%2F08%2FMySQL-%E3%80%8A%E6%96%87%E4%BB%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[介绍MySQL数据库和InnoDB存储引擎表的各种类型文件 参数文件告诉MySQL实例启动时，在哪里找到数据库文件，并且指定某些初始化参数。可通过命令mysql --help | grep my.cnf来寻找参数文件 MySQL可以不需要参数，这时的参数取决于编译MySQL时指定的默认值和源代码中指定参数的默认值 参数其实就是键值对，可以通过SHOW VARIABLES查看数据库中的所有参数，也可以通过LIKE来过滤参数名 MySQL参数可以分为动态和静态两种类型。动态参数意味着可以在MySQL实例运行中进行更改，静态参数则相反。可以通过SET对动态参数值进行修改，语法如下：123SET| [global | session] system_var_name= expr| [@@global. | @@session. | @@] |system_var_name= expr global和session两个关键词表明该参数的修改是基于当前回话还是整个实例的生命周期，例子如下123456789101112131415161718mysql&gt; SET read_buffer_size=524288;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@session.read_buffer_size;+----------------------------+| @@session.read_buffer_size |+----------------------------+| 524288 |+----------------------------+1 row in set (0.00 sec)mysql&gt; SELECT @@global.read_buffer_size;+---------------------------+| @@global.read_buffer_size |+---------------------------+| 131072 |+---------------------------+1 row in set (0.00 sec) 对变量的全局值进行修改，只在这次实例的生命周期内有效，不会去修改参数文件中对应的值，因此用户如果想在MySQL下次启动时使用该参数，就要去修改参数文件 日志文件记录MySQL实例对某种条件作出相应时写入的文件，如错误日志、二进制文件、慢查询文件、查询日志文件 MySQL日志文件有四类，这些日志文件将帮助开发人员对数据库的运行状态进行诊断，并进行数据库层面的优化 错误日志对MySQL的启动、运行、关闭过程进行了记录，可通过SHOW VAIABLES LIKE ‘log_error来定位该文件 慢查询日志slow log可以定位可能存在问题的SQL语句，从而进行SQL语句层面的优化 MySQL在启动时，要设置一个阈值，将运行时间超过（大于，而非大于等于）该阈值的SQL语句都记录到慢查询日志文件中，该值可以通过long_query_time设置，单位是微秒1234567mysql&gt; show variables like &apos;long_query_time&apos;;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec) 默认情况下，MySQL是不启动慢查询日志，要手动设置为ON12mysql&gt; show variables like &apos;log_slow_queries&apos;;Empty set (0.00 sec) MySQL另外一个参数是log_throttle_queries_not_using_indexes，用来表示每分钟允许记录到slow log的且未使用索引的SQL语句次数 当慢查询日志越来越多时，就需要MySQL提供的mysqldumpslow命令123456789mysqldumpslow --helpUsage: mysqldumpslow [ OPTS... ] [ LOGS... ]Parse and summarize the MySQL slow query log. Options are --verbose verbose --debug debug --help write this text to standard output... MySQL也将慢查询日志记录放在一张表中12345678910111213141516show create table mysql.slow_log;| Table | Create Table | slow_log | CREATE TABLE `slow_log` ( `start_time` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), `user_host` mediumtext NOT NULL, `query_time` time(6) NOT NULL, `lock_time` time(6) NOT NULL, `rows_sent` int(11) NOT NULL, `rows_examined` int(11) NOT NULL, `db` varchar(512) NOT NULL, `last_insert_id` int(11) NOT NULL, `insert_id` int(11) NOT NULL, `server_id` int(10) unsigned NOT NULL, `sql_text` mediumblob NOT NULL, `thread_id` bigint(21) unsigned NOT NULL) ENGINE=CSV DEFAULT CHARSET=utf8 COMMENT=&apos;Slow log&apos; 参数log_output指定了慢查询输出的格式，默认为FILE，可将其设置为TABLE MySQL还增加了来逻辑读取和物理读取的统计，物理读取就是指从磁盘进行I/O读取的次数，逻辑读取包含所有的读取，不管是磁盘还是缓冲池。可以设置long_query_io参数来将超过指定逻辑IO次数的查询记录到slow log中 查询日志记录了对MySQL数据库请求的所有信息，无论这些请求是否得到了正确执行 二进制日志记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作，因为这类操作对数据本身没有修改 总的来说，二进制文件主要有以下作用 恢复：某些数据的恢复需要二进制日志，用户可以通过二进制文件进行point-in-time的恢复 复制：与恢复类似，通过复制和执行二进制日志使一台远程数据库（slave或standby）与另一台（master或primary）进行实时同步 审计：通过二进制日志中的信息进行审计，判断是否对数据库进行注入的攻击 以下参数配置会影响二进制文件的信息和行为12345678910111213141516171819202122232425262728mysql&gt; show variables like &quot;%binlog%&quot;;+--------------------------------------------+----------------------+| Variable_name | Value |+--------------------------------------------+----------------------+| binlog_cache_size | 32768 || binlog_checksum | CRC32 || binlog_direct_non_transactional_updates | OFF || binlog_error_action | ABORT_SERVER || binlog_format | ROW || binlog_group_commit_sync_delay | 0 || binlog_group_commit_sync_no_delay_count | 0 || binlog_gtid_simple_recovery | ON || binlog_max_flush_queue_time | 0 || binlog_order_commits | ON || binlog_row_image | FULL || binlog_rows_query_log_events | OFF || binlog_stmt_cache_size | 32768 || binlog_transaction_dependency_history_size | 25000 || binlog_transaction_dependency_tracking | COMMIT_ORDER || innodb_api_enable_binlog | OFF || innodb_locks_unsafe_for_binlog | OFF || log_statements_unsafe_for_binlog | ON || max_binlog_cache_size | 18446744073709547520 || max_binlog_size | 104857600 || max_binlog_stmt_cache_size | 18446744073709547520 || sync_binlog | 1 |+--------------------------------------------+----------------------+22 rows in set (0.01 sec) max_binlog_size指定单个二进制文件的最大值，如果超过，建立新的二进制文件 binlog_cache_size当使用事务的表存储引擎时，所有未提交的二进制日志都会被记录到一个缓存中，等该事务提交时直接将缓冲中的二进制日志记录到二进制日志文件中，该参数就是指定缓冲区的大小 该参数是基于会话（session），也就是说，当一个线程开始一个事务时，MySQL就会自动分配一个大小为binlog_cache_size的缓存，因此不能设置过大，但是也不能设置过小，因为当事务记录大于设定的参数时，会将缓存中的日志写入一个临时文件。可以通过下面去查看这个参数设置是否合适 12345678mysql&gt; show global status like &quot;binlog_cache%&quot;;+-----------------------+-------+| Variable_name | Value |+-----------------------+-------+| Binlog_cache_disk_use | 0 || Binlog_cache_use | 0 |+-----------------------+-------+2 rows in set (0.00 sec) Binlog_cache_disk_use记录使用临时文件写二进制日志的次数，Binlog_cache_use记录使用缓存写二进制日志的次数。使用之前要先配置log-bin，并且要重启，我说怎么次数是01root@ubuntu:/home/xzy# service mysql restart sync_binlog二进制日志并不是每次写的时候同步到磁盘的。该参数就是表示缓存多少次同步到磁盘 binlog_format影响记录二进制日志的格式，在MySQL 5.1之前，二进制文件格式都是基于SQL语句级别。这种形式的二进制文件会导致主从数据库的数据不一致 因此引入以下参数 STATEMENT：这种模式记录的依旧是逻辑SQL语句 ROW：记录表的更改情况 MIXED：MySQL默认使用STATEMENT格式进行记录，但是在某些情况下使用ROW格式记录 使用ROW格式，可能会导致二进制文件大小变得很大，这对磁盘空间要求有一定的增加，而且复制是采用传输二进制文件实现的，会对网络开销产生影响 查看123456789101112131415161718192021root@ubuntu:/var/log/mysql# mysqlbinlog mysql-bin.000001 /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;DELIMITER /*!*/;# at 4#190312 7:20:40 server id 1 end_log_pos 123 CRC32 0x7bdc45e3 Start: binlog v 4, server v 5.7.25-0ubuntu0.18.04.2-log created 190312 7:20:40 at startup# Warning: this binlog is either in use or was not closed properly.ROLLBACK/*!*/;BINLOG &apos;OMCHXA8BAAAAdwAAAHsAAAABAAQANS43LjI1LTB1YnVudHUwLjE4LjA0LjItbG9nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4wIdcEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQAAeNF3Hs=&apos;/*!*/;# at 123#190312 7:20:40 server id 1 end_log_pos 154 CRC32 0x47bb9591 Previous-GTIDs# [empty]SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;DELIMITER ;# End of log file/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/; 此时产生的信息时不可读的，要加上参数-v或-vv，可以看到执行的具体信息 套接字文件当用UNIX域套接字文件进行连接时需要的文件，套接字文件可由参数socket控制 pid文件MySQL实例启动时，会将自己的进程ID写入pid文件 上面两个文件的位置都可以在配置文件中查看到 MySQL表结构文件因为MySQL插件式存储引擎的体系结构的关系，MySQL数据的存储都是基于表的，每个表都有与之对应的文件。但不论表采取何种存储引擎，MySQL都有一个frm为后缀名的文件，记录该表的表结构定义。frm同样用来存放视图的定义 上面介绍的都是MySQL数据库本身的文件，和存储引擎无关 存储引擎文件MySQL的存储引擎都有自己的文件来存储各种数据，这些存储引擎才真正存储记录和索引等数据 表空间文件InnoDB采用将存储的数据按照表空间进行存放的设计。在默认配置下，会有一个初始大小为10M,名为iddata1的文件，该文件就是默认的表空间文件 可以通过innodb_data_file_path参数将多个文件组成一个表空间，同时设置文件的属性。如果文件位于不同的磁盘上，就能达到负载均衡，提供数据库整体性能。设置了该参数，则所有InnoDB存储引擎的表的数据都会记录到该共享表空间中 另一个参数innodb_file_per_table，用户可以将每个基于InnoDB的表产生一个独立表空间，文件名为table_name.ibd，这些单独的文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是放在默认的共享表空间 重做日志文件该文件对InnoDB至关重要，记录了对于InnoDB的事务日志。InnoDB会根据重做日志文件将数据库恢复到出现故障之前的状态，保证数据的完整性 每个InnoDB存储引擎至少有1个重做日志文件组，每个组下面至少2个重做日志文件。在日志组中每个重做日志文件大小一致。并以循环写入的方式运行 以下参数影响着重做日志的属性 innodb_log_file_size：重做日志文件大小 innodb_log_file_in_group：日志文件组中重做日志文件的数量 innodb_mirrored_log_groups：日志镜像文件组的数量 innodb_log_group_name：日志文件组所在路径，默认为./，表示MySQL数据库的数据目录下 重做日志文件的大小设置对性能影响非常大。设置过大，恢复时需要很长的时间，设置过小，会但质一个事务的日志需要多次切换重做日志文件 和二进制日志的区别 二进制文件记录的是和MySQL相关的日志记录，包括InnoDB、MyISAM等日志；InnoDB重做日志文件只记录自身引擎本身的事务日志 二进制文件记录关于一个事务的具体操作，该日志是逻辑日志，重做日志记录关于每个页的更改的物理情况 二进制日志文件仅在事务提交前进行提交，不论事务多大，只提交一次；重做日志在事务执行期间不断有条目写入日志 重做日志条目由4部分组成 redo_log_type：表示重做日志的类型 space：表空间ID page_no：页的偏移量 redo_log_body：数据部分，恢复时需要调用相应函数进行解析 写入重做日志文件先写入一个重做日志缓冲，再按照一定条件写入磁盘，也就是重做日志文件，此时按照512字节大小，也就是一个扇区的大小写入。因为扇区是写入的最小单位，因此可以保证写入必定成功 主线程每秒会将重做日志缓冲写入文件，不论事务是否已经提交 另一个触发写入操作由参数innodb_flush_log_at_trx_commit控制。0表示当提交事务时，并不将事务的重做日志写入磁盘文件的日志文件，而是等待主线程的刷新。1表示在执行commit时将重做日志缓冲同步到磁盘，即伴有fsync的调用。2表示重做日志异步写到磁盘，即写到文件系统的缓存中]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引与算法]]></title>
    <url>%2F2019%2F03%2F06%2FMySQL-%E3%80%8A%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%2F</url>
    <content type="text"><![CDATA[对InnoDB存储引擎支持的索引做一个概述，并对索引内部的机制深入分析 索引索引这节是MySQL内容补充 聚集索引通俗讲就是一本字典本身，通过拼音查询汉字就是使用聚集索引。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引” 一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是平衡树结构，换句话说，就是整个表就变成了一个索引。也就是所谓的聚集索引。 这就是为什么一个表只能有一个主键， 一个表只能有一个聚集索引，因为主键的作用就是把表的数据格式转换成索引（平衡树）的格式放置 其中树的所有结点（叶节点除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句select * from table where id = 1256;，首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行 但是加入索引之后，写入数据的速度会下降。原因很简单的，因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构，因此，在每次数据改变时，DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因 非聚集索引我们通过偏旁去查询汉字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引” 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引，那么索引就是由name字段中的值构成，在数据改变时，DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引，那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联 每次给字段建一个新索引，字段中的数据就会被复制一份出来，用于生成索引。因此，给表添加索引，会增加表的体积，占用磁盘存储空间 非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值，再使用主键的值通过聚集索引查找到需要的数据 不管以任何方式查询表，最终都会利用主键通过聚集索引来定位到数据，聚集索引（主键）是通往真实数据所在的唯一路径 B+树]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CLRS-B树]]></title>
    <url>%2F2019%2F03%2F06%2FCLRS-B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[很多数据库系统会使用B树来存储信息。因为B树的分支因子可以很大，即节点可以有很多孩子，这可以降低树的高度，以及查找任何一个关键字所需的磁盘存取次数例如一棵高度为2分支因子为1001的B树，可以存储超过10亿个关键字，由于根结点已经在主存中，查找任何关键字都只需要2次磁盘存取 B树的定义 B树的高度和红黑树一样对数增长，但是对数的底数要大很多倍，这意味着磁盘访问次数少很多]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《单机数据库》]]></title>
    <url>%2F2019%2F03%2F05%2FRedis%EF%BC%9A%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[对Redis服务器的数据库实现进行介绍 介绍服务器保存数据库的方法，客户端切换数据库的方法，数据库保存键值对的方法，以及针对数据库的添加、删除、查看、更新的实现方法，服务器保存见得过期时间的方法，以及服务器自动删除过期键的方法，数据库通知功能的实现方法 在redis.h/redisServer结构中定义了服务器的大量属性 数据库在redis.h/redisServer结构中有个redisDb *db;属性，它代表了所有数据库，每一项都指向了一个数据库 其中的属性int dbnum;/* Total number of configured DBs */则指明了数据库的个数，默认为16 在redis.h/redisClient结构中也有一个redisDb *db属性，记录了该客户端使用的目标数据库。SELECT命令可以修改客户端的目标数据库，底层原理就是上述指针，使其指向服务器的不同数据库 键空间123456789typedef struct redisDb &#123; dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP) */ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; long long avg_ttl; /* Average TTL, just for stats */&#125; redisDb; 我们知道每个数据库都由上述结构表示，其中的dict字典保存了所有键值对，称这个字典为键空间（keysspace），键空间和用户所见的数据库是一一对应的 对键值对的添加、删除更新等操作，都是通过键空间来进行处理完成的 服务器不仅对键空间执行指定的读写操作，还会执行额外的维护操作 会更新服务器的键空间命中次数和不命中次数 更新键的LRU（最后一次使用）时间，可用于计算键的闲置时间 删除过期键 使用WATCH命令监视键，如果在该键被修改时，将其标记为脏（dirty），从而让事务程序注意到这个键被修改 对脏键的计数器+1，这个计数器会触发服务器的持久化和复制操作 修改键之后，就会按照配置触发发送响相应的数据库通知 生存时间或过期时间通过EXPIRE或PEXPIRE命令可以以秒或毫秒给键设置生存时间（Time To Live，TTL）。同理，通过EXPIREAT或PEXPIREAT命令可以设置过期时间，过期时间来临时，服务器会自动删除该键 通过上述命令设置了键后，可以通过TTL或PTTL查看键的剩余生存时间 前面提到的四个设置生存时间或是过期时间的命令，最终都是转换成PEXPIREAT命令来执行 在redisDb结构中有expires属性，来保存数据库所有键的过期时间，称这个属性为过期字典。过期字典的键是一个指向键空间某个键对象，值就是UNIX时间戳的long long类型整数 过期删除策略当一个键过期时，有三种策略去删除过期键 定时删除：在设置键的过期时间的同时，设置一个定时器，让定时器执行对键的过期删除 惰性删除：放任键过期不管，但每次从键空间取出键的时候，检查键是否过期 定期删除：每隔一段时间，程序对数据库进行检查，删除里面的过期键 定时删除由于能及时删除过期键，对内存最为友好，但是设置定时器意味着要创建线程去占用CPU时间，当大量请求等待服务器处理时，就不应该把CPU时间浪费在处理过期键上 除此之外，创建一个定时器要用到Redis服务器的时间事件，而时间事件的实现方式无序链表，这意味着并不能高效处理特定事件 惰性删除对CPU友好，但是对内存不友好，过期键可能永远不会被删除（除非用户执行FLUSHDB），这就类似于内存泄漏 定期删除就是上面两种方法的折中，这种方法的关键在于设置删除操作的执行时长和频率 Redis使用的是惰性删除和定期删除 惰性删除由db.c/expireIfNeeded函数实现123456789101112131415161718192021int expireIfNeeded(redisDb *db, robj *key) &#123; if (!keyIsExpired(db,key)) return 0; /* If we are running in the context of a slave, instead of * evicting the expired key from the database, we return ASAP: * the slave key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. */ if (server.masterhost != NULL) return 1; /* Delete the key */ server.stat_expiredkeys++; propagateExpire(db,key,server.lazyfree_lazy_expire); notifyKeyspaceEvent(NOTIFY_EXPIRED, "expired",key,db-&gt;id); return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);&#125; 所有读写数据库的命令都会调用上述函数对输入键进行检查。如第一行所示，如果键没有过期，不做动作，他就像过滤器，过滤掉过期的输入键 定期删除由redis.c/activeExpireCycle函数实现，服务器周期性函数redis.c/serverCron函数执行时，就会调用该函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/* Try to expire a few timed out keys. The algorithm used is adaptive and * will use few CPU cycles if there are few expiring keys, otherwise * it will get more aggressive to avoid that too much memory is used by * keys that can be removed from the keyspace. * * No more than REDIS_DBCRON_DBS_PER_CALL databases are tested at every * iteration. * * This kind of call is used when Redis detects that timelimit_exit is * true, so there is more work to do, and we do it more incrementally from * the beforeSleep() function of the event loop. * * Expire cycle type: * * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a * "fast" expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION * microseconds, and is not repeated again before the same amount of time. * * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is * executed, where the time limit is a percentage of the REDIS_HZ period * as specified by the REDIS_EXPIRELOOKUPS_TIME_PERC define. */void activeExpireCycle(int type) &#123; /* This function has some global state in order to continue the work * incrementally across calls. */ static unsigned int current_db = 0; /* Last DB tested. */ static int timelimit_exit = 0; /* Time limit hit in previous call? */ static long long last_fast_cycle = 0; /* When last fast cycle ran. */ int j, iteration = 0; int dbs_per_call = REDIS_DBCRON_DBS_PER_CALL; long long start = ustime(), timelimit; if (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123; /* Don't start a fast cycle if the previous cycle did not exited * for time limt. Also don't repeat a fast cycle for the same period * as the fast cycle total duration itself. */ if (!timelimit_exit) return; if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return; last_fast_cycle = start; &#125; /* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with * two exceptions: * * 1) Don't test more DBs than we have. * 2) If last time we hit the time limit, we want to scan all DBs * in this iteration, as there is work to do in some DB and we don't want * expired keys to use memory for too much time. */ if (dbs_per_call &gt; server.dbnum || timelimit_exit) dbs_per_call = server.dbnum; /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time * per iteration. Since this function gets called with a frequency of * server.hz times per second, the following is the max amount of * microseconds we can spend in this function. */ timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100; timelimit_exit = 0; if (timelimit &lt;= 0) timelimit = 1; if (type == ACTIVE_EXPIRE_CYCLE_FAST) timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */ for (j = 0; j &lt; dbs_per_call; j++) &#123; int expired; redisDb *db = server.db+(current_db % server.dbnum); /* Increment the DB now so we are sure if we run out of time * in the current DB we'll restart from the next. This allows to * distribute the time evenly across DBs. */ current_db++; /* Continue to expire if at the end of the cycle more than 25% * of the keys were expired. */ do &#123; unsigned long num, slots; long long now, ttl_sum; int ttl_samples; /* If there is nothing to expire try next DB ASAP. */ if ((num = dictSize(db-&gt;expires)) == 0) &#123; db-&gt;avg_ttl = 0; break; &#125; slots = dictSlots(db-&gt;expires); now = mstime(); /* When there are less than 1% filled slots getting random * keys is expensive, so stop here waiting for better times... * The dictionary will be resized asap. */ if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (num*100/slots &lt; 1)) break; /* The main collection cycle. Sample random keys among keys * with an expire set, checking for expired ones. */ expired = 0; ttl_sum = 0; ttl_samples = 0; if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP) num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP; while (num--) &#123; dictEntry *de; long long ttl; if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break; ttl = dictGetSignedIntegerVal(de)-now; if (activeExpireCycleTryExpire(db,de,now)) expired++; if (ttl &lt; 0) ttl = 0; ttl_sum += ttl; ttl_samples++; &#125; /* Update the average TTL stats for this database. */ if (ttl_samples) &#123; long long avg_ttl = ttl_sum/ttl_samples; if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl; /* Smooth the value averaging with the previous one. */ db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/2; &#125; /* We can't block forever here even if there are many keys to * expire. So after a given amount of milliseconds return to the * caller waiting for the other active expire cycle. */ iteration++; if ((iteration &amp; 0xf) == 0) &#123; /* check once every 16 iterations. */ long long elapsed = ustime()-start; latencyAddSampleIfNeeded("expire-cycle",elapsed/1000); if (elapsed &gt; timelimit) timelimit_exit = 1; &#125; if (timelimit_exit) return; /* We don't repeat the cycle if there are less than 25% of keys * found expired in the current DB. */ &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4); &#125;&#125; 函数中定义了全局变量current_db，记录当前函数检查的进度，并在下一个检查的时候根据该值据需上次的检查。当检查完一轮时，将该值设置为0 从上述代码可以看出，该函数还有其他一些优化和细节值的讨论 复制当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制 主服务器在删除一个过期键之后，会显式向所有从服务器发送一个DEL命令，告知从服务器删除该过期键 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，继续像处理未过期键一样处理过期键 通过主从复制模型，也就是通过主服务器控制从服务器统一删除过期键，可以保证主从服务器数据的一致性？？？这里为什么说是一致性？？明明查询从服务器上的过期键会返回该键，而不是返回nil？？ 通知客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况 通知类型分为键空间通知（这类通知关注某个键执行了什么命令）和键事件通知（这类通知关注某个命令被什么键执行） 实现通知功能的是notify.c/notifyKeyspaceEvent函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* The API provided to the rest of the Redis core is a simple function: * * notifyKeyspaceEvent(char *event, robj *key, int dbid); * * 'event' is a C string representing the event name. * 'key' is a Redis object representing the key name. * 'dbid' is the database ID where the key lives. */void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) &#123; sds chan; robj *chanobj, *eventobj; int len = -1; char buf[24]; /* If any modules are interested in events, notify the module system now. * This bypasses the notifications configuration, but the module engine * will only call event subscribers if the event type matches the types * they are interested in. */ moduleNotifyKeyspaceEvent(type, event, key, dbid); /* If notifications for this class of events are off, return ASAP. */ if (!(server.notify_keyspace_events &amp; type)) return; eventobj = createStringObject(event,strlen(event)); /* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */ if (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123; chan = sdsnewlen("__keyspace@",11); len = ll2string(buf,sizeof(buf),dbid); chan = sdscatlen(chan, buf, len); chan = sdscatlen(chan, "__:", 3); chan = sdscatsds(chan, key-&gt;ptr); chanobj = createObject(OBJ_STRING, chan); pubsubPublishMessage(chanobj, eventobj); decrRefCount(chanobj); &#125; /* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */ if (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123; chan = sdsnewlen("__keyevent@",11); if (len == -1) len = ll2string(buf,sizeof(buf),dbid); chan = sdscatlen(chan, buf, len); chan = sdscatlen(chan, "__:", 3); chan = sdscatsds(chan, eventobj-&gt;ptr); chanobj = createObject(OBJ_STRING, chan); pubsubPublishMessage(chanobj, key); decrRefCount(chanobj); &#125; decrRefCount(eventobj);&#125; 参数type指定要发送通知的类型，event、keys和dbid分别是事件的名称、产生事件的键和键对应的数据库编号 当命令需要发送数据库通知时，该命令就会调用该函数，并传递相应的参数 RDB持久化在执行SAVE或BGSAVE命令创建一个新的RDB文件时，已过期的键不会保存到该文件中 在载入RDB文件时，也会在文件中遇到过期键 如果以主服务器模式运行，过期键不会载入数据库 如果以从服务器模式运行，过期键也会被载入数据库 生成的RDB文件的两个命令的区别在于：SAVE是阻塞的，而BGSAVE会创建一个子进程，由子进程去创建RDB文件 在执行BGSAVE时，SAVE和BGSAVE会被服务器拒绝，这样做是为了避免产生竞争 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* Save the DB on disk. Return C_ERR on error, C_OK on success. */int rdbSave(char *filename, rdbSaveInfo *rsi) &#123; char tmpfile[256]; char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */ FILE *fp; rio rdb; int error = 0; snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid()); fp = fopen(tmpfile,"w"); if (!fp) &#123; char *cwdp = getcwd(cwd,MAXPATHLEN); serverLog(LL_WARNING, "Failed opening the RDB file %s (in server root dir %s) " "for saving: %s", filename, cwdp ? cwdp : "unknown", strerror(errno)); return C_ERR; &#125; rioInitWithFile(&amp;rdb,fp); if (server.rdb_save_incremental_fsync) rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES); if (rdbSaveRio(&amp;rdb,&amp;error,RDB_SAVE_NONE,rsi) == C_ERR) &#123; errno = error; goto werr; &#125; /* Make sure data will not remain on the OS's output buffers */ if (fflush(fp) == EOF) goto werr; if (fsync(fileno(fp)) == -1) goto werr; if (fclose(fp) == EOF) goto werr; /* Use RENAME to make sure the DB file is changed atomically only * if the generate DB file is ok. */ if (rename(tmpfile,filename) == -1) &#123; char *cwdp = getcwd(cwd,MAXPATHLEN); serverLog(LL_WARNING, "Error moving temp DB file %s on the final " "destination %s (in server root dir %s): %s", tmpfile, filename, cwdp ? cwdp : "unknown", strerror(errno)); unlink(tmpfile); return C_ERR; &#125; serverLog(LL_NOTICE,"DB saved on disk"); server.dirty = 0; server.lastsave = time(NULL); server.lastbgsave_status = C_OK; return C_OK;werr: serverLog(LL_WARNING,"Write error saving DB on disk: %s", strerror(errno)); fclose(fp); unlink(tmpfile); return C_ERR;&#125; 当服务器启动时，会自动检测RDB文件，并自动载入，载入过程也是阻塞的 由于BGSAVE可以在后台执行，所有通过设置一定的参数就可以让其在后台自动保存，如通过命令SAVE设置SAVE 900 1就表示数据库在900秒内，数据库至少修改1次时，就会执行BGSAVE 这些参数都保存在saveparam结构体数组中12345678struct redisServer&#123; ... struct saveparam *saveparams; /* Save points array for RDB */ long long dirty; /* Changes to DB from the last save */ time_t lastsave; /* Unix time of last successful save */ ...&#125;; dirty计数器记录距离上一次成功执行SAVE或BGSAVE命令后，服务器对数据库状态进行了多少次修改（包括写入、删除、更新等） lastsave是一个UNIX时间戳，保存上一次执行SAVE或BGSAVE命令的时间 Redis的服务器周期性操作函数serverCron默认每隔100毫秒会执行一次，其中一项工作就是遍历saveparam数组，如果符合条件就会执行SAVE或BGSAVE命令 RDB文件结构 REDIS：保存REDIS五个字符 db_version：记录RDB文件的版本号 database：保存任意多个数据库，每条记录由SELECTDB、db_number、key_value_pairs三部分组成。SELECTDB表示接下来读入的是数据库号码，当读入该号码后，服务器就会切换数据库，将接下来的键值对载入正确的数据库中 EOF：RDB文件正文结束标志 check_num：根据前面四部分计算得到的校验和，会和载入数据计算得到的校验和进行比对，检查RDB的完整性 对于key_value_pairs，TYPE指明了对象类型或底层编码，服务器根据该值决定如何读入和解释value的值。对于具有过期时间的键值对，还有两个字段，前面的EXPIRETIME_MS常量表示接下来读入的是以毫秒为单位的过期时间，ms就表示UNIX时间戳，也就是过期时间 value字段根据保存值的对象不同会有不同的结构 AOF持久化与RDB保存数据库中的键值对来记录数据库状态不同，AOF（Append Only File）通过保存Redis服务器所执行的写命令来记录数据库状态 当服务器以AOF持久化模式运行时，只有当过期键被惰性删除或定期删除之后，才会在AOF文件追加一条命名，显式记录该键被删除 由于AOF文件的更新频率比RDB高，所以在AOF持久化功能开启时，服务器会优先载入AOF文件 AOF持久化功能的实现分为命令追加、文件写入、文件同步三个步骤 当服务器执行完一个写命名后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾 服务器在一个事件循环中会调用flush44AppendOnlyFile函数，来将aof_buf缓冲区的内容写入和保存到AOF文件里面，该函数的行为有配置文件中的参数appendfsync决定，具体参见配置文件注解 对于AOF文件载入，服务器会创建一个不带网络连接的伪客户端，有其来执行AOF中的指令，使数据库恢复 为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写功能，服务器可以创建一个新的AOF文件来代替现有的AOF文件，但是新文件中不会包含冗余命令，而且保存的数据库状态相同 虽然叫AOF文件重写，但是不对现有AOF文件做任何读取、分析操作，而是直接读取当前数据库状态来完成。该功能通过aof_rewrite()函数实现 但是因为这个函数进行大量的写入操作，调用该函数的线程被长时间阻塞，所以Redis服务器将AOF重写操作放入子进程 子进程进行AOF重写，父进程（即服务器）可以继续处理命令请求 使用子进程而不是线程，因为子进程带有父进程的数据副本，可以避免使用锁的情况下，保证数据的安全性？？？ 使用子进程也会产生一个数据不一致的问题，在子进程重写AOF期间，父进程服务器接受的新的命令请求会修改数据库当前状态。为了解决这个问题，服务器设置了一个AOF重写缓冲区。在服务器创建子进程之后，这个缓冲区得到使用，也就是说在子进程重写AOF期间，服务器要将执行的命令写入AOF缓冲区和AOF重写缓冲区 当子进程完成AOF重写之后，会向父进程发送一个信号，服务器接到这个信号之后，会调用信号处理函数 将AOF重写缓冲区所有内容写入新的AOF文件 将新的AOF文件改名，原子地覆盖现有的AOF文件 父进程只有在执行信号处理函数时会造成阻塞，对命令请求的影响降到最低 事件Redis是一个事件驱动程序，需处理以下两类事件 文件事件：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象，服务器和客户端通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列的网络通信操作 时间事件：服务器的一些操作（如serverCron）需要在给定的时间点执行，时间事件就是服务器对这类定时操作的抽象 文件事件Redis使用了一个称为“A simple event-driven programming library”的自制异步事件库（以下简称“AE”，源文件为ae.c） Redis基于Reactor模型开发了自己的网络事件处理器，称为file event handler file event handler使用I/O多路复用监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器 当套接字准备好后，file event handler就会调用关联的事件处理器来处理事件 文件事件是对套接字操作的抽象。多个文件事件可能会并发出现（可想成是多个套接字准备好操作），但是I/O多路复用程序将套接字放入队列，以同步、每次一个套接字的方式向事件分派器发送套接字。只有上一个事件处理完毕，才会继续传送下一个套接字 Redis的I/O多路复用程序包装了iocp（windows），kqueue（freebsd）或是epoll（linux）等I/O多路复用函数，并实现了相同的API。在编译的时候会根据系统自动选择I/O多路复用程序的底层实现 12#define AE_READABLE 1 /* Fire when descriptor is readable. */#define AE_WRITABLE 2 /* Fire when descriptor is writable. */ 当套接字变为可读时（如客户端对套接字执行write、close操作等），就会产生相应的AE_READABLE事件 当套接字变为可写时（如客户端对套接字执行read操作），就会产生AE_WRITABLE事件 API12int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData) 该API接受一个套接字、一个事件类型（aeEventLoop）、一个事件处理器（aeFileProc），将给定套接字的给定事件类型加入到I/O多路复用程序的监听范围，并将事件和事件处理器关联 1void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask) 接受一个套接字描述符和一个监听事件类型，取消对给定套接字的给定事件的监听，并取消事件和事件处理器的关联 1int aeGetFileEvents(aeEventLoop *eventLoop, int fd) 返回套接字正在被监听的事件类型 1int aeWait(int fd, int mask, long long milliseconds) 在给定时间内阻塞并等待套接字的给定类型事件产生，事件产生或超时则返回 1static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) 在给定时间内，阻塞并等待所有设置为监听状态的套接字产生文件事件，只要产生一个或超时就返回 1int aeProcessEvents(aeEventLoop *eventLoop, int flags) 该函数就是文件事件分配器，调用aeApiPoll等待事件产生，然后遍历所有已产生事件，并调用相应的事件处理器来处理事件 事件处理器处理器源码在networking.c 连接应答处理器为了对连接服务器的各个客户端进行应答，服务器需要为监听套接字关联连接应答处理器1void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) 实质就是对套接字accept函数的包装。当服务器初始化的时候，就会将该处理器和服务器监听套接字的AE_READABLE事件关联起来 命令请求处理器1void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) 实质就是对read函数的封装。当客户端连接成功时，就会将客户端的套接字的AE_READABLE事件和命令请求处理器关联 命令回复处理器1void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) 实质是对write函数的封装。当需要命令回复传回客户端时，服务器将客户端套接字的AE_WRITABLE事件和命令回复处理器关联。当客户端套接字准备好接受时，就会产生AE_WRITABLE事件，并引发处理器执行 时间事件时间事件分为：定时事件，在指定时间执行；周期性事件，每隔指定时间执行 一个时间事件有：id（全局唯一标识符）、when（UNIX时间戳）和timeproc（时间事件处理器）组成。服务器将所有时间事件放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，找到符合条件的时间事件，并调用时间事件处理器 API123long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc) 将新的时间事件添加到服务器1static int processTimeEvents(aeEventLoop *eventLoop) 时间事件的执行器，遍历所有时间事件，并调用时间处理器来处理 Redis的serverCron函数就是一个时间事件，它定期对自身的资源和状态进行检查和调整 更新服务器数据，如时间、内存 清理过期键 关闭无效客户端 AOF或RDB持久化 集群模式时，定期同步和连接测试 事件调度1int aeProcessEvents(aeEventLoop *eventLoop, int flags) 这就是之前提到的API，也就是文件事件分派器，由它来对事件进行调度和分派 对于文件事件和时间事件的处理都是同步、有序和原子的。服务器不会中断事件处理，也不会对事件抢占。因此对于文件事件和时间事件处理器要自觉，尽量少占用阻塞时间，必要时还要主动退出 客户端通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式处理命令请求，并与多个客户端进行网络通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* With multiplexing we need to take per-client state. * Clients are taken in a liked list. */typedef struct redisClient &#123; uint64_t id; /* Client incremental unique ID. */ int fd; redisDb *db; int dictid; robj *name; /* As set by CLIENT SETNAME */ sds querybuf; size_t querybuf_peak; /* Recent (100ms or more) peak of querybuf size */ int argc; robj **argv; struct redisCommand *cmd, *lastcmd; int reqtype; int multibulklen; /* number of multi bulk arguments left to read */ long bulklen; /* length of bulk argument in multi bulk request */ list *reply; unsigned long reply_bytes; /* Tot bytes of objects in reply list */ int sentlen; /* Amount of bytes already sent in the current buffer or object being sent. */ time_t ctime; /* Client creation time */ time_t lastinteraction; /* time of the last interaction, used for timeout */ time_t obuf_soft_limit_reached_time; int flags; /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */ int authenticated; /* when requirepass is non-NULL */ int replstate; /* replication state if this is a slave */ int repldbfd; /* replication DB file descriptor */ off_t repldboff; /* replication DB file offset */ off_t repldbsize; /* replication DB file size */ long long reploff; /* replication offset if this is our master */ long long repl_ack_off; /* replication ack offset, if this is a slave */ long long repl_ack_time;/* replication ack time, if this is a slave */ char replrunid[REDIS_RUN_ID_SIZE+1]; /* master run id if this is a master */ int slave_listening_port; /* As configured with: SLAVECONF listening-port */ multiState mstate; /* MULTI/EXEC state */ blockingState bpop; /* blocking state */ list *watched_keys; /* Keys WATCHED for MULTI/EXEC CAS */ dict *pubsub_channels; /* channels a client is interested in (SUBSCRIBE) */ list *pubsub_patterns; /* patterns a client is interested in (SUBSCRIBE) */ sds peerid; /* Cached peer ID. */ /* Response buffer */ int bufpos; char buf[REDIS_REPLY_CHUNK_BYTES];&#125; redisClient; 服务器]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《存储器层次结构》]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8A%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E3%80%8B%2F</url>
    <content type="text"><![CDATA[不能太贪心！ 局部性原理是造成存储器层次结构的主因 时间局部性：某个数据项被访问之后可能很快被再次访问的特性 空间局部性：某个数据项被访问之后，其相近地址的数据项可能很快被访问的特性 存储器层次结构：一种由多存储器层次组成的结构，存储器的容量和访问时间随着离处理器距离的增加而增加。两级层次之间交换数据的最小单元称为块或行 命中率：在高层存储器中找到目标数据的存储访问比例，是存储器层级结构性能的一个衡量标准；与之相反，缺失率就是在高层存储器中没有找到数据的存储访问比例 命中时间：访问存储器层次结构中的高层存储器所需要的时间，包括了判断是否命中的时间 缺失代价：将相应的块从低层存储器替换到高层存储器所需的时间，包括访问块、将数据逐层传输、将数据插入发生缺失的层和将信息块传递给请求者的时间 存储器层次结构这个概念将会影响OS如何管理存储器和I/O、编译器如何产生代码、应用程序如何使用计算机等等 目前构造存储器层次结构主要有4种技术：DRAM、SRAM、闪存和磁盘 cache原理评估虚拟机虚拟存储器并行与cache]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构与对象》]]></title>
    <url>%2F2019%2F03%2F04%2FRedis%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[五种对象（字符串对象、列表对象、哈希对象、集合对象、有序集合对象）的底层数据结构以及对对象的性能和功能的影响，也趁机复习一下数据结构 由于Redis使用的是C语言，很多其他高级语言有的数据结构，都要Redis自己实现，因此在分析Redis原理时，自然就要碰到常见的数据结构 简单动态字符串Redis没有直接使用C语言的传统的字符串表示（即以空字符结尾的字符数组），而是自己构建了名为简单动态字符串（simple dynamic string，SDS）的抽象类型，除了作为Redis的默认字符串表示，还被用作缓冲区：AOF模块的AOF缓冲区以及客户端状态中的输入缓冲区 1redis&gt;RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot; 上述语句就会创建键值对，键是一个字符串对象，底层实现就是SDS，值是一个列表对象，包含三个字符串对象，也是SDS实现 12345struct sdshdr &#123; unsigned int len; unsigned int free; char buf[];&#125;; len：记录SDS保存字符串长度 free：数组未使用字节长度 为什么要记录未使用空间呢？ 与C字符串的区别C获取字符串长度需要O(N)复杂度，而SDS获取长度只要O(1)，因此获取字符串长度不会成为Redis的瓶颈，可以通过STRLEN获取字符串长度 SDS能防止缓冲区溢出。例如对于C的char *strcat(char *dest,char *src);函数，默认用户已经为dest分配了足够的内存，如果假设不成立，就会产生缓冲区溢出 而SDS的空间分配策略杜绝了发生缓冲区的可能性。当SDS API需要对SDS进行修改，会先检查SDS的空间是否满足需求。如果不满足，会自动扩展1s = sdsMakeRoomFor(s,len); 但是SDS的分配策略不是只分配缺少的空间，会多分配一些 内存分配策略对于C语言的字符串，只要涉及字符串长度，就要进行一次内存重分配操作 对于append等增长字符串操作，就需要扩展底层数据的空间大小，否则就有可能发生缓冲区溢出 对于trim等缩短字符串长度操作，就需要释放内存空间，否则就会发生内存泄漏 对于内存重分配，可能需要调用系统调用，这是一种代价很高的执行。 对于Redis这种数据频繁修改的场合，如果每修改一次字符串，都要执行内存重分配，那势必对性能造成影响。当这个地方我们就能回答最开始的问题 为什么要记录未使用空间呢？。 SDS通过记录未使用空间接触字符串长度和底层数组长度之间的关系。字符串长度增加不一定意味着底层数组增加，也就意味着不需要频繁调用内存重分配 空间预分配额外分配的空间数量根据下面的代码段决定12345678910111213141516171819202122#define SDS_MAX_PREALLOC (1024*1024)sds sdsMakeRoomFor(sds s, size_t addlen) &#123; ... if (free &gt;= addlen) return s; len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); newlen = (len+addlen); if (newlen &lt; SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); if (newsh == NULL) return NULL; newsh-&gt;free = newlen - len; return newsh-&gt;buf;&#125; 从上面的代码可以看出，如果增加后的长度（newlen）小于1MB，则新长度翻倍；如果大于1MB，则只增加1MB 惰性空间释放当需要缩短字符串时，程序不会立即使用内存重分配来回收多出来额度字节，而是使用free属性来记录多出来的空间。虽然这样做可以减少重分配操作，但另一方面也是浪费空间。因此SDS提供相应API能直接释放未使用的空间 二进制安全C字符串除了字符串末尾，不能包含空字符，否则会误读，这就意味着C字符串只能保存文本数据，不能保存图片、音频、视频等二进制数据 而SDS API都是以处理二进制的方式处理存放在buf数组里的数据程序不会对其中的数据做任何限制、过滤或假设。写入时什么样，读取时就是什么样。因为SDS使用len值而不是空字符来判断结尾。这使得Redis能保存任意格式的二进制 虽然SDS不以空字符作为判断条件，但这些API依旧会将SDS保存的数据结尾设置为空字符，并在分配空间时多分配一个字节来容纳空字符，目的就是为了能重用&lt;string.h&gt;中的函数，减少不必要的代码重复 链表链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且通过增删节点灵活调整链表长度 链表除了在列表键应用外，还在发布于订阅、慢查询、监视器等功能应用，服务器本身还使用链表来保存多个客户端的状态信息以及构造客户端输出缓冲区 当一个列表键包含数量较多的元素时，或者列表中包含的元素都是较长的字符串时，就会使用链表作为列表键的底层实现 Redis服务器本身使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输缓冲区 链表的实现应该不是难题，来看看高手们的代码adlist.h 链表节点的定义12345typedef struct listNode &#123; struct listNode *prev; struct listNode *next; void *value;&#125; listNode; 把节点封装成list1234567891011121314typedef struct list &#123; listNode *head; listNode *tail; void *(*dup)(void *ptr);//节点值复制函数 void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len;&#125; list; 构造链表函数1234567891011121314list *listCreate(void)&#123; struct list *list; if ((list = zmalloc(sizeof(*list))) == NULL) return NULL; list-&gt;head = list-&gt;tail = NULL; list-&gt;len = 0; list-&gt;dup = NULL; list-&gt;free = NULL; list-&gt;match = NULL; return list;&#125; Redis的实现特性 双向链表，获取前驱节点和后驱节点的复杂度都是O(1) 无环链表，表头和表尾都指向NULL，对链表的访问以NULL为终点 带有指向表头和表尾的指针，获取复杂度为O(1) 链表长度计数器 多态，节点都是使用void *保存节点值，因此列表可以保存不同类型的值 题外话：事实上，C语言通过某种组合方式，可以间接性的实现面对对象和抽象，就像Redis实现链表所做的那样 字典Redis数据库就是用字典实现的，哈希键也是通过字典实现 Redis字典所使用哈希表的实现在dirt.h中123456typedef struct dictht &#123; dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;&#125; dictht; table属性就是一个数组，数组中的元素都是指向dictEntry结构的指针，sizemask总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上 123456789101112typedef struct dictEntry &#123; void *key; union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; struct dictEntry *next;&#125; dictEntry; 值的定义再一次体现了C语言也能实现类似于多态的性质 next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决collision Redis字典定义123456789101112typedef struct dict &#123; dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ int iterators; /* number of iterators currently running */&#125; dict; type属性是一个指向dictType结构的指针，每个dictType保存一簇用于操作特定类型键值对的函数，Redis会为不同用途的字典设置不同的类型特定函数？？privdata属性保存需要传给那些类型特定函数的可选参数 上述两个属性为了创建多态字典而设置 ht属性是一个包含两个项的数组，每个元素是一个dictht哈希表，字典一般只是用ht[0]哈希表，ht[1]作为rehash使用 rehashidx记录rehash的进度，如果没有进行rehash，值为-1？？？ 哈希算法程序需要根据键值对计算出哈希值和索引值，再根据索引值，将包含键值对的哈希表节点放到哈希表数组的指定索引上，如下所示，使用的是宏定义1#define dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key) Redis使用MurmurHash2作为计算键的哈希值的算法，但是在最新的版本中使用SipHash Redis的哈希表直接使用链地址法解决Collision，也就是使用next指针连接键冲突的键值对 rehash为了让哈希表的负载因子（负载因子=ht[0].used/ht[0].size）维持在一个合理的范围，当哈希表保存的键值对数量太多或太少是，就需要对哈希表的大小进行扩展或收缩 首先给ht[1]分配空间，如果是扩展，ht[1].size = 大于等于ht[0].used两倍的第一个2的幂，如果是收缩，ht[1].size = 大于等于ht[0].used的第一个2的幂 将ht[0]键值对rehash到ht[1] 释放ht[0] 当出现下面两种情况时，会自动开始对哈希表进行扩展 服务器没有执行BGSAVE（在后台异步保存当前数据库的数据到磁盘）或BGREWRITEAOF（异步执行一个 AOF文件重写操作），且负载因子大于等于1 服务器在执行BGSAVE或BGREWRITEAOF，且负载因子大于等于5 而当负载因子小于0.1时，会自动进行收缩操作 Performs N steps of incremental rehashing. Returns 1 if there are still keys to move from the old to the new hash table, otherwise 0 is returned. 上述表明服务器不是一次性将ht[0]rehash到ht[1]，而是分多次、渐进式rehash。这就是前面提到的rehashidx的作用，当开始rehash时，rehashidx设置为0，在rehash期间，每次对字典执行添加、删除、查找或更新操作时，程序除了执行指定操作时，还会顺带将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]，当rehash完成，rehashidx加一，当所有rehash完成，rehashidx设置为-1 上述rehash方式将计算工作平摊到对字典的操作中，避免集中式rehash带来的系统停顿等后果。在渐进式rehash中，对字典的操作会在两个哈希表中进行 跳跃表跳跃表作为有序集合键的底层实现之一，还作为集群节点中的内部数据结构，如下所示 Redis的跳跃表在server.h/zskiplistNode和server.h/zskiplist，zskiplistNode定义跳跃表节点，zskiplist保存跳跃表节点的信息，如节点数量等 12345678910111213141516/* ZSETs use a specialized version of Skiplists */typedef struct zskiplistNode &#123; sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel &#123; struct zskiplistNode *forward; unsigned long span; &#125; level[];&#125; zskiplistNode;typedef struct zskiplist &#123; struct zskiplistNode *header, *tail; unsigned long length; int level;&#125; zskiplist; 先跳过！！等学一下跳跃表！！ 整数集合当集合只包含整数值元素，并且数量不多时，就会使用整数集合（intset）作为集合键的底层实现 12345typedef struct intset &#123; uint32_t encoding; uint32_t length; int8_t contents[];&#125; intset; 集合的元素按照从小到大的顺序无重复的放在contents数组里，虽然数组定义为int8_t，但是真正保存的类型取决于encoding：INISET_ENC_INT16 INISET_ENC_INT32 INISET_ENC_INT64 每当添加到集合的新元素比现有所有元素的类型都要长时，就要进行升级 根据新元素类型，扩展底层数组的空间大小 将现有元素转换成新元素的类型 添加新元素 因为新添加的元素肯定小于或者大于现有所有元素，因此新元素要么放在底层数组的开头要么放在最末尾 由于C是静态类型语言，应该避免将不同类型的数组放在同一个数据结构中。但有了升级，就能随意将不同类型添加到集合中，而不用担心类型出错。另外就是节约内存 压缩列表是列表键和哈希键的底层实现之一，当列表或者哈希键包含小整数值或者短字符串时，就会使用压缩列表 压缩列表是为了节约内存而开发，是由一系列特殊编码的连续内存块组成的顺序性数据结构，其形式有点类似于数据库的行记录格式 zlbytes：整个压缩列表占用的字节数 zltail：列表尾节点到头结点的偏移量 zllen：节点数量 entryX：节点 zlend：特殊值0xFF，表示列表末尾 每个节点由previous_entry_length encoding content三部分组成 previous_entry_length：当前一个节点的长度小于254字节，该属性长度只有1字节；如果大于等于254字节，该属性就有5字节，其中第一个字节设置为0xFE，后面的字节实际保存前一个节点的长度，例如0xFE00002766，实际长度就是0x0000002766。通过该属性和指针运算，就可以实现从表尾向表头遍历操作 encoding：记录节点content保存的数据的类型及长度，编码的开头两位表示类型，例如11表示整数编码，00 01 10表示字节数组编码，其余字节均表示长度。例如11000000表示int16_t类型整数，00bbbbbb长度小于63字节的字节数组 content：保存节点的值 连锁更新该现象的出现就是因为previous_entry_length属性，如果每个节点的长度都接近254字节，当插入一个大于254字节的节点时，就会引起这个现象 虽然连锁更新的最坏复杂度为$O(N^2)$，但是发生的几率很低，因此不会影响性能 可能导致连锁更新的APIziplistPush ziplistInsert ziplistDelete ziplistDeleteRange 对象Redis使用上面这些数据结构，构造了一个对象系统，这个系统就包含了字符串对象、列表对象、哈希对象、集合对象、有序集合对象五类对象 通过对象 可以判断一个对象是否可以执行给定的命令 可以针对不同的使用场景，对对象设置多种不同的实现，从而优化效率 实现了基于引用计数的内存回收机制，并基于引用计数实现了对象共享机制 对象带有访问时间记录信息 当我们在Redis数据库创建键值对时，至少会创建两个对象，一个对象作为键值对的键，一个作为键值对的值。每个对象都是由以下结构体表示1234567891011// server.htypedef struct redisObject &#123; unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr;&#125; robj; 第一个属性记录对象的类型，可以是REDIS_STRING REDIS_LIST REDIS_HASH REDIS_SET REDIS_ZSET五种类型常量，对于Redis数据库的键值对来说，键总是一个字符串对象，值则可以是多种类型 对象中有一个ptr指针属性，它指向对象的底层实现数据结构，而encoding属性则指明对象使用数据结构的类型，如REDIS_ENCODING_INT REDIS_ENCODING_EMBSTR REDIS_ENCODING_HT等，它对于用户来说是不可见的。用户只能看到上述五种对象类型，而使用哪种数据结构来实现对象，则由服务器自主决定从上图我们还看到了一个新的数据结构quicklist去取代ziplist 通过encoding属性设定对象使用的编码（即底层实现），使得Redis可以根据不同的场景来实现对象，从而优化在该场景下的使用效率 字符串对象字符串对象的底层编码可以是int、raw（简单动态字符串）和embstr（embstr编码的简单动态字符串） 如果字符串对象保存的是整数值，就可以用一个指向long类型的指针保存到ptr属性中 下图就是使用sdshdr作为底层数据结构实现，且是raw作为编码方式的字符串对象，这种方式就如图中所示，将调用两次内存分配函数来创建两个结构体 另一种也是使用sdshdr作为底层数据结构的字符串对象表示是embstr编码的，如下图所示，这种方式只需要调用一次内存分配函数 对于long double类型的浮点数在Redis中也是作为字符串表示，在有需要的时候转换成浮点数值，去做计算 在某些情况下，int和embstr编码的字符串对象就会转换成raw编码的字符串对象，如为int值后追加一个字符串时，就会从int编码转换成raw编码 列表对象哈希对象集合对象有序集合对象类型检查与多态Redis上的命令分为两种，一种是对任何类型的键都执行，如DEL、EXPIRE、RENAME等；另一种就是只能针对特定类型的键执行 为了确保命令和输出键的类型相对应，服务器就需要通过对象中的type属性去检查，如果不符合就会返回类型错误信息 如果类型正确，还需要根据对象的编码方式（即encoding属性），选择合适的API去执行响应的命令 内存回收Redis在自己的对象系统中构建了一个引用计数计数实现的内存回收机制，通过该机制就能自动释放对象并回收内存 对象共享上面提到的refcount属性还带有对象共享的作用 每个对象的引用计数信息就记录在refcount属性中。当不同的键指向完全相同的对象时，就不会重新创建一个对象，而是选择共享，并在对象的refcount值+1。这种机制对于节约内存显然很有帮助 在这个基础上，Redis在初始化时，就会创建一万个字符串对象，包含0-9999的所有整数值，当服务器需要这些字符串对象时，就会选择共享对象，而不是新创建对象 但在实际操作中，这种现象好像消失了？？？ 这些共享对象不仅只有字符串键可以使用，嵌套了字符串对象的对象都可以使用这些共享对象 由于将共享对象设置为键的值对象时，要检查共享对象和目的对象的完全一致性，对于复杂的共享对象，检查的复杂度就会很高，例如如果共享对象是保存整数值字符串对象，检查复杂度为O(1)；如果是保存字符串的字符串对象，复杂度为O(N)；如果是多个对象的对象，复杂度就是达到O(N^2)。因此Redis只选择对包含整数值的字符串进行共享 对象空转对象的最后一个属性lru，记录对象最后一次被命令访问的时间，可使用OBJECT IDLETIME命令查看空转时长，但是该命令不会改变lru属性的值 该属性的另一个作用是服务器占用的内存超过了设置参数的上限，空转时长较高的那部分键会被优先被服务器释放掉，从而回收内存 quicklist]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器无关优化》]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8A%E6%9C%BA%E5%99%A8%E6%97%A0%E5%85%B3%E4%BC%98%E5%8C%96%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《代码生成》]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8A%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《运行时刻环境》]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《中间代码生成》]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8A%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《语法制导的翻译》]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8A%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《语法分析》]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《词法分析》]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全与锁优化]]></title>
    <url>%2F2019%2F03%2F02%2FJVM%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本章介绍JVM如何实现高效，和上一章对应 线程安全：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果 线程安全根据线程安全，数据分为5类： 不可变：immutable 、final的基本类型变量或者对象的变量全部是final，如String、Integer、枚举类型和Number的部分子类（Long、Double） 绝对线程安全：一个类要达到不管运行时环境如何，调用者都不需要任何额外的同步措施，才能称为绝对线程安全。但是Java API中标记自己是线程安全的类，其实都不是绝对的线程安全 相对线程安全：这是我们通常意义上的线程安全，他需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施，但在一些特定顺序的连续调用时，就需要额外的同步手段来保证安全，如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等 线程兼容：对象本身不是线程安全的，但是可以通过正确使用同步手段来保证对象在并发环境中可以安全使用，Java API大部分类都是线程不安全的，如ArrayList和HashMap 线程对立：无论是否采取同步措施，都无法在多线程环境下并发使用的代码 线程安全既需要代码编写帮助，也需要JVM线程安全手段的帮助 互斥同步同步就是多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，而互斥是实现同步的一种手段。临界区、互斥量和信号量都是主要的互斥实现方式 最基本的互斥同步手段就是synchronize，该关键词经过编译会在同步块的前后形成monitorenter和monitorexit两个字节码，这两个字节码需要一个reference类型的参数指明要锁定和解锁的对象。执行monitorenter时，会获取该对象的锁，并计数+1，执行monitorexit时，计数-1，并释放锁。如果获取锁失败，则当前线程要阻塞等待，直到锁被其他线程释放 synchronize同步块对于同一个线程是可重入的；而且同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。由于Java线程和OS原生线程一一对应，阻塞或者唤醒进程就需要OS从用户态切换到内核态，这需要很大的代价，因此对于简单得多同步块，使用synchronize就没有必要 java.util.concurrent中的重入锁（ReentrantLock）也能实现同步，相比synchronize，它是表现为API层面的互斥锁，而synchronize表现为原生语法层面的互斥锁，除此之外，还有三项高级功能 等待可中断：对持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，这对于执行时间非常长的同步块有帮助 可实现公平锁：多个线程在等待同一个锁的时候，必须按照申请锁的时间顺序来一次获取锁 锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象6 非阻塞同步互斥同步因为进行线程阻塞和唤醒的所带来的性能问题，而称为阻塞同步。这次是一种悲观的并发策略，总是认为只要不去做正确的同步措施，就肯定会出现问题，无论共享数据是否出现竞争，都要进行加锁。随着硬件指令集的发展，有了另一种选择：基于冲突检测的乐观并发策略，就是先进行操作，如果没有竞争共享数据，那操作就成功了；如果出现竞争，就要采取其他补偿措施。这种策略不需要把线程挂起，因此称为非阻塞同步 这种策略需要操作和冲突检测都具备原子性，这就要硬件支持，一些看起来要多次操作的行为只要一条处理器指令就能完成 测试并设置 获取并增加 交换 比较并交换（CAS） 加载链接/条件存储 无同步方案如果一个方法本来就不涉及共享数据，这些代码天生就是线程安全的，如下面两类 可重入代码：可以在代码执行的任何时刻中断它，转而去执行另一端代码，而在控制权返回后，原来的程序不会出现任何错误。这种代码不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数传入、不调用非可重入的方法。判断原则：该方法的返回结果可以预测，只要输入相同的数据，都能返回相同的结果 线程本地存储：尝试把共享数据放在同一个线程中执行，让共享数据的可见范围限制在同一个线程之内，这样就不需要同步。如果希望每个线程单独拥有一个全局或静态变量，所有线程都可以使用它，但是在每个线程中是单独存储的，那么就需要使用线程本地存储？？ 锁优化这些技术都是为了在线程之间更搞笑的共享数据，以及解决竞争问题 自旋锁和自适应自旋共享数据的锁定位置只会持续很短的时间，为了这段时间去挂起和恢复线程并不值得，因此可以让后面请求锁的那个线程等待一下，而不是挂起，看看持有锁的线程是否很快释放锁，为了让线程等待，只需要让线程执行一个忙循环（自旋） 自旋等待不能代替阻塞，因为虽然自旋本身避免了线程切换的开销，但它是要占用CPU时间的，因此如果锁被占用的时间很长，自旋反而浪费处理器资源，所以自旋超过一定次数就会挂起线程，默认次数是10次 自适应则意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定 锁消除JIT在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁，会进行消除。主要判定依据来源于逃逸分析的数据支持，如果判断一段代码中，堆上的所有数据都不会逃逸出去从而不会被其他线程访问到，就能当做栈上数据对待，认为是线程私有的 锁粗化原则上，要将同步块的作用范围限制的尽量小，这样等待锁的线程就能尽快拿到锁。但是如果加锁操作出现在循环体中，那即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗，因此JVM会探测到这样的操作，将加锁同步的范围粗化到整个操作序列的外部 轻量级锁传统的锁机制称为重量级锁。轻量级锁的本意是在没有多线程竞争的前提下，减少传统的重量级锁的性能消耗 在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头 Mark Word：这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位，这是实现轻量级锁的偏向锁的关键 class pointer：这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位 如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度 Mark Word存储内容的含义 对象哈希码、对象分布年龄：标志位01，未锁定 指向锁记录的指针：标志位00，轻量级锁定 指向重量级锁的指针：标志位10，重量级锁定 偏向线程ID、偏向时间戳、对象分代年龄：标志位01，可偏向 无：标志位11，GC标记 ？？？？ 轻量级锁能提升性能的依据：对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁使用CAS操作避免使用互斥量的开销 偏向锁消除数据在无竞争情况下的同步原语，偏的意思就是这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要进行同步]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存模型与线程]]></title>
    <url>%2F2019%2F03%2F02%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[并发处理的广泛应用是使得Amdahl定律代替摩尔定律的根本原因，成为了压榨计算机的新武器。本章介绍JVM如何实现并发 由于计算机的存储设备与处理器的运算速度有几个数量级的差距，因此现代计算机不得不加入高速缓存（Cache，二级缓存）来作为内存和处理器之间的缓冲 在多处理器系统中，每个处理器都有自己的高速缓存，这就引入新的问题：缓存一致性，因此处理器访问缓存时需要遵循一些协议。JVM内部的虚拟机缓存操作和硬件的模型具有很高的可比性 内存模型Java虚拟机规范中定义的Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异，而像C/C++直接使用物理硬件和操作系统的内存模型，这会因为不同平台上内存模型的差异而导致代码不能跨平台 在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信” 其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JMM是和多线程相关的，他描述了一组规则或规范，可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字 JMM的目的是定义程序中各个变量（实例字段、静态字段等）的访问规则。JMM规定了所有变量都存储在主内存中，每条线程都有自己的工作内存（类似于上图中的Cache） 工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量所有操作都在工作内存完成，而不是直接读写主内存。线程之间变量的传递需要通过主内存完成 Java内存模型看上去和JVM内存结构差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所为。其实两者不是同一层次的内存划分。如果非要对应起来，主内存主要对应于Java堆的对象实例数据部分，工作内存对应于栈中的部分区域 为了实现主存和工作内存之间的交互协议，JMM定义了以下8种操作，JVM实现时必须保证每种操作都是原子的、不可分的 lock：把变量标志为一条线程独占的状态 unlock：释放处于锁定状态的变量 read：把一个变量的值从主内存传输到线程得到工作内存中，以便load使用，这一步目标主要是读取 load：把read得到的变量值放入工作内存的变量副本，这一步主要是载入 use：把工作内存中的变量值传递给执行引擎，每当JVM遇到需要变量的字节码指令时都会执行这个动作 assign：把执行引擎接受到的值赋给工作内存的变量，每当JVM遇到给变量赋值的字节码指令时都会执行这个动作 store：把工作内存的变量传递到主内存中，以便write使用 write：把store得到的变量的值放入主内存的变量中 除此之外8个操作还需满足以下规则，这8个操作和规则确定了Java程序中哪些内存访问操作在并发下是安全的 不允许read和load、store和write操作单独出现，即不允许一个变量从主内存读取了但工作内存不接受，也不允许从工作内存写回但主内存不接受的情况 一个线程如果有assign操作，则其后必须出现store和write操作，反之不能出现。改变变量必须回存 新变量只能生灭于主内存，use和store变量前，必须有对应的load或assign该变量的操作 一个变量同一时刻最多允许被一个线程对其lock，同一线程可对这个变量进行多次lock，执行同样次数的unlock才能完全解锁 lock变量时，会清空工作内存中变量副本的值，执行引擎使用前需重新load或assign 没有lock的变量不允许unlock 执行unlock前必须回存至主内存，即store和write 被volatile定义的变量，对所有线程都是可见的。这意味着当一条线程修改了一个变量的值，新值对于其他线程来说是可以立即得知的，而普通变量的值需要通过主内存才能在线程之间传递。但其实volatile变量其实在工作内存也存在不一致的问题，只是因为在每次使用前都会先刷新，执行引擎看不到不一致的情况 volatile变量只能保证可见性，不能保证在并发下是安全的，当不满足下面两个条件时，要使用加锁来保证原子性 运算结果不依赖变量当前值，或者能够确保只有单一的线程修改变量 变量不需要与其他状态变量共同参与不变约束 其次，volatile变量禁止指令重新排序优化。volatile通过内存屏障实现，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由JVM来生成内存屏障的指令（如插入Lock addl $Ox0，(%esp)），通过强制处理器顺序执行待定的内存操作来避免这个问题 内存屏障有两个作用： 阻止屏障两侧的指令重排序。指令把修改同步到内存中，意味着所有之前的操作都已经执行完成，便形成了无法越过内存屏障的效果 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效，这相当于volatile变量的修改对其他CPU可见 1234567891011121314// code run by first thread intentFirst = true; while (intentSecond) if (turn != 0) &#123; intentFirst = false; while (turn != 0) &#123;&#125; intentFirst = true; &#125; criticalSection(); turn = 1; intentFirst = false; 上述的intentFirst变量由于没有volatile，存在被乱序执行的可能，所以第13、14行可能先执行，这就对导致程序就会错误执行 JMM对volatile变量定义了特殊规则 线程T对变量V执行use之前必须执行load，相反执行load之前必须先执行use。这保证在使用V之前都从主内存刷新最新的值 线程T对变量V执行store之前必须执行assign，相反执行assign之前必须先执行store。这保证修改V之后都能立即同步到主内存 JMM允许将没有volatile修饰的64位数据的读写操作分为两次32位的操作进行，这就可能读到半个变量的值。不过JVM几乎都会选择把64位读写作为原子操作，因此不需特意把64位数据申明为volatile 总结Java内存模型是围绕在并发过程中如何处理原子性、可见性、有序性而建立的 原子性：read、load、assign、use、store、write操作保证了原子性变量操作，因此大致可认为基本数据类型都是具备原子性的，当遇到比基本数据类型更大的原子性保证时，还有lock、unlock保证，这反映到更高层次就是字节码指令monitorenter和monitorexit，进而反映到Java代码就是synchronize，因此在该关键字块之间的操作也具备原子性 可见性：上面讲过volatile实现了可见性，普通变量和volatile变量的区别在于，volatile的特殊规则保证了新值立即同步到主内存中，以及每次使用前立即从主内存刷新，普通变量则不能保证这一点；除此之外，synchronize也能保证可见性，因为规则：对一个变量执行unlock之前，必须把变量同步回主内存中；final变量保证可见性的规则：final 常量无需同步,就能被其它线程正确访问 有序性：Java有序性：如果在本线程内观察，所有操作都是有序的；但是如果从一个线程观察另一个线程，所有操作都是无序的。造成后半句的原因就是指令重排序和工作内存与主内存同步延迟。volatile本身包含禁止指令重排序的含义，synchronize则是：一个变量再同一时刻只允许一条线程对齐进行lock操作 先行发生原则该规则是判断数据是否存在竞争、线程是否安全的主要依据，依靠该原则和几条规则，就能解决并发环境下两个操作之间是否可能存在冲突的所有问题 先行发生是JMM定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，就是说操作B发生之前，操作A产生的影响（修改内存中共享变量的值、发送了信息、调用了方法等）能被操作B观察到 下面的规则是JMM天然存在的先行发生关系，如果两个操作之前的关系不在下面规则中，就没有顺序保障，虚拟机可以随意重排序 程序次序规则：在一个线程内，按照程序控制流顺序，书写在前面的操作先行发生在书写后的操作 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作 volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作 线程启动规则：Thread对象的start()方法先行发生于线程的每个动作 线程终止规则：线程所有操作都先行发生于此线程的终止检测 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 对象终结规则：一个对象初始化完成先行发生于它的finalize()方法的开始 传递性：操作之间的先行关系存在传递关系 时间先后顺序和先行发生原则之间没有关系，衡量并发安全问题的时候一切以先行发生原则为准 线程线程是比进程更轻量级的调度执行单位，是CPU调度的基本单位。每个已经执行start()且未结束的java.lang.Thread类都是一个线程实例，该类的关键方法都是Native，这意味着这个方法没有使用或无法使用平台无关的手段实现 实现线程有三种方法：使用内核线程实现、使用用户线程和使用用户线程加轻量级进程混合实现 内核线程Kernel-Level Thread（KLT）就是直接由Kernel支持的线程，由其完成线程切换，Kernel通过Scheduler对线程进行调度，并负责将线程的任务映射到各个处理器上 一般应用程序不会直接使用内核线程，而是使用内核线程的一个高级接口：轻量级进程（Light Weight Process，LWP，即线程），这种轻量级进行和内核线程是一对一的线程模型 这种实现方式由于是基于内核线程实现，各种线程操作都需要进行系统调用，而系统调用代价较高，需要在用户态和内核态切换，其次每个轻量级进程都要一个内核线程支持，因此就需要消耗内核资源，导致支持的进程数量有限 用户线程狭义上的用户线程完全建立在用户空间的线程库上，系统内核不能感知其存在。用户线程的建立、同步、销毁和调度完全在用户态上完成，不需要切换到内核态，因此消耗低，还支持规模更大的线程数量，这种模型成为一对多线程模型这种模型的弊端就是所有线程操作都要用户程序自己处理，而且不能发挥多处理器的用处 用户+进程在这种混合模式下，既存在用户线程，也存在轻量级进程，在这种模式下，用户线程和轻量级进程的数量比不一定，成为多对多线程模型。Unix系列的OS都提供N：M线程模型的实现 Java线程在JDK 1.2中，线程模型替换为基于OS原生线程模型来实现，因此OS支持怎样的线程模型，就决定了JVM的线程是怎么映射的 对于Sun JDK来说，Windows版和Linux版都是使用一对一线程模型实现的 线程调度是指系统为线程分配处理器使用权的过程，分为协同式线程调度和抢占式线程调度。协同式调度就是由线程本身控制，抢占式调度每个线程由系统来分配执行时间。具体可以参考OS文章 我们可以通过设置线程优先级来建议系统给某些线程多分配一些时间。Java中就设置了10个优先级。但是Java的线程是通过映射到系统的原生线程上来实现的，最终调度依旧取决于OS，因此不见得从OS的优先级和Java优先级存在一一对应的关系 Java定义了5种线程状态 新建：创建后尚未启动的线程 运行：此状态的线程有可能正在执行，有可能正在等待CPU分配时间 无限期等待：不会被分配CPU执行时间，要等待被其他线程显示唤醒，没有设置Timeout的Object.wait()方法和Thread.join()方法、LockSupport.park()方法都会使线程入此状态 限期等待：不会被分配CPU执行时间，但在一定时间后会被系统自动唤醒，如Thread.sleep()、设置Timeout的Object.wait()方法和Thread.join()方法、LockSupport.parkNanos()等 阻塞：阻塞和等待状态的区别在于，阻塞状态在等待获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis设计与实现》]]></title>
    <url>%2F2019%2F03%2F02%2FRedis%EF%BC%9A%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[希望有朝一日能参与到开源中！ 其实Redis很简单，就是充当缓存的作用， 不能替代MySQL(及其它)数据库。 做个比喻： 数据库就相当于硬盘，Redis就相当于内存， 在Redis里读写数据更快。 Redis一般作为中间件，服务将数据缓存到Redis里， 但必须要注意跟数据库的同步问题！！！ 中间件的概念其实就是《NoSQL精粹》中讲到的混合持久化。原则：先在Redis里查，如果查不到再去数据库查， 并保持结果到Redis里 源码结构对Redis的源代码进行了整体分类 test memtest.c 内存检测 redis_benchmark.c 用于redis性能测试的实现 redis_check_aof.c 用于更新日志检查的实现 redis_check_dump.c 用于本地数据库检查的实现 testhelp.c 一个C风格的小型测试框架 struct adlist.c 用于对list的定义，它是个双向链表结构 dict.c 主要对于内存中的hash进行管理 sds.c 用于对字符串的定义 sparkline.c 一个拥有sample列表的序列 t_hash.c hash在Server/Client中的应答操作。主要通过redisObject进行类型转换 t_list.c list在Server/Client中的应答操作。主要通过redisObject进行类型转换 t_set.c set在Server/Client中的应答操作。主要通过redisObject进行类型转换 t_string.c string在Server/Client中的应答操作。主要通过redisObject进行类型转换 t_zset.c zset在Server/Client中的应答操作。主要通过redisObject进行类型转换 ziplist.c ziplist是一个类似于list的存储对象。它的原理类似于zipmap zipmap.c zipmap是一个类似于hash的存储对象 data aof.c AppendOnly File，作用就是记录每次的写操作,在遇到断电等问题时可以用它来恢复数据库状态 config.c 用于将配置文件redis.conf文件中的配置读取出来的属性通过程序放到server对象中 db.c对于Redis内存数据库的相关操作 multi.c用于事务处理操作 rdb.c 对于Redis本地数据库的相关操作，默认文件是dump.rdb（通过配置文件获得），包括的操作包括保存，移除，查询等等 replication.c 用于主从数据库的复制操作的实现 tool bitops.c 位操作相关类 debug.c 用于调试时使用 endianconv.c 高低位转换，不同系统，高低位顺序不同 help.h 辅助于命令的提示信息 lzf_c.c 压缩算法系列 lzf_d.c 压缩算法系列 rand.c用于产生随机数 release.c 用于发步时使用 sha1.csha加密算法的实现 util.c 通用工具方法 crc64.c 循环冗余校验 event ae.c 用于Redis的事件处理，包括句柄事件和超时事件。 ae_epoll.c实现了epoll系统调用的接口 ae_evport.c 实现了evport系统调用的接口 ae_kqueue.c 实现了kqueuex系统调用的接口 ae_select.c 实现了select系统调用的接口 baseinfo asciilogo.c redis的logo显示 version.h有Redis的版本号 compatible fmacros.h 兼容Mac系统下的问题 solarisfixes.h 兼容solary下的问题 main redis.c redis服务端程序 redis_cli.c redis客户端程序 net anet.c 作为Server/Client通信的基础封装 networking.c 网络协议传输方法定义相关的都放在这个文件里面了 wrapper bio.c background I/O的意思，开启后台线程用的 hyperloglog.c 一种日志类型的 intset.c 整数范围内的使用set，并包含相关set操作 latency.c 延迟类 migrate.c 命令迁移类，包括命令的还原迁移等 notify.c 通知类 object.c 用于创建和释放redisObject对象 pqsort.c 排序算法类 pubsub.c 用于订阅模式的实现，有点类似于Client广播发送的方式 rio.c redis定义的一个I/O类 slowlog.c 一种日志类型的，与hyperloglog.c类似 sort.c 排序算法类，与pqsort.c使用的场景不同 syncio.c 用于同步Socket和文件I/O操作。 zmalloc.c 关于Redis的内存分配的封装实现 others scripting.c sentinel.c setproctitle.c valgrind.sh redisassert.h 基本命令Redis中文网 目录 《数据结构与对象》：数据库键总是一个字符串对象，但是值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象，本章剖析这五种对象的底层数据结构以及对对象的性能和功能的影响 《单机数据库》：对实现原理、持久化、事件、客户端、服务器等方面做了讲解 《多机数据库的实现》：对赋值、Sentinel、集群三个多机功能进行了介绍 《独立功能的实现》：对发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器进行了讲解]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《长期中的真实经济》]]></title>
    <url>%2F2019%2F03%2F02%2F%E3%80%8A%E9%95%BF%E6%9C%9F%E4%B8%AD%E7%9A%84%E7%9C%9F%E5%AE%9E%E7%BB%8F%E6%B5%8E%E3%80%8B%2F</url>
    <content type="text"><![CDATA[描述长期中决定关键真实变量（GDP增长、储蓄、投资、真实利率和失业）的力量 生产与增长 考察人均真实GDP的国际数据 考察生产率 考察生产率和经济政策之间的联系 储蓄、投资和金融体系金融体系由帮助将一个人的储蓄与另一个的投资相匹配的机构组成 讨论经济学中组成金融体系的各种机构 金融体系和一些关键宏观经济变量之间的关系，尤其是储蓄和投资之间的关系 建立一个金融市场上的资金供求模型 金融学的基本工具金融学研究人们如何在某一时期内做出关于配置资源和应对风险的决策的学科 讨论如何比较不同时点的货币量 讨论如何管理风险 根据对时间和风险的分析，考察什么决定一种资产比如一股股票的价值 失业 政府如何衡量经济中的失业率？ 解释失业数据时会出现什么问题？ 一般情况下失业者没有工作的时间会有多长？]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《宏观经济学的数据》]]></title>
    <url>%2F2019%2F03%2F02%2F%E3%80%8A%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%8B%2F</url>
    <content type="text"><![CDATA[监测整体经济发展的生产总量和物价总水平的指标 一国收入的衡量 考察国内生产总值 生活费用的衡量 考察如何衡量整体生活费用 如何用消费物价指数来衡量通货膨胀率，以及如何用消费物价指数比较不同时期的美元数字]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《经济学原理（微观）》]]></title>
    <url>%2F2019%2F03%2F02%2F%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%EF%BC%88%E5%BE%AE%E8%A7%82%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[研究家庭和企业如何做出决策，以及它们如何在市场上相互影响]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《经济学原理（宏观）》]]></title>
    <url>%2F2019%2F03%2F02%2F%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%EF%BC%88%E5%AE%8F%E8%A7%82%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[研究整体经济现象，包括通货膨胀、失业和经济增长 为什么学习经济学？ 帮助理解生活的世界。为什么演员的报酬这么高？为什么有些年份找工作容易？ 更精明地参与经济。多少收入用于支出，多少用于储蓄，多少用于投资？学习经济学不会使自己富有，但提供一些有助于致富的工具 理解经济政策的潜力和局限性。政府的预算赤字如何影响经济？自由贸易的影响是什么？ 《宏观经济学的数据》 《长期中的真实经济》]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《库与运行库》]]></title>
    <url>%2F2019%2F03%2F01%2F%E3%80%8A%E5%BA%93%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%BA%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《装载与共享库》]]></title>
    <url>%2F2019%2F03%2F01%2F%E4%BF%AE%E5%85%BB-%E3%80%8A%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%BA%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[介绍ELF文件在linux下的装载过程和linux下共享库的管理问题 装载程序==菜谱CPU==人硬件==其他厨具进程==炒菜的过程 32位平台下，有4GB虚拟空间、linux默认分配1GB给OS，3GB给进程 对于程序来说，将程序需要的所有指令和数据载入内存运行，就是静态装入，但是当所需要的内存经常大于物理内存的数量，又不能无限添加内存。由于程序运行时局部性原理，就可以将程序最常用的部分驻留在内存中，这就是动态装入，覆盖装入和页映射是典型的动态装载方法 覆盖装入几乎已经被淘汰，大致思想就是，把挖掘内存潜力的任务交给程序员，并把程序分成多个模块，并编写一个管理这些模块合适驻留内存的辅助器称为覆盖管理器，不详述 页映射随着虚拟存储的发明而诞生。把内存和所有磁盘数据和指令按照页为单位划分成若干页，以后所有装载和操作的单位就是页。有时候程序的页数远超过物理页数，此时就需要算法去选择舍去那个页来装载需要的页。一种是先进先出算法，另一种是最少使用算法，而这个控制程序就是现代操作系统，更准确的说是操作系统的存储管理器 可执行文件的页可能被装入内存中的任意页，程序如果使用物理地址直接操作，每次装入时都需要重定位，因此才需要虚拟存储和现代的硬件MMU提供地址转换功能 接下来剖析：创建一个进程，然后装载相应的可执行文件并执行 创建一个独立的虚拟地址空间：由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上就是创建映射函数需要的数据结构？？ 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系：第一步做的是虚拟空间和物理内存的映射关系，这步要做的是虚拟空间和可执行文件的映射关系。当操作系统捕捉到页错误时，需要知道程序需要的页在可执行文件的哪个位置，这就是虚拟空间和可执行文件之间的映射关系。可执行文件在装载时实际就是被映射的虚拟空间，但是考虑到偏移、字段对齐等因素，还是会有些许区别。linux把进程的虚拟空间中得到一个段叫做虚拟内存区域（VMA，如代码区、只读常量区、全局区、BSS段、堆区、栈区） 将CPU的PC设置为可执行文件的入口地址，启动执行：这一步在OS层面很复杂，设计内核堆栈和用户堆栈的切换、CPU运行权限的切换，不过从进程角度就简单认为执行了一条跳转指令，跳到可执行文件的入口地址 页错误上面的步骤只是通过可执行文件头部的信息建立可执行文件和进程虚拟内存之间的映射关系，可执行文件的真正指令和数据并没有载入内存 当CPU执行指令时，发现指令对应的页面是一个空页面，就认为这是一个页错误（Page Fault）。CPU会将控制权交给操作系统，其由专门的页错误处理程序 OS会先查询上面装载中第二步构造的数据结构，找到缺失页所在的VMA，计算出相关页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页和物理页之间建立映射关系，之后把控制权交还给进程 进程虚拟内存空间分布可执行文件拥有众多的段，但在映射的时候，是以系统的页长度为单位，这就会造成内存的浪费。为解决这个问题，可以将拥有相同权限的段合并在一起，然后映射到页中 在ELF中，数据分类的单位是Section，而从装载的角度，用Segment重新划分了ELF的每个Section，ELF中描述Segment的结构叫做Program Header，其描述了ELF文件如何被OS映射到进程的虚拟空间 堆和栈在进程的虚拟地址空间中，除了保存ELF文件的Segment，还保存进程需要的栈和堆 进程刚启动的时候，需要知道一些进程运行环境，如运行参数和环境变量，OS在进程启动之前将这些信息提前保存到进程的虚拟空间的栈中（也就是上图的STACK VMA）]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动态链接》]]></title>
    <url>%2F2019%2F03%2F01%2F%E3%80%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDB存储引擎]]></title>
    <url>%2F2019%2F03%2F01%2FInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[InnoDB：”in-no-db” 第一个完整支持ACID事务的引擎，还支持行锁设计、MVCC、外键、提供一致性非锁定读 从MySQL 5.1开始，MySQL数据库允许存储引擎开发商以动态形式加载引擎，这样存储引擎的更新可以不受MySQL数据库版本的限制。MySQL 5.1中，可以支持两个版本的InnoDB，一个是静态编译的InnoDB版本，可以将其看作老版本的InnoDB，另外一个是动态加载的InnoDB版本，官方称为InnoDB plugin，或者InnoDB 1.0 各版本之间的比较 老版本的InnoDB：支持ACID，行锁设计， MVCC InnoDB 1.0x：继承了上述版本的所有功能，增加了compress和dynamic页格式 InnoDB 1.1x：继承了上述版本的所有功能，增加了linux AIO，多回滚段 InnoDB 1.2x：继承了上述版本的所有功能，增加了全文索引支持，在线索引添加 InnoDB体系结构：内存池就是很多块内存组成的大内存，负责维护缓存磁盘上的数据，重做日志缓冲，维护内部数据等后台线程负责刷新内存池的数据，保证缓存的是最新的数据；将内存数据刷新到磁盘中等 后台线程前面说过InnoDB是一个单进程多线程的模型，后台不同的线程负责不同的任务 Master Thread：非常核心的后台线程，负责将缓冲池中的数据异步刷新到硬盘中，保证数据一致性，包括脏页的刷新、合并插入、UNDO页的回收等 IO Thread：InnoDB引擎中大量使用AIO（异步IO）来处理IO请求。从InnoDB 1.0.X版本之后，read thread和write thread分别增到4个，除此之外还有insert buffer和log IO thread12345678mysql&gt; SHOW VARIABLES LIKE &apos;innodb_%io_threads&apos;;+-------------------------+-------+| Variable_name | Value |+-------------------------+-------+| innodb_read_io_threads | 4 || innodb_write_io_threads | 4 |+-------------------------+-------+2 rows in set (0.00 sec) SHOW ENGINE INNODB STATUS;：可以查看IO thread状态 Purge Thread：清除、净化的意思，事务被提交后，undolog不再需要，因此需要Purge Thread回收undo页1234567mysql&gt; SHOW VARIABLES LIKE &apos;innodb_purge_threads&apos;;+----------------------+-------+| Variable_name | Value |+----------------------+-------+| innodb_purge_threads | 4 |+----------------------+-------+1 row in set (0.01 sec) Page Cleaner Thread：将脏页刷新操作放入单独的线程中完成 内存 缓冲池InnoDB存储引擎是基于磁盘的，由于CPU和磁盘速度之间的鸿沟，基于磁盘的DBMS通常需要缓冲池技术来提高性能 页从缓冲池刷新回磁盘的操作并不是每次页更新时触发，而是通过Checkpoint机制刷新磁盘。SHOW VARIABLES LIKE &#39;innodb_buffer_pool_size&#39;;来查看缓冲池大小 缓冲池不只是缓存索引页和数据页，还包括undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等 缓冲池的数量也可以自由设定，每个页根据hash值平均分配到不同缓冲池实例中。这样的目的就是增加数据库的并发处理能力。SHOW VARIABLES LIKE &#39;innodb_buffer_pool_instances&#39;;查看缓冲池数量，也可以修改配置文件中的innodb_buffer_pool_instances大于1，以获取多个缓冲池实例 LRUInnoDB通过LRU（Latest Recent Used，最近最少使用）算法来管理缓冲池。当缓冲池放不下新读取的页时，就会释放LRU列表尾端的页。但是新读取的页不是直接放入LRU列表的首部，而是midpoint，大约在列表5/8处，在midpoint之后的表称为old列表，之前的表称为new列表，SHOW VARIABLES LIKE &#39;innodb_old_blocks_pct&#39;;查看midpoint值，SET GLOBAL innodb_old_blocks_pct=20设置该参数，以降低old列表的比例 使用midpoint的原因：有些SQL操作，如索引或数据的扫描，这些操作会访问表中的很多页，这些页只在这次查询中有用，并不是活跃的热点数据，但是大量这种页如果放入首部，会使得所有页都被刷新出缓冲池 除此之外，还引入了innodb_old_blocks_time参数，其表示页读到mid位置后需要等待多久后才会加入LRU列表的热端，通过SET GLOBAL innodb_old_blocks_time=1000;设置该参数 当页从LRU列表的old部分加入new部分称为page made young，因为innodb_old_blocks_time导致没有从old移动到new称为page not made young 数据库刚启动时，LRU列表为空，页都存放在Free列表中。此时需要用到的时候直接将Free列表中的页删除，在LRU列表中增加相应的页，维持页数守恒 通过SHOW ENGINE INNODB STATUS;命令可以查看缓冲池的所有信息，1234567891011121314151617181920----------------------BUFFER POOL AND MEMORY----------------------Total large memory allocated 137428992Dictionary memory allocated 102398Buffer pool size 8191Free buffers 7942Database pages 249Old database pages 0Modified db pages 0Pending reads 0Pending writes: LRU 0, flush list 0, single page 0Pages made young 0, not young 00.00 youngs/s, 0.00 non-youngs/sPages read 215, created 34, written 360.00 reads/s, 0.00 creates/s, 0.00 writes/sNo buffer pool page gets since the last printoutPages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/sLRU len: 249, unzip_LRU len: 0I/O sum[0]:cur[0], unzip sum[0]:cur[0] 可以看出Buffer pool共8191个页，Free buffers表示Free列表共7942个页，Database pages即是LRU列表，共249个页。Pages made young表示从LRU列表中页移动到前端的次数 除了上面的命令还可以通过表INNODB_BUFFER_POOL_STATS来观察缓冲池状态12mysql&gt;SELECT pool_id,hit_rate, pages_made_young,pages_not_made_young &gt;FROM information_schema.INNODB_BUFFER_POOL_STATS; InnoDB好提供压缩页功能，原本16KB的页压缩为1KB、2KB、4KB、8KB，也因此需要unzip_LRU列表进行管理，且对不同大小的页进行分别管理，例如要向Buffer pool申请4KB的大小 检查4KB的unzip_LRU列表 如果有可用的空闲页直接使用，否则检查8KB的unzip_LRU列表 如果有空闲页，将页分为2个4KB页，存放到4KB的unzip_LRU列表之中 如果没有，则申请16KB… 在LRU列表中的页被修改之后，称该页为脏页，即缓冲池的页和磁盘中的页数据不一致。Flush列表的页即为脏页列表，Modified db pages就表示脏页的数量 重做日志缓冲重做日志（redo log）：确保事务的持久性（保证数据库的事务可以被重演）。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性 InnoDB首先将日志信息放入这个缓冲区，然后按照一定频率（一般为1S）将其刷新到重做日志文件，该缓冲区大写通过innodb_log_buffer_size设置 下面三种情况会将缓冲区的重做日志刷新带外部磁盘的重做日志文件中 Master Thread定期刷新 每个事务提交时 重做日志缓冲区剩余空间小于1/2时 额外的内存池在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆（heap）的方式进行的。在对一些数据结构本身分配内存时，需要从额外的内存池中申请，当该区域的内存不够时，会从缓冲池中申请。每个缓冲池中的帧缓冲（frame buffer）还有对应的缓冲控制对象（buffer control block），这些对象记录了诸如LRU、锁、等待等方面的信息，而这个对象的内存需要从额外内存池中申请 Checkpoint当前数据库都采取write ahead log策略，即当事务提交时，先写重做日志，在修改页 Checkpoint技术为了解决以下问题 缩短数据库的恢复时间，因为这样数据库只要对Checkpoint后的重做日志进行恢复 缓冲池不够用时， 将脏页刷新到磁盘 重做日志不可用时，刷新脏页。重做日志是循环使用，新的日志会覆盖旧的日志，因此当重做日志不够时，就要强制产生Checkpoint，将缓冲池的页至少刷新到当前重做日志的位置 LSN(Log sequence number)标记版本，每个页、重做日志、Checkpoint都有版本 Checkpoint的困难之处在于如何决策每次刷新几页到磁盘，每次从哪里取脏页和什么时候出发Checkpoint Checkpoint分为Sharp、Fuzzy Checkpoint。Sharp将所有脏页刷新到磁盘，发生在数据库关闭的时候Fuzzy发生在以下四个场景 master thread checkpoint flush lru list async flush 保证重做日志的循环使用的可用性？？？ dirty page too much Master thread？？？内部有多个loop组成：loop、backgroup loop、flush loop、suspend loop，Master Thread根据数据库运行状态在各个loop中切换 InnoDB关键特性插入缓冲Insert Buffer和数据页一样，也是物理页的一个组成部分 在插入操作时，数据页的存放主要还是按照Primary Key，但是对于非聚集索引叶子节点的插入则不是顺序的，这时需要离散访问非聚集索引页，由于随机读取（当存储器的消息被读取时，写入所需时间与数据位置无关）的存在导致插入操作性能下降，这主要是因为B+树的特性决定了非聚集索引插入的离散性 B+树的叶节点是有序的。当它用于聚集索引的时候，叶节点本身既是索引又是真实值。当它用于非聚集索引的时候，叶节点仅仅是索引，索引的指针指向的才是真实值。由于此时索引是有序的，因此其指向通常是无序的，所以两个连续的索引值可能对应的真实值所在的行可能会离得很远。 举个例子，一个表用整数id作为主键，且将主键当做聚集索引。此时再用表中的另一列age当做非聚集索引。由于表的行本身就是按主键排序的，因此age是无序的，所以age=10的行可能在第八行，而age=11的行却可能位于第三十行，差别很大。所以在插入的时候就无法做到连续的索引插入到连续的行中，而只能一条一条地定位和插入 Insert Buffer对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中。而是先判断插入的非聚集索引是否在缓冲池中，若存在，直接插入，若不在，先放入Insert Buffer对象中，再以一定的频率和情况进行Inser Buffer和辅助索引页子节点的merge操作，这时通常能将多个插入合并到一个操作中 只有满足索引是辅助索引、索引不是唯一的，InnoDB才会使用Insert Buffer。辅助索引不能是惟一的，因为数据库不会去查找索引页来判断插入的记录的唯一性，如果去查找就会有离散读取的情况发生，Insert Buffer就失去了意义 通过SHOW ENGINE INNODB STATUS;命令可以查看Insert Buffer信息，merges表示合并的次数12345678-------------------------------------INSERT BUFFER AND ADAPTIVE HASH INDEX-------------------------------------Ibuf: size 1, free list len 0, seg size 2, 0 mergesmerged operations: insert 0, delete mark 0, delete 0discarded operations: insert 0, delete mark 0, delete 0 在写密集情况下，插入缓存会占用过多的缓冲池内存，可以通过修改IBUF_POOL_SIZE_PER_MAX_SIZE对插入缓冲的大小进行控制，如果设置为3，则最大只能使用1/34 现在引入了Change Buffer，InnoDB对INSERT、DELETE、UPDATE都能进行缓冲，分别是Insert Buffer、Delete Buffer、Purger Buffer。如上述代码中表示，insert表示Insert Buffer，delete mark表示Delete Buffer，delete表示Purge Buffer,discarder operations表示当Change Buffer发生merge时，表已经被删除，此时就无需在将记录合并 Insert Buffer的数据结构就是一颗B+树，而且全局只有一棵，负责对所有表的辅助索引进行Insert Buffer 此B+树的非叶节点存放search key，构造如下图 search key共九个字节，其中space表示待插入记录所在表的表空间id，每个表都有一个唯一的space id，offset表示页所在的偏移量，占用4字节 当一个辅助索引要插入页（space，offset）时，如果这个页不在缓冲池中，那InnoDB先构造一个search key，接下来将这条记录插入Insert Buffer B+树的叶子节点中，上图第二行是叶子节点的结构，metadata占用4个字节，其中两个字节保存IBUF_REC_OFFSET_COUNT，该值用来记录每个记录进入Insert Buffer的顺序 为了保证每次 Merge Insert Buffer页必须成功，还需要有一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型为Insert Buffer Bitmap。每个辅助索引页在Insert Buffer Bitmap占用4位，其中两位IBUF_BITMAP_FREE表示该辅助索引页的可用空间数量，例如00表示无可用空间，01表示剩余空间大于1/32页等等 最后思考Merge Insert Buffer何时发生 辅助索引页被读取到缓冲池：例如在执行正常的SELECT查询操作，这时需要检查Insert Buffer Bitmap，然后确认该辅助索引页是否有记录存放在Insert Buffer B+树中，若有则要进行合并 Insert Buffer Bitmap页追踪到该辅助索引页已经没有可用空间 Master Thread：在Master Thread中，执行merge操作的页数由srv_innodb_io_capacity的百分比决定要真正合并多少辅助索引页 两次写doublewrite带给InnoDB的是数据页的可靠性 当InnoDB正在写入某个页到表中，如果只写了一部分就发生宕机，这种情况就叫部分写失效 doublewrite就是在应用重做日志之前，用户需要一个页的副本，在写入失效发生时，先通过页的副本还原该页，在重新重做 在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页复制到内存中的doublewrite buffer，之后在通过doublewrite buffer分两次顺序写入共享表空间的物理磁盘上，然后马上调用fsync函数（系统调用fsync将所有已写入文件描述符fd的数据真正的写道磁盘或者其他下层设备上，Linux文件系统可以使数据在写入磁盘前先在内存中保留几秒，以此更高效率的处理磁盘I/O），同步磁盘。完成之后，再将doublewrite buffer中的页写入各个表空间文件中 如果OS在将页写入磁盘的过程中发生崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个 副本，将其复制到表空间文件，在应用重做日志 自适应哈希索引InnoDB会监控表上各索引页的查询，如果观察到建立哈希索引可以带来速度的提升，就会建立哈希索引，这就叫自适应哈希索引（Adaptive Hash Index，AHI），AHI根据缓冲池的B+树构造起来，InnoDB会自动根据访问的频率和模式自动为某些热点页建立哈希索引 异步IO用户可以发出一个IO请求之后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。和AIO对应的是Sync IO，即进行一次IO操作，需要等待此次操作结束才能继续接下来的操作 AIO另一个优势是进行IO merge，也就是将多个IO合并为一个IO，例如用户需要访问连续的三个页，AIO会判断这三个页是连续的，因此AIO底层会发送一个IO请求，直接读取三个页 InnoDB提供了内核级别的AIO支持，成为Native AIO，这需要libaio库支持 在InnoDB中，read ahead方式的读取都是AIO，脏页的刷新，即磁盘的写入操作也是AIO 刷新邻接页当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页，则一起刷新 启动、关闭和恢复在关闭时，参数innodb_fast_shutdown影响InnoDB的行为 0：在关闭时，InnoDB需要完成所有full purge和merge insert buffer，并且将所有脏页刷新到磁盘中 1：不需要完成上述的full purge和merge insert buffer，但是在缓冲池的一些数据脏页会是会刷新回磁盘 2：不需要完成上述的full purge和merge insert buffer。也不将缓冲池的数据脏页写回，但是将日志都写入日志文件 参数innodb_force_recovery影响了整个InnoDB存储引擎恢复的状态 0：为默认值，代表当发生需要恢复时，进行所有的恢复操作，当不能有效恢复时，如数据页发生了corruption，MySQL就可能发生宕机，并把错误写入错误日志 1：忽略检查到的corrupt页 2：阻止Master Thread线程的运行 3：不进行事务的回滚操作 4：不进行插入缓冲的合并操作 5：不查看撤销入职，InnoDB存储引擎会将未提交的事务视为已提交 6：不进行回滚的操作 当该参数设置大于0后，但是insert、update、delete这类DML操作是不允许的，只能进行select、create和drop]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行期优化]]></title>
    <url>%2F2019%2F02%2F28%2FJVM%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[追求性能的路上！ 早期的Java程序是通过解释器进行执行的，只有在运行期，JVM发现hotpot code时，才会将这些代码编译成和本地相关的机器码，并进行优化，实现者就称为即时编译器，但是即时编译器不是JVM必需的部分 像主流厂商，如Hotpot、J9等，都是解释器和编译器共存的状态，两者各有优势。想程序需要快速启动和执行的时候，解释器可以先发挥作用，随着时间推移，编译器逐渐发挥作用，将更多的代码编译成本地代码，以获取更高的效率；反过来，某些时候，编译器的优化不好，就会退回到解释状态继续执行，解释器就作为“逃生门”的角色 Hotpot内置了两个即时编译器：Client Compiler和Server Compiler，Hotpot根据自身版本和宿主机器的硬件性能自动选择运行模式（Client模式和Server模式，这两种都成为Mixed模式），当用户使用参数-Xint强制使用解释器时，就进入解释模式。当使用Xcomp时，就进入编译模式123456789101112PS C:\Program Files\Java\jdk1.8.0_201\bin&gt; java -versionjava version &quot;10.0.1&quot; 2018-04-17Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, mixed mode)PS C:\Program Files\Java\jdk1.8.0_201\bin&gt; java -Xint -versionjava version &quot;10.0.1&quot; 2018-04-17Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, interpreted mode)PS C:\Program Files\Java\jdk1.8.0_201\bin&gt; java -Xcomp -versionjava version &quot;10.0.1&quot; 2018-04-17Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, compiled mode) 为了在程序响应速度和运行效率之间达到最佳的平衡，Java 7中，Hotpot采用了分层编译的策略，并默认开启 第0层：程序解释执行。解释器不开启性能监控功能时，触发第1层编译 第1层：C1编译，将字节码编译为本地代码，进行简单优化，加入性能监控 第2层：C2编译，会启动一些耗时较长的优化 多次调用的方法和多次执行的循环体会触发编译器编译，编译器对两种情况都是选择以整个方法为编译对象，判断代码是不是热点代码叫做热点探测 基于采样的热点探测：JVM周期性检查各个线程的栈顶，如果发现经常出现在栈顶，就认为是热点代码，但这种方法会因为线阻塞而受干扰 基于计数器的热点探测：JVM为每个方法建立计数器，统计方法的执行次数，又分为方法调用计数器和回边计数器。计数器有一个阈值，只有当超过阈值时，才会触发JIT编译，阈值可通过-XX:CompilerThreshold设定 从图中看到，在方法执行期间，存在替换方法的可能性，我们称这个过称为栈上替换（OSR，On-Stack Replacement），OSR是一种在运行时替换正在运行的函数/方法的栈帧的技术。但它是手段，不是目的——是出于某种目的需要在运行时替换栈帧。使用OSR最常见的目的就是在一个函数/方法的执行过程中，在执行引擎的不同优化层级之间切换，可以是从低优化层级向高优化层级切换，也可以反过来。这也就隐含了一个假设——这个执行引擎有多个层级的优化 方法计数器统计的并不是绝对次数，而是相对频率，因为计数器有一个热度衰减的机制，如果超过一段时间，次数就会减少一半，这个周期成为半衰周期，可以使用-XX:UseCounterDecay关闭热度衰减，-XX:ConuterHalfLifeTime设置半衰周期 回边计数器则是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为回边（类似于汇编中的loop)，回边计数器的目的就是为了触发OSR编译，回边计数器没有热度衰减，统计的就是绝对次数，而且当回边计数器溢出时，还会设置方法计数器的值也为溢出 默认情况下，编译动作都是早后台进程中进行，但设置-XX:-BackgroundCompilation可以禁止后台编译，执行线程想虚拟机提交编译后将会一直等待，知道编译完成再开始执行]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行工具与参数调优]]></title>
    <url>%2F2019%2F02%2F27%2FJVM%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[从实战角度了解JVM内存管理的世界 运行日志、异常堆栈、GC日志、线程快照、堆转储快照都是我们定位系统信息的信息 jdk/bin中“赠送”的应用程序具有很大的作用，这些命令行工具大多数是jdk/lib/tools.jar类库的包装，即这些工具都是tools类库用Java实现的，Windows下Shift+右键快速进入指定文件夹，下面概述重要的命令行工具，详情参见ORACLE文档 jpsJVM process status Tool，显示指定系统内所有的Hotpot虚拟机进程，和Linux中ps类似，列出名称和进程唯一ID -q：只输处ID，忽略名字 -m：输出进程启动时传递给main()的参数 -l：输出主类全名 -v：出书进行启动时的JVM参数 123456789101112PS C:\Program Files\Java\jdk1.8.0_201\bin&gt; jps -l1568017508 org.jetbrains.jps.cmdline.Launcher18644 org.jetbrains.jps.cmdline.Launcher2980 jdk.jcmd/sun.tools.jps.Jps4408PS C:\Program Files\Java\jdk1.8.0_201\bin&gt; jps -q15680175081864444088812 jstatJVM Statistics Monitoring Tool，收集虚拟机的类装载、内存、垃圾收集、JIT编译等运行数据，命令格式jstat -option -id -interval -count，option表示查询信息类型，id表示查询进程，interval表示查询间隔，count表示查询次数 -class：监视类装载、卸载数量和字节数以及所花费的时间 -gc：监视堆状况，包括Eden区、两个survivor区，老年代、永久代等容量、已用空间、GC时间合计等 -gcnew：新生代GC状况 -gcold：老年代GC状态 -compiler：输出JIT编译过的方法、耗时等信息 -printcompilation:输出编译过的方法名称 jinfoConfiguration Info For Java，显示JVM配置信息 jmapMemory Map for Java，生成JVM内存转储快照 jhatJVM Heap Dump Browser，用于分析上面生成的快照，可在浏览器查看 jstackStack Trace for Java，显示虚拟机的线程快照]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第15章 泛型]]></title>
    <url>%2F2019%2F02%2F27%2F%E3%80%8ATIJ-%E6%B3%9B%E5%9E%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[为了编写可以应用于多种类型的代码而产生泛型 了解边界所在，才能成为编程高手，因为只有知道了某个技术不能做什么，才能做到所能做的 泛型实现了参数化类型的概念，但是Java的泛型一直受到诟病，]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《MySQL技术内幕》]]></title>
    <url>%2F2019%2F02%2F27%2F%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本书完整讲解InnoDB存储引擎的体系结构和工作原理，并结合InnoDB得到源代码讲解了它的内部实现机制 任何时候Why比What重要，只有真正理解内部实现原理、体系结构，才能更好地使用，这才是人类正确思考问题的原则 体系结构MySQL由后台进程以及一个共享内存区组成，是单进程多线程架构 数据库：物理操作系统文件或其他形式文件类型的集合，依照某种数据模型组织起来并存放于二级存储器中的数据集合 实例：数据库实例才是真正用于操作数据库文件，应用程序通过其和数据库打交道从上往下，从左往右依次是 管理服务和工具组件 连接池组件 SQL接口组件 查询分析器组件 优化器组件 缓冲组件 插件式存储引擎：该特性是MySQL区别于其他数据库的重要特性；存储引擎是基于表的，而不是数据库；用户可以自由选择存储引擎，甚至修改引擎，使其符合自己的需求 物理文件 存储引擎之间还是有很大区别，要根据需要选择合适的引擎，有些引擎支持事务，有些则不支持 InnoDB：支持事务、行锁设计、支持外检、非锁定读，多版本并发控制，实现了SQL标准的四种隔离级别，插入缓冲，二次写，自适应哈希索引，预读 MyISAM：不支持事务（并不是所有应用都需要事务）、表锁设计，支持全文索引，缓冲池只缓冲索引文件，而不缓冲数据文件 连接数据库操作就是一个连接进程和MySQL数据库实例进行通信，本质上就是进程通信，常见的有管道、命名管道、命名子、TCP/IP、Unix域套接字等 源码结构存储引擎的源码都在storage文件夹下，InnoDB的源码文件夹结构如下 btr：B+树的实现 buf：缓冲池的实现，包括LRU算法， FLUSH刷新算法 dict：InnoDB中内存数据字典的实现 dyn：InnoDB中动态数组的实现 fil：InnoDB文件数据结构以及对文件的一些操作 fsp：file space，对物理文件的管理，如页、区、段等 ha：哈希算法的实现 handler：插件式存储引起的实现 ibuf：插入缓冲的实现 include：头文件 lock：如S锁、X锁的实现以及定义锁额度一系列算法 log：日志缓冲和重组日志文件的实现 mem：辅助缓冲池的实现，用来申请一些数据结构的内存 mtr：事务的底层实现 os：封装对OS的操作 page：页的实现 row：各种类型行数据的操作 srv：参数的设计 sync：互斥量的实现 thr：封装的可移植的线程库 trx：事务的实现 ut：工具类 目录 InnoDB存储引擎 表 索引与算法：正在整理 事务：未 锁：未 文件：未]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《现代操作系统》]]></title>
    <url>%2F2019%2F02%2F26%2F%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Archlab]]></title>
    <url>%2F2019%2F02%2F26%2Flab-arch%2F</url>
    <content type="text"><![CDATA[设计处理器！ 安装过程源文件可到GitHub下载，根据simguide进行安装，期间有些问题 /usr/bin/ld: cannot find -lfl collect2: error: ld returned 1 exit status解决/usr/bin/ld: cannot find -lxxx 问题：此类问题都是因为缺少库导致的，但是Centos上缺少的这个fl库好像只有Ubuntu上才有，因此需要兜兜转转去安装Ubuntu，真麻烦！真香！哈哈哈好或或！第一次上手Ubuntu，也太好看，也太好用了吧！变心！ 接下来还遇到了几个问题，一是要修改Makefile，但是和网上通用教程有些区别，自己电脑上的文件路径不同，要自己找到文件后输入正确的路径，我电脑上的路径是12345GUIMODE=-DHAS_GUITKLIBS=-L/usr/lib/x86_64-linux-gnu -ltk8.5 -ltcl8.5TKINC=-I/usr/include/tcl8.5 重新编译又遇到了matherr未定义的问题，这应该是因为该符号过时不再使用的原因，因此需要去查找出现该符号的*.c文件并注释掉，最终得以成功！]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机组成与设计硬件/软件接口》]]></title>
    <url>%2F2019%2F02%2F26%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%A1%AC%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%8F%A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[成功的程序员总是关心其程序的性能 之前一直不理解为什么副标题是硬件软件接口，这指的是啥？现在想想不就指令集体系嘛！什么是处理器？不就是通过指令集映射到硬件的那几张图嘛！那这本书对我们编写软件有什么帮助呢？ 现代计算机的特征是处理器的并行性和内存的层次性，程序员为了程序的能效，就需要了解代码之下的很多细节，这就需要增加对计算机组成的认知 算法：决定了源码级语句的数量和IO操作数量 编程语言、编译器、体系结构：决定了源码对应的计算机指令数量 对应第三章数据级并行，使用C的子字并行 处理器、存储系统：决定指令的执行速度，对应第4、5章指令级并行，循环展开开发多指令发射和乱序执行硬件 存储器层次优化，使用阻塞cache 硬件和操作系统：决定了IO操作可能的执行速度，线程级并行 在过去与60年中，计算机设计者提出了8个伟大思想 面向摩尔定律设计：摩尔定律指出单芯片上的集成度每18-24个月翻一番，由于设计计算机需要几年时间，因此设计者必须预测其设计完成时的工艺水平 使用抽象简化设计：架构师和程序员必须发明能够提高产量的技术，否则设计时间也将会向资源规模一样按照摩尔定律增长，要提高生产率的主要技术之一就是用抽象来分离不同的设计层次 加速大概率事件：这远比优化小概率时间更能提高性能 通过并行提高性能：就像另一本书中所说，并发编程是程序员提高的一个门槛 通过流水线提高性能：特殊的并行性场景 通过预测提高性能：求人准许不如求人原谅 存储器层次：更快和更大总是矛盾的 通过冗余提高可靠性：通过使用冗余部件来提高系统可靠性，就是浪费一些东西来换取可靠性 大端和小端MSB（Most Significant Bit）是最重要的字节，LSB则是最不重要的字节，对应上图，0x78就是LSB，0x12就是MSB 大端和小端的区别就是Big-endian规定MSB在存储时放在低地址，在传输时MSB放在流的开始，LSB则相反 前面的大端和小端都是在说计算机自己，也被称作主机字节序。其实，只要自己能够自圆其说是没啥问题的。问题是，网络的出现使得计算机可以通信了。通信，就意味着相处，相处必须得有共同语言。但是每个计算机都有自己的主机字节序 TCP/IP协议（RFC1700）规定使用“大端”字节序为网络字节序，其他不使用大端的计算机发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化 为了程序的兼容，你会看到，程序员们每次发送和接受数据都要进行转换，这样做的目的是保证代码在任何计算机上执行时都能达到预期的效果。 《存储器层次结构》]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章：处理器体系结构]]></title>
    <url>%2F2019%2F02%2F26%2FCSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[现代处理器是人类创造的最复杂的系统之一 不同的处理器家族支持不同的ISA（Instruction-Set Architecture，指令集体系结构），ISA在编译器编写者和处理器设计人员之间提供了一个抽象概念层，ISA模型看上去是顺序指令执行，但在实际执行时，为了获取更高的性能，往往采取一些特殊机制 本章目的在于设计处理器，首先会定义一个简单的指令集（Y86-64，是X86-64子集，只包含8字节整数操作），和实际ISA相比，简单一些但足够完整，完成一些处理整数的程序，接着会提供一些数字硬件设计的背景，之后会设计基于顺序操作的Y86-64处理器，之后进行改进，创建一个流水线化的处理器 Y86-64指令集体系结构的指令都会读取和修改处理器状态的某些部分，这称为程序员可见状态，也就是多个寄存器（每个寄存器存储一个64位字）、3个一位的条件码（ZF、SF、OF，保存最近的算术或逻辑指令造成的信息）、PC和状态码（Stat，表明程序执行的总体状态，指示是正常运行还是出现了某种异常，例如当指令试图读取非法的内存地址时，就会产生对应的状态码，这就和软件层的异常对应上了） 中间介绍了一些指令细节、逻辑设计和硬件控制语言，要么就是过于细节，要么就是学过了，因此没有仔细看，直接跳过，直接进入处理器设计步骤 即使是ISP的一条指令也包含了很多操作，而且指令之间或多或少会有些不同，因此创建一个框架，使得指令都遵循统一的序列，有点类似于模板设计方法 取指：从内存中读取指令字节，地址为PC的值 译码：从寄存器文件读入最多两个操作数 执行：算术/逻辑单元（ALU）执行指令指明的操作，计算内存引用的有效地址，要么增加/减少栈指针 访存：将数据写入内存，或者从内存读取数据 写回：将结果写回到寄存器文件 更新PC：将PC设置为下一条指令地址]]></content>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译期优化]]></title>
    <url>%2F2019%2F02%2F25%2FJVM%E7%BC%96%E8%AF%91%E6%9C%9F%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[对效率的追求是程序员天生的坚定信仰 编译期的前端（如Sun的Javac）把*.java文件转化成*.class文件，后端运行期编译器（JIT编译器，如HotSpot VM的C1、C2编译器）把字节码转化成机器码，静态提前编译器（GCJ）直接把*.java文件编译为本地机器代码，本文所讲的都是前端编译部分 Javac并没有优化措施，对性能的优化多集中在后端的即时编译器中，但Javac做了优化措施来改善程序员的编码风格和提高编码效率，许多新生Java“语法糖”，如泛型、内部类，是靠前端编译器实现的，而不是依赖虚拟机的底层改进，且本身就是由Java编写的，为分析源码提供便利。语言编译器竟然是由语言本身完成，称为自举，这似乎让自己有点明白了《计算机程序的构造和解释》中最后两章自制编译器，即最开始使用X语言（如Fortran）实现Y语言（如Pascal）的编译器，即解决鸡与蛋的问题，即使用其它语言构建出我们的第一版编译器，之后成熟以后，就可以完全使用已经生成好的编译器来编译出我们的新编译器 编译过程大概分成三步 解析与填充符号表：解析分为词法分析和语法分析，词法分析是将源代码的字符流转变为Token集合，Token指的是关键词、变量名、字面量、运算符等，词法分析由javac.parser.Scanner类完成；语法分析则根据Token序列构造抽象语法树，具体可参见《编译原理》，语法分析由javac.parser.Parser类完成，生成的抽象语法树由javac.tree.JCTree类表示 插入式注解处理器的注解处理：编写注解处理器参见第20章 注解，如果这些注解处理器在处理注解期间对语法树进行了修改，编译器将回到上一步骤重新处理，直到不再对语法树进行修改为止，每次循环成为一个Round 分析和字节码生成：语法分析形成的抽象树能表示正确的源程序抽象，但不代表符合语言规定的语义，因此要进行语义分析，而语义分析必须限定在具体的语言和具体的上下文环境中 Javac的语义分析过程分为标注检查和控制流分析两个步骤 标注检查：变量是否已被申明过，变量与赋值之间的数据类型是否匹配等，除此之外，还有一个常量折叠步骤，比如int a = 1 + 3，在这个步骤之后，语法树上就会呈现出int a = 3，因此在运行期间并不会增加CPU指令，由javac.comp.Attr和javac.comp.Check类实现 数据及控制流分析：程序局部变量再使用前是否有赋值、方法的每条路径是否都是有返回值、是否所有的受查异常都正确处理等，局部变量的final不变性是由编译器在编译期间保障，而不是在运行期，因为有无final得到的Class文件都是一样，由javac.comp.Flow实现？？？ 语法糖对语言的功能并没有影响，但更方便程序员使用，增加程序的可读性，减少出错的可能性。Java是低糖语言，主要语法糖有泛型、变长参数、自动装箱/拆箱等，这些语法糖在编译期间会被还原为简单的基础语法结构，因为JVM并不支持这些语法，由javac.comp.TransTypes类和javac.comp.Lower类完成 最后一个阶段是字节码生成，这个阶段把前面步骤产生的信息转化为字节码写入到磁盘中，除此之外，编译器还进行了少量的代码添加和转换工作，由javac.jvm.Gen类实现，实例构造器&lt;init&gt;()方法和类构造器&lt;clinit&gt;()方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）？？？把字符串的加操作替换为StringBuffer或StringBuilder的append()就是在这个步骤完成 Java的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换成原来的原生类型（如整型、字节型，区别于引用类型），实现Java泛型的方法称为类型擦除，这种泛型称为伪泛型，下面是自动装箱的一个陷阱 123456789101112131415161718192021222324public class test &#123; public static void main(String[] agrs)&#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 4; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c == d);//指向同一个对象 System.out.println(e == f);//值大于127，不同地址 System.out.println(c == (a + b));//自动拆箱，比较数值 System.out.println(c.equals(a + b));//类型和值都相同 System.out.println(g == (a + b));//自动拆箱，比较数值 System.out.println(g.equals(a + b));//值相同，类型不同 &#125;&#125;truefalsetruetruetruefalse “==”运算：如果是基本数据类型，则直接对值进行比较，如果是引用数据类型，则是对他们的地址进行比较（但是只能比较相同类型的对象，或者比较父类对象和子类对象。类型不同的两个对象不能使用==）。包装类在不遇到算术运算的情况下不会自动拆箱 Object中qeuals的源码发现，它的实现也是对对象的地址进行比较，此时它和”==”的作用相同。而JDK类中有一些类覆盖了Object类的equals()方法，比较规则为：如果两个对象的类型一致，并且内容一致，则返回true,这些类有：java.io.file、java.util.Date、java.lang.string、包装类（Integer,Double等） nteger使用一个内部静态类中的一个静态数组保存了-128-127范围内的数据，静态数组在类加载以后是存在方法区，并不是什么常量池。在自动装箱的时候，首先判断要装箱的数字的范围，如果在-128-127的范围则直接返回缓存中已有的对象，否则new一个新的对象。其他的包装类也有类似的实现方式]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《王二的经济学故事》]]></title>
    <url>%2F2019%2F02%2F25%2F%E3%80%8A%E7%8E%8B%E4%BA%8C%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%95%85%E4%BA%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[王二的经济学故事，是我们每个人的故事 理论是灰色的，而生命之树常青 觉得自己从来不会出错的人，多半不是无知就是自大狂]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编译原理》]]></title>
    <url>%2F2019%2F02%2F25%2F%E3%80%8A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8B%2F</url>
    <content type="text"><![CDATA[网上看到一句话，机器生汇编，汇编生B，B生C，C生万物，这个生的逆向过程就是编译器要做的事情 编译器只是一个语言处理系统的一部分，创建可执行的目标程序完整的流程如下图，详情参见拆开编译器这个黑盒子，又会发现很多步骤，如下图 一种语言的语法描述了程序的正确形式，语义则定义了程序的含义 上下文无关文法：是广泛使用的一种描述语法的表示方法 下图是编译器前端的模型 词法分析：源代码程序被输入到扫描机，它运用一种类似于有限状态机的算法将源代码的字符序列分割成一系列的符号，产生的符号可以分为关键字、标识符、字面量和特殊符号。然后将标识符放到符号表，将数字、字符串常量放到文字表。C语言在词法分析之前，还会通过预处理器去处理宏替换和文件包含，对于工具Lex，参见Lex/Yacc入门 语法分析：对上一步产生的记号进行分析，产生语法树，采用上下文无关语法的分析方式，对应的工具是Yacc 语义分析：经过该阶段，这个语法树的表达式都被标志了类型，如果类型需要隐式转换，该步骤会在语法树插入相应转化节点 中间语言生成：编译器往往在源码级别会有一个优化，即源码级优化器。它会将这个语法树转换为中间代码，此时已经非常接近目标代码，但是中间代码一般不包括数据尺寸、变量地址等。最常见的中间代码类型是三地址码。中间代码是编译器前端和后端的分水岭。 前端负责产生机器无关的中间代码，后端将中间代码转化成目标机器代码 目标代码生成与优化：这个过程非常依赖目标机器，CPU的复杂和语言的复杂使得编译后端也变得异常复杂 目录 《词法分析》 《语法分析》 《语法制导的翻译》 《中间代码生成》 《运行时刻环境》 《代码生成》 《机器无关优化》]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《一沙一世界》]]></title>
    <url>%2F2019%2F02%2F24%2F%E3%80%8A%E4%B8%80%E6%B2%99%E4%B8%80%E4%B8%96%E7%95%8C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一沙一世界，一花一天国，掌中握无限，刹那成永恒 好的文章是理性沉稳的，而不是情绪化的，不应该故作深沉；世事充满不确定性，好的文章应该看中论述的过程而不是具体的结论。具体的结论，会因为条件、约束、环境和前提的变化而变化 不能用正确或者错误来评价经济学文章，这是单一思维模式的体现，经济学作为社会学科，从不同视角出发很可能会得出不同的结论。好的经济学文章，要能提供正确的思维逻辑分析和新颖的角度，重点不在于正确的结论。好像有点爱上经济学了，提供了一个和计算机思维不一样的思维模式 一个国家出口的最终目的就是为了出口，否则出口一堆商品，换来手上的外汇，也是一堆白纸 虽然发达国家也常被叫做工业化国家，但是几乎所有工业化国家，工业已经不再是经济最大的部分，甚至不是经济增长最重要的源泉，但是这些国家的兴起却是因为工业化 制造业是经济增长的引擎，但未必是就业的增长引擎。未来服务业反而会称为主要的就业吸收部门 中国的制造业也许已经是世界第一，但进一步发展的空间相当有限，因为中国的制造业还是相对低端，不再能持续创造就业机会。而高端制造业只会创造更少的就业机会，而不是更多，例如飞机。因此当中国的制造业向高端发展时，中国庞大的劳动力就会成为一个大问题 为此，中国应该给服务业更大的发展空间，也能因此拉动内需，赋予起来的中国百姓花越来越多的钱在购买服务上，从购买农产品、工业品，到购买服务，是消费升级的必然结果 大学生就业难，一是因为大学生毕业人口逐年增加，十年前全国有610万应届毕业生，现在则有800万，每年百分之三的增长；二是因为学生不愿放低身价 大学生的市价低可能是因为结构性因素造成的，比如毕业生多，需求小，也可能是教育质量的因素，市场对部分大学生的质量不认可 二十世纪末，大学生扩招，大学却能在不增加师资、教学设施的情况下，凭空多招一大堆学生，这种形式的扩招有时候就是稀饭里多加一瓢水和一双筷子。现在为了解决本科生就业难的问题，又开始研究生扩招，水还要继续掺下去 作为大学生，应该尽早认清这个现实，降低自己的预期，同时提升自己的水平 在经济增速下滑的时候，这种收入下降不会平摊到所有人头上，而是一部分人承受大部分的下降，而大部分人毫发无损 对于企业，裁员和降薪的效果都是类似的，但是通过裁员来应对经济状态的变化，存在额外成本，例如在经济变好后，重新招聘人员的时间成本和人力成本，而降低工资则不存在这样的问题。但是如果工资不具有足够的灵活性，那企业依旧会选择裁员 从上面这方面来说，工资越不具有灵活性，在经济走差的时候，失业情况越严重 无论从企业利益，还是公平角度，减薪似乎都是一个更好的选择，但是在实现起来却很困难，因为让大部分人牺牲利益比小部分人失业要苦难的多，这也是很多企业选择裁员而不是减薪的原因 人为地压低价格并不会改变物稀的本质，相反只会使得物稀的情况变得更加严重。最典型的例子就是20世纪50年代的大食堂，既没有改变粮食不够吃的现状，反而造成大量浪费 中国的高铁存在独特的现象：被高速，高铁的票价增加了不少人的出行成本，这类人时间是相对不重要的，舒适度是相对不重要的，钱才是最重要的。这一现象的出现的原因就是铁路的低端替代品不多 被高速折射的问题：有限的资源，如何在一个收入差距日渐拉大的人群中分配 有人说提高票价能降低春运的压力，这种方法是有效的，但未必是有人情的，提高票价只会让更多低收入人群回不了家，这样的策略忽略了人类社会是有文明的，不应该只有丛林法则 科斯定理定义是：只要财产权是明确的，并且交易成本为零或者很小，那么，无论在开始时将财产权赋予谁，市场均衡的最终结果都是有效率的，实现资源配置的帕雷托最优。这个定义对于没有经济学基础的同学来说看着有点费劲。用薛兆丰老师的话说就是：一项有价值的资源，不管它的产权归谁，最后这项资源都会流动到能最大化利用其价值的人手里。更通俗一点讲就是：交易费用足够低，谁用的好就归谁 查理·芒格说：“想要得到某样东西的最好办法，就是让自己配得上它”，这也正符合科斯定理。不用相信成功学，只要不断修炼自己，就能让自己配得上自己想要的东西 中国是以商业化的模式修路，这就意味着修路是以盈利为目的。这种模式虽然不招人喜欢，但是却快速提高了中国基础设施水平 中国经济存在许多问题，但依旧是世界上最有活力的经济 人口红利的意思是一个经济体，如果人口数一定，那么赡养率较低时，人均收入的增长会较快。通俗讲，就是干活的多，不干活的少，经济体的活力会高一些 计划生育造成的特殊人口结构，是中国经济能够快速增长的一个重要因素。但是未来，随着人口老龄化，人口结构变成倒金字塔型，人口红利就会变成人口负利，独生子女这一代要承受着太多的压力，这是很不健康的 中国就是一个用百米冲刺的速度跑马拉松的国度。阶级的分布被拉的很长，每个阶级都有大量的人群，但阶级之间很能交流，形成了异质化现象 破窗理论:谬误是法国人Bastiat在他的文章“看得见的和看不见的”中提出的，他用这个故事来说明那些看不见的成本 故事本身很简单：如果一个小孩打破了商店的窗户，商店的老板就要去买玻璃，这样玻璃店的人就有活干了；玻璃店的人又需要买面包，这样面包店人就也有活干了；如此往复，打碎了一块玻璃似乎可以创造很多就业，打碎玻璃其实是一件好事而不是坏事。 Bastiat本人对这个故事之所以是个谬误的解释非常简单：商店老板花了钱买玻璃，他的那些钱就不能花在别的东西上了，在这个故事上你只看到了商店老板把钱花在玻璃上，你却没有看到商店老板因此减少了别的支出。这也就是我在《自然灾害拉动经济？》一文里说机会成本的那一段。现代经济，因为货币，政府，赤字，转移支付，储蓄等等的存在，使得事情变得有点不那么清楚，很多事情变得不那么直接，比如说Bastiat的故事里就没有储蓄和投资的变动，因为整个故事只有一期，但机会成本这件事情的逻辑还是在那里的 人不是概率动物，对小概率事件的估计能力是很差的 好的通缩通常因为供应突然增大，进而引发整体的价格水平下降，坏的通缩通常因为需求下降导致产品滞销引起 通缩引起的钱越来越值钱，不一定是好事。钱越来越值钱，意味着持有货币是一项不错的投资，但一个经济中，总得有人进行真正的投资，也就是把钱花出去。对于消费也是同理，价格越来越低，人们也就推迟购买的时间，降低消费。这两个因素又会加剧通缩和经济下滑。这也侧面反应为什么经济是通货膨胀而不是通货紧缩的 泡沫，就是金融资产的价格过高，不足以被基本面所支撑。如果有人愿意购买存在泡沫的金融资产，其理由只能是有人愿意在更高的价格接受。只要有资金不断注入，这样的泡沫就可以吹下去。这样的泡沫经济不就是一个巨大的旁氏骗局吗？？！ 所有的政府开支最终都要靠税收来支付，不是向当前的纳税人收，就是通过赤字的方世玉向未来的纳税人收，不是通过直接的税来收，就是通过各种费来收，不是财政部来收，就是让央行通过只要通胀来收（通胀税） 动物的基因中天然暗示了要多吃，这是出去生存的本能，人也一样，但是当人类进去富裕的时代，基因却没有跟上，也就出现了越来越多的肥胖 不管怎么变道，平均下来也快不了多少；炒股，不管怎么积极操作，大多数人都不会在平均意义上跑赢大盘 信用卡降低了交易成本，就像现在的移动支付。但是银行不断在信用卡，在花呗上做文章的解释是在行为经济学。人是一种自制力较差，容易冲动的生物。有了花呗，银行卡就能为自己的冲动买单 正版的高价不是盗版的原因而是盗版的结果。与其降低自己的身价去吸引低端消费者购买正版，不如保持身价去宰割高端消费者 这个世界充满信息不对称，几乎时时都处在竞争不充分，而小到抽烟大到全球变暖都是外部性的体现 只重利益而忽略道德后果的经济增长是不可以持续的 我们看待整个世界的时候存在系统性偏差，倾向于把更多的重要性放在可以衡量的东西上。这提醒我们有些东西是无价，衡量不了的，但我们不能忘记它的重要性 相同的工种，在不同的国家有截然不同的报酬。这是因为每个国家中，最有创造力，最有才干，最有生产率的人能够创造的财富个产出是相对较高的，正是这批人使得干着最简单的工作的人也可以获得更高的收入 中国的网络舆论主要来自城市，以及中国没有广泛参与的政治制度，使得中国沉默的大多数现象尤其明显。这导致收入分配最底层的农民对收入分配差距抱怨最少，而处于收入分配上层的城市居民对于分配抱怨最大 现代市场经济和过去的小农经济不同点之一，在于现代市场经济在交易的透明化。消费者完全不知道生产者是谁，这就需要政府管制， 医疗体系改革，很多时候是经济和伦理的双重考核。人们需要在这两者中找到艰难的平衡点 个人需要对自己的选择负责，即便这个选择可能会伤害自己 过去的中国，所有东西都是国家的，科学家是国家培养，远动员也是。未来，应该更加明确市场化改革中产权的界定问题 任何东西都可以交易，甚至是天气 数字仅仅是数字，如果不会分析，不会比较，数字总会只是死硬的，不会提供真相 事实的真相是人类的终极追求之一]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《了不起的盖茨比》]]></title>
    <url>%2F2019%2F02%2F22%2F%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94%E3%80%8B%2F</url>
    <content type="text"><![CDATA[我们现在所做的中国梦，就如一百年前美国人所做的美国梦，终有一天梦会醒 看过书，看过电影，但终究只有经历过，才会有所体会 《了不起的盖茨比》出版于1925年，是一部以20世纪20年代的纽约市及长岛为背景的中篇小说，奠定了菲茨杰拉德在现代美国文学史上的地位，成了20年代“爵士时代”的发言人和“迷惘的一代”的代表作家之一 爵士时代，一般指一战以后，经济大萧条以前的约十年的时间。第一次世界大战结束了(1918)，经济大萧条(1929)还没有到来，传统的清教徒道德已经土崩瓦解，享乐主义开始大行其道。用菲茨杰拉德自己的话来说“这是一个奇迹的时代，一个艺术的时代，一个挥金如土的时代，也是一个充满嘲讽的时代。” 爵士时代之前的几十年（1860-1918）是美国经济突飞猛进的黄金时期（二次工业革命的迅速成长壮大以及一战的猛捞油水），尤其是工业革命之后的很长一段时间，社会流动性是很大的。意味着底层群众和翻身的机会还是很大的。然而随着社会的发展，贫富差距拉大，逐渐固化的社会结构会增加个体奋斗的成功难度。因为马太效应，一个人的权和钱累积到了一定程度，便会利用手中的资源优势去维系或者掠夺更多的资源。 然后把自己所在的阶层筑上高墙，墙外的人只能靠关系和特权才能进入。这样的话就会导致穷人翻身的机会越来越小，当依靠个人奋斗、后天努力也不能过上出人头地的生活时，美国梦就化作了泡影，化作了一种巨大的讽刺 曾经的美国梦，现在的中国梦，难道不是历史再次上演，这也时刻提醒着现在利益熏心的中国人，给我们一个警告 某种程度上，盖茨比所离开的那个世界，就是今天的世界：无论是说着“美国梦”也好”中国梦“也罢，在世界的不同地方，社会的固化都是无时不刻发生着的。每个社会都有它年轻的时候，当年正在西进的美国，信奉的是”昭昭天命“，认为勤劳勇敢的人们注定会开疆辟壤。从文革动乱中重获新生的中国，相信的是“知识改变命运”，认为只要冲过独木桥，就会有美好的生活。但当盖茨比向对岸的绿灯伸出绝望的手之时，也许他就明白了，这个社会已经不再年轻了，已经变得顽固、傲慢，排斥着新鲜的血液 或许我们多多少少都会对盖茨比这样的人物产生共鸣，他的攀登、他面对的围城、他的失败与伟大，同样被我们所熟知 最后，想说一句，少不读盖茨比。故事过于悲观与现实，但即使梦会碎，也要奋力向前，不然人生意义何在？《一千五百万的价值》中，男主奋力抗争，以为自己拥有了真实的、正确的价值观，想去唤醒沉睡的群众，结局同样悲观，依旧陷入了这个无尽的漩涡中，成为了自己讨厌的一员。So we beat on, boats against the current, borne back ceaselessly into the past.于是我们继续奋力向前，逆水行舟，被不断地向后推，直至回到往昔岁月]]></content>
      <tags>
        <tag>美国梦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑镜》]]></title>
    <url>%2F2019%2F02%2F21%2F%E3%80%8A%E9%BB%91%E9%95%9C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[科技真的改善人类了吗？该迷你剧以极端的黑色幽默讽刺和探讨了这个问题 《天佑吾主》、《一千五百万的价值》、《你的全部历史》以三种不同的科学技术讲述了对生活的影响，分别是社交网络、虚拟现实和记忆胶囊 《天佑吾主》是对现实世界的夸张荒诞的戏剧性揭露，《一千五百万的价值》，我仿佛看到了1984的影子，《你的全部历史》是我思考人也许应该活得糊涂一点，有时候睁一只眼闭一只眼，更能感到幸福 搁在美剧，皇室公主被绑架，之后的情节一定是绑匪提出数以亿计的赎金，然后美国大兵或者美国英雄前去解救，但在这部英剧中，不得不佩服编剧的脑洞，绑匪提出要首相和猪性交的条件以换取公主性命。故事的最后是首相和猪性交了一个多小时，他没得选择，本来是最无辜的人，却因此失去了名誉，也失去了妻子，这不仅让我想起了《万历十五年》中描述的清朝皇帝，都是看似位高权重的人，实则也活得很没有自由，都是这个社会、时代下的傀儡。这部剧让我看到了一个娱乐至上的社会，一个麻木不仁的社会，报社记者为了获取第一手消息，不惜出卖肉体，不惜深入前线，每个社交工具后的人都露出了难得的好奇心，或者说是邪恶的一面，希望看到首相出丑。这看似是民主的社会，却揭露了民主的bug，绑匪发起的这一行为艺术叫做多数人暴政。绑匪提前半小时释放公主，并砍下自己的手指去威胁首相，他就像是这场闹剧的导演，他从没有打算杀死公主，他深知这个社会在面对这场闹剧时，会有什么反应，他是一个观众，也是一个精神病患者，渴望看这场戏剧的上演 和《1984》中一样，人们都活在巨幕之下，但区别在于《一千五百万的价值》没有老大哥的形象，影响人们思想的是接连不断的电视节目。男主花了几乎全部“里程”为了帮助女主登上达人舞台，女主却因此成为了AV女星，男主伤心欲绝痛不欲生。当男主角揣着一片三角形的碎玻璃去参加达人秀节目时，我还以为他会杀掉那些评委，或者血刃赛场，以自己的鲜血控诉这个操蛋的社会和现实，以唤醒这些愚昧的民众明了这个被操控的现实。我以为电影会到这里就结束。 但是不是，当我们的男主角情绪激烈声泪俱下地发表完那番控诉现实的话以后，达人秀的评委说，这真是一场精彩的表演。注意是表演。然后虚拟的观众席上爆发出一阵阵掌声和喝彩声。当你说出了这个社会的真相，希望唤醒那些还处在愚昧当中的人们的时候，他们却以为这只是你另一种新奇的表演模式。这就是《娱乐至死》里面所说的“我们的问题不在于电视为我们展示具有娱乐性的内容，而在于所有的内容都以娱乐的方式表现出来。这就完全是另一回事了。”因此对话无果，所有严肃的控诉被消解为一种娱乐的表达方式 对于这样的一个结果，显然是男主角所没有预想到的。达人秀评委某电视台高层答应给他一个职位，让他到他的电视台以他这种表演方式表演脱口秀。男主角接受了。显然他不是一个坚决的信仰者，在这样的诱惑面前，他做出了自己的选择 我们没有人可以要求他去做一个牺牲者，特别是在这样的牺牲之后，真的能改变什么还存在疑问的时候。但是我只能讲，编剧的这个处理，让我无比叹服 这部剧反映了消费主义娱乐至死之后之后，你转身继续去刷微博打游戏看综艺节目看得哈哈大笑。你以为你看懂了这部剧，却不知道你自己却身处那部剧所阐述的一个逻辑中，你被什么控制着而你却不自知。这言外之意的讽刺，没有什么能比这讽刺更多的了]]></content>
      <tags>
        <tag>科幻</tag>
        <tag>剧情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大国大城》]]></title>
    <url>%2F2019%2F02%2F21%2F%E3%80%8A%E5%A4%A7%E5%9B%BD%E5%A4%A7%E5%9F%8E%E3%80%8B%2F</url>
    <content type="text"><![CDATA[当代中国的统一、发展与平衡，大国需要大城 灵光一现的感觉真的太棒了！看着书前几页的插图，有些就是自己身边的画面，但是从一个社会学家的角度就能看到不一样的东西，这就是跨学科思维，同一样事物，从不同学科的角度去思考，就会有不一样的感受，真棒！]]></content>
      <tags>
        <tag>社会</tag>
        <tag>中国经济</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《躺着赚钱》]]></title>
    <url>%2F2019%2F02%2F21%2F%E3%80%8A%E8%BA%BA%E7%9D%80%E8%B5%9A%E9%92%B1%E3%80%8B%2F</url>
    <content type="text"><![CDATA[躺着赚钱的前提是有一颗知道如何思考的脑袋 看了目录，反倒被最后一章吸引-让孩子站在巨人的肩膀上理解这个世界。学习投资与理财，不是为了学习赚钱手段，而是学习一种思维方式、分析思路，提供一种看待世界的全新视角 让孩子早点接触金钱反倒可以开拓视界与深度，还能体会到复利之美 把财富交给时间 把培养这个世界和投资之间的条件反射，从地理映射到资源，从资源映射到市场，从市场映射到投资 投资界中，能让现在的我看到的利润，都是别人愿意让我看到的，但实际却是一环套一环，只有看透这一切，有自己的准确判断，不要轻信高利润、低风险，克制自己的欲望，否则自己就是被割羊毛的人 幼儿园一直说要投资自己，其实可以通过量化的方式评估自己的价值：如果每月的收入是8000元，相当于自身价值每月带来的收益是8000元，按照自然收益率5%算，则自身价值达到近200万。因此相对于手上那点闲钱，更应该花费大量的精力在自身价值，要明确轻重缓急 投资和修身一样，投资不意味着赚钱，赚钱和亏钱永远是相伴相生的，想要做到多少年化率就要撑到多少的亏损，要不断体会那个让自己感到恐慌的极限值，并以此为戒。要不断打磨自己的性格，不断学习，不能在舒适区待着，即游刃有余做能力范围内的事情，要勇敢的进入学习区，需要刻意的学习补充和优化，现在的自己就处在学习区，庆幸！ 定期将闲钱投资于适合自己的组合中，然后用更多时间打造自己的事业，并在这个过程中把承担风险能力提高 余额宝背后实际就是货币基金，这类基金被规定不能投资股票等资产，因此大部分钱都是存在银行中，但是集合散户的钱去存银行和自己存是大不一样的！因为货币基金和银行约定了高息机构协议存款，银行越需要钱时，就越能谈的一个好价格 量化标准 α：追求超出股指的业绩，力争上游 β：跟着大盘赚 小学幼儿园讲述的是风险最低的固定收益类理财产品（银行理财和余额宝），现在要了解的是公募基金，公募基金在中国运行18年，但百分之七十多的人都是亏损的 市场上三千多只公募基金，大致分为 货币型：幼儿园阶段已经讲过 股票型：股票资产投资比例下限为80% 混合型：保本基金、打新基金（就是用资金参与新股申购，如果中签的话，就买到了即将上市的股票）、定增基金、量化基金（利用数学、统计学、信息技术的量化投资方法来管理投资组合。数量化投资的组合构建注重的是对宏观数据、市场行为、企业财务数据、交易数据进行分析，利用数据挖掘技术、统计技术、计算方法等处理数据，以得到最优的投资组合和投资机会） 指数型：指数基金、指数增强，以特定指数（如沪深300指数、标普500指数、纳斯达克100指数、日经225指数等）为标的指数，并以该指数的成份股为投资对象 债券型：纯债基金、一级债券基金、二级债券基金 QDⅡ：通过QDⅡ通道实现出海投资 买基金相当于雇佣一个团队帮你管钱，就需要收取服务费，因此对于投资基金，管理费用也是要关注的点，而不是只关注预期收益。管理费包含了申购费、管理费（1.0%）、托管费（0.25%）、赎回费等，对于基金公司来说，管理费是很重要的利润来源 基金有A、B、C三种后缀，A类是前端收费，即购买时就收了申购费，B类是后端收费，赎回时补收申购费，C类的基金，收费方式有所不同：免申购、持有满30天免赎回费，但收取销售服务费0.3% 历年的冠军流水的兵，不要轻信以往收益，而是着眼分析未来收益 选基金有时候不如选基金经理 根据市场环境配置相应资产会获得比较好的收益，当如果是A股牛市时，可以选择一些股票比重大的基金，这样收益会高一些 有些基金短时间入榜是因为被送了钱，有些基金巨额的赎回费会算入基金收益中，因此表象就是被全世界抛弃了，依旧能名列前茅 面对冠军基金，要冷静分析为什么成为第一名，是因为新基金，还是因为被大量赎回等等，虽然很难避免局部带来的片面和武断，但是依旧要努力突破界限 因为被抢购而导致体量过大，对基金来说也是拖累，最近（2019年2月）A股大涨导致大量购入基金，已经看到好多基金停止申购。因为规模大之后，基金经理就很难挑选中小盘股票，这些股会因为一买就上涨（俗称滑点），被迫买大盘股，就偏离原有的基金风格，就像突然中了五百万的彩票，大部分都没有花大笔钱的经验，基金经理也是一样 世界上最大的三家基金评级机构是晨星、理柏、惠普，上面会一些指标去了解基金 基准指数：基金经理给自己设定的对手，它的业绩相对于基准的涨落，是基金经理的KPI 标准差：基金总回报率的波动幅度 夏普比率：代表收益/风险，比率越高，相同风险下收益越高 阿尔法系数：系数越高，基金经理的操盘能力越强 高中游戏规则决定了在股票市场中，大多是人都是赔钱的，也正是这些赔钱的人给市场带来了资金和繁荣的动力 股票和基金一样也要收取佣金，因为券商要交钱给证监会征管费和和交易所的经手费用，股票中的费用分为印花税（国家收取）和佣金（券商收取，买卖双向收取） 拥有投资头脑的前提之一就是能用敏锐的眼光发现生活周边的投资价值，当一个新产品突然爆发时，自身要能敏感到能感觉到背后的价值，但是仅有敏锐的眼光还不行，还要去论证它到底是不是眼见为实，只赚能看得懂钱，力所能及的从每件事背后找到赚钱逻辑，这是价值投资的前提 但身边出现新鲜事物之后，就要学着到这个新产品的上下游产业看看，到同类生产企业看看，不断论证价值潜力，生活体验是可以给自己一个投资方向的。试着从身边熟悉的东西开始思考，这相当于把风险转移到自己擅长的东西上 一个行业会经过概念期-导入期-成长期-成熟期-衰退期等阶段，概念期投资是风险投资做的事情，导入期是产业链成熟，政策扶持开始跟进，成长期就是参与的企业越来越多，合力把这个产业从梦想照进现实 要想神探福尔摩斯一样，看着衣服能想到羊毛也许来自巴西草原，纽扣来自欧洲，加工来自中国，只有这样对世界充满好奇，培养对投资机会的敏感度，才能做好长期的投资，而不是大多数股民采取的投机策略，最近（2019年2月）A股大涨的背后是什么，我现在还看不透，但隐约觉得还是存在很大风险，不能轻易入场 大学从全球资产的联动去看对投资的影响，站到高，就不会处在后知后觉的位置被人宰割 现在才发现，学会理财之前，应该好好学学经济学，学学如何分析政策和市场之间的内在逻辑，现在看起来变得有些吃力！ 全球投资，债券为先 黄金更像是保护伞，是投资者在避险（美元下跌，战争、病毒等）的时候的选择，因此国际事件多会影响黄金价格，另一个就是美国货币政策和黄金的联系 美国的量化宽松政策大致是大幅度印美元，提高实体经济环境下货币的供应量，市场利率压低，也就是黄金和银行利息差变小，黄金变得便宜 资产价格跟着市场走，当消息落地，。则价格再根据“预期与现实”的差异做修正 把貌似有规律的部分记在本子上，不断用新的数据验证是投资中必须形成的一个习惯！]]></content>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《面试复习指南》]]></title>
    <url>%2F2019%2F02%2F19%2F%E3%80%8A%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8D%97%E3%80%8B%2F</url>
    <content type="text"><![CDATA[面试题集合 Java基础什么是面向对象面向对象、面向过程 面向对象的三大基本特征和五大基本原则 → 平台无关性Java 如何实现的平台无关 JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala） → 值传递值传递、引用传递 为什么说 Java 中只有值传递 → 封装、继承、多态什么是多态、方法重写与重载 Java 的继承与实现 构造函数与默认构造函数 类变量、成员变量和局部变量 成员变量和方法作用域 基本数据类型8种基本数据类型：整型、浮点型、布尔型、字符型 整型中 byte、short、int、long 的取值范围 什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？ → 自动拆装箱什么是包装类型、什么是基本类型、什么是自动拆装箱 Integer 的缓存机制 → String字符串的不可变性 JDK 6 和 JDK 7 中 substring 的原理及区别、 replaceFirst、replaceAll、replace 区别、 String 对“+”的重载、字符串拼接的几种方式和区别 String.valueOf 和 Integer.toString 的区别、 switch 对 String 的支持 字符串池、常量池（运行时常量池、Class 常量池）、intern → 熟悉 Java 中各种关键字transient、instanceof、final、static、volatile、synchronized、const 原理及用法 → 集合类常用集合类的使用、ArrayList 和 LinkedList 和 Vector 的区别 、SynchronizedList 和 Vector 的区别、HashMap、HashTable、ConcurrentHashMap 区别、 Set 和 List 区别？Set 如何保证元素不重复？ Java 8 中 stream 相关用法、apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因 Collection 和 Collections 区别 Arrays.asList 获得的 List 使用时需要注意什么 Enumeration 和 Iterator 区别 fail-fast 和 fail-safe CopyOnWriteArrayList、ConcurrentSkipListMap → 枚举枚举的用法、枚举的实现、枚举与单例、Enum 类 Java 枚举如何比较 switch 对枚举的支持 枚举的序列化如何实现 枚举的线程安全性问题 → IO字符流、字节流、输入流、输出流、 同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型 BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty → 反射反射与工厂模式、反射有什么用 Class 类、java.lang.reflect.* → 动态代理静态代理、动态代理 动态代理和反射的关系 动态代理的几种实现方式 AOP → 序列化什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全 → 注解元注解、自定义注解、Java 中常用注解使用、注解与反射的结合 Spring 常用注解 → JMS什么是 Java 消息服务、JMS 消息传送模型 → JMXjava.lang.management.、 javax.management. → 泛型泛型与继承、类型擦除、泛型中 KTVE? object 等的含义、泛型各种用法 限定通配符和非限定通配符、上下界限定符 extends 和 super List 和原始类型 List 之间的区别? List&lt;?&gt; 和 List 之间的区别是什么? → 单元测试junit、mock、mockito、内存数据库（h2） → 正则表达式java.lang.util.regex.* → 常用的 Java 工具库commons.lang、commons….、 guava-libraries、 netty → API &amp; SPIAPI、API 和 SPI 的关系和区别 如何定义 SPI、SPI 的实现原理 → 异常异常类型、正确处理异常、自定义异常 Error 和 Exception 异常链、try-with-resources finally 和 return 的执行顺序 → 时间处理时区、冬令时和夏令时、时间戳、Java 中时间 API 格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系 SimpleDateFormat 的线程安全性问题 Java 8 中的时间处理 如何在东八区的计算机上获取美国时间 → 编码方式Unicode、有了 Unicode 为啥还需要 UTF-8 GBK、GB2312、GB18030 之间的区别 UTF8、UTF16、UTF32 区别 URL 编解码、Big Endian 和 Little Endian 如何解决乱码问题 → 语法糖Java 中语法糖原理、解语法糖 语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式 03 阅读源代码 String、Integer、Long、Enum、 BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、 ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet java内存模型多态（重载重写）object方法类访问权限sleep、notify、wait 联系、区别String、stringbuffer、stringbuilder 联系、区别、源码Volatile 原理、源码、与syn区别线程间通信方式线程的各种状态等等等等 集合框架List ArrayListLinkedListVector三者区别，联系，源码 Set HashSetLinkedHashSetTreeSet基于什么实现，内部数据结构，适用场景，源码 Map HashMapweakHashMaoLinkedHashMapTreeMapHashMap与hashtable的区别 内部实现原理、源码、适用场景 并发包ConcurrentHashMap 原理、源码、与hashmap的区别 CopyOnWriteArrayList (set) 什么情况加锁、什么情况不加锁、适用场景 ArrayblockingQueue (Linked) 两者区别，take、put、offer、poll方法原理、源码AtomicInteger (long boolean) 功能 CountDownLatch 功能、场景CyclicBarrier 功能、场景FutureTask (Callable) 源码、场景 ReentantLock 与syn的区别、好处、场景 Condition 与wait、notify的区别、好处 Semaphore 好处、场景 ReentrantReadWriteLock 读写分离的好处、适用场景、源码 Executors 线程池种类、各个作用、适用场景 ThreadPoolExecutor重载方法的参数、各参数作用、源码 并发04 Java 并发编程→ 并发与并行什么是并发、什么是并行 并发与并行的区别 → 什么是线程，与进程的区别线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程 线程与进程的区别 → 线程池自己设计线程池、submit() 和 execute()、线程池原理 为什么不允许使用 Executors 创建线程池 → 线程安全死锁、死锁如何排查、线程安全和内存模型的关系 → 锁CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、 锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 → 死锁什么是死锁 死锁如何解决 → synchronizedsynchronized 是如何实现的？ synchronized 和 lock 之间关系、不使用 synchronized 如何实现一个线程安全的单例 synchronized 和原子性、可见性和有序性之间的关系 → volatilehappens-before、内存屏障、编译器指令重排和 CPU 指令重 volatile 的实现原理 volatile 和原子性、可见性和有序性之间的关系 有了 symchronized 为什么还需要 volatile → sleep 和 wait→ wait 和 notify→ notify 和 notifyAll→ ThreadLocal→ 写一个死锁的程序→ 写代码来解决生产者消费者问题→ 并方包Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic、Semaphore、CountDownLatch、ConcurrentHashMap、Executors JVMJVM五大区 每个区的存储、作用JVM内存模型 类加载机制双亲委派模型 垃圾收集器常用gc算法收集器种类、适用场景fullGC、MinorGC触发条件 JVM优化可视化工具使用日志查询各项参数设置四种引用 → JVM 内存结构class 文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、 堆和栈区别 Java 中的对象一定在堆上分配吗？ → Java 内存模型计算机内存模型、缓存一致性、MESI 协议 可见性、原子性、顺序性、happens-before、 内存屏障、synchronized、volatile、final、锁 → 垃圾回收GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收 GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon） → JVM 参数及调优-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、 -XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold → Java 对象模型oop-klass、对象头 → HotSpot即时编译器、编译优化 → 虚拟机性能监控与故障处理工具jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler Arthas 02 类加载机制 classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw） 03 编译与反编译 什么是编译（前端编译、后端编译）、什么是反编译 JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化） 编译工具：javac 反编译工具：javap 、jad 、CRF IO流BIO 字节流：类型、适用场景字符流：类型、适用场景 NIO类型、适用场景三大组件的联系、使用内存情况 webwebTomcat 结构、流程、源码Servlet 生命周期三种实现方式 Spring→ Servlet 生命周期 线程安全问题 filter 和 listener web.xml 中常用配置及作用 → Hibernate什么是 OR Mapping Hibernate 的懒加载Hibernate 的缓存机制 Hibernate / Ibatis / MyBatis 之间的区别 → SpringBean 的初始化AOP 原理实现 Spring 的IOCSpring 四种依赖注入方式→ Spring MVC什么是 MVC Spring mvc 与 Struts mvc 的区别 → Spring BootSpring Boot 2.0、起步依赖、自动配置、 Spring Boot 的 starter 原理，自己实现一个 starter → Spring Security→ Spring Cloud服务发现与注册：Eureka、Zookeeper、Consul 负载均衡：Feign、Spring Cloud Loadbalance 服务配置：Spring Cloud Config 服务限流与熔断：Hystrix 服务链路追踪：Dapper 服务网关、安全、消息springMVC使用请求流程 IOC/AOP 原理、源码、联系两种动态代理实现 mybatis使用 #、$区别一级、二级缓存 设计模式单例模式工厂模式观察者模式适配器模式模仿方法模式策略模式责任链模式装饰者模式 常用的八种掌握就行，原理，使用单例、工厂、观察者重点设计模式设计模式的六大原则： 开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle） → 了解 23 种设计模式 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 → 会使用常用设计模式单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁 工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会 数据结构二叉树 平衡二叉树二叉查找树红黑树完全二叉树满二叉树 概念、适用场景、时间复杂度、好处坏处B树 B-TreeB+Tree 两者的联系、区别、适用场景 算法直接插入排序二分插入排序希尔插入排序冒泡排序快排选择排序堆排序归并排序 各种排序的思想实现复杂度稳定性如何可以手写 网络TCP 三次握手、四次挥手、各种状态、状态改变和UDP的区别 网络编程知识→ tcp、udp、http、https 等常用协议 三次握手与四次关闭、流量控制和拥塞控制、OSI 七层模型、tcp 粘包与拆包 → http/1.0 http/1.1 http/2 之前的区别http 中 get 和 post 区别 常见的 web 请求返回的状态码 404、302、301、500分别代表什么 → http/3→ Java RMI，Socket，HttpClient→ cookie 与 sessioncookie 被禁用，如何实现 session → 用 Java 写一个简单的静态文件的 HTTP 服务器→ 了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器→ 用 Java 实现 FTP、SMTP 协议→ 进程间通讯的方式→ 什么是 CDN？如果实现？→ DNS什么是 DNS 、记录类型: A 记录、CNAME 记录、AAAA 记录等域名解析、根域名服务器 DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS → 反向代理正向代理、反向代理 反向代理服务器 IO模型 同步、异步、阻塞、非阻塞概念模型种类、各自特点、适用场景如何使用 Linux基础常用命令管道符查看日志相关命令CPU使用命令 01 Java 底层知识→ 字节码、class 文件格式→ CPU 缓存，L1，L2，L3 和伪共享→ 尾递归→ 位运算用位运算实现加、减、乘、除、取余 02 → 不用 synchronized 和 lock，实现线程安全的单例模式→ 实现 AOP→ 实现 IOC→ nio 和 reactor 设计模式 01 新技术 → Java 8 lambda 表达式、Stream API、时间 API → Java 9Jigsaw、Jshell、Reactive Streams → Java 10局部变量类型推断、G1 的并行 Full GC、ThreadLocal 握手机制 → Java 11ZGC、Epsilon、增强 var → Spring 5响应式编程 → Spring Boot 2.0→ HTTP/2→ HTTP/3 02 性能优化 使用单例、使用 Future 模式、使用线程池 选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存 03 线上问题分析 → dump 获取 线程 Dump、内存 Dump、gc 情况 → dump 分析分析死锁、分析内存泄露 → dump 分析及获取工具jstack、jstat、jmap、jhat、Arthas → 自己编写各种 outofmemory，stackoverflow 程序HeapOutOfMemory、 Young OutOfMemory、 MethodArea OutOfMemory、ConstantPool OutOfMemory、 DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow → Arthasjvm 相关、class/classloader 相关、monitor/watch/trace 相关、 options、管道、后台异步任务 文档：https://alibaba.github.io/arthas/advanced-use.html → 常见问题解决思路内存溢出、线程死锁、类加载冲突 → 使用工具尝试解决以下问题，并写下总结当一个 Java 程序响应很慢时如何查找问题 当一个 Java 程序频繁 FullGC 时如何解决问题 如何查看垃圾回收日志 当一个 Java 应用发生 OutOfMemory 时该如何解决 如何判断是否出现死锁 如何判断是否存在内存泄露 使用 Arthas 快速排查 Spring Boot 应用404/401问题 使用 Arthas 排查线上应用日志打满问题 利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError 04 编译原理知识 → 编译与反编译 → Java 代码的编译与反编译→ Java 的反编译工具javap 、jad 、CRF → 即时编译器→ 编译过程词法分析，语法分析（LL 算法，递归下降算法，LR 算法）语义分析，运行时环境，中间代码，代码生成，代码优化 05 操作系统知识 → Linux 的常用命令→ 进程间通信→ 进程同步生产者消费者问题、哲学家就餐问题、读者写者问题 → 缓冲区溢出→ 分段和分页→ 虚拟内存与主存→ 虚拟内存管理→ 换页算法 06 07 数据结构与算法知识 → 简单的数据结构 栈、队列、链表、数组、哈希表、 栈和队列的相同和不同之处 栈通常采用的两种存储结构 → 树二叉树、字典树、平衡树、排序树、 B 树、B+ 树、R 树、多路树、红黑树 → 堆大根堆、小根堆 → 图有向图、无向图、拓扑 → 排序算法稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序 不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序 各种排序算法和时间复杂度 → 两个栈实现队列，和两个队列实现栈→ 深度优先和广度优先搜索→ 全排列、贪心算法、KMP 算法、hash 算法→ 海量数据处理分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。 08 大数据知识 → Zookeeper 基本概念、常见用法 → Solr，Lucene，ElasticSearch在 linux 上部署 solr，solrcloud，新增、删除、查询索引 → Storm，流式计算，了解 Spark，S4在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。 → Hadoop，离线计算HDFS、MapReduce → 分布式日志收集 flume，kafka，logstash→ 数据挖掘，mahout 09 网络安全知识 → XSS XSS 的防御 → CSRF→ 注入攻击SQL 注入、XML 注入、CRLF 注入 → 文件上传漏洞→ 加密与解密对称加密、非对称加密、哈希算法、加盐哈希算法 MD5，SHA1、DES、AES、RSA、DSA 彩虹表 → DDOS攻击DOS 攻击、DDOS 攻击 memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS 如何通过 Hash 碰撞进行 DOS 攻击 → SSL、TLS，HTTPS→ 用 openssl 签一个证书部署到 apache 或 nginx 5 架构篇 01 分布式 数据一致性、服务治理、服务降级 → 分布式事务2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC → Dubbo服务注册、服务发现，服务治理 http://dubbo.apache.org/zh-cn/ → 分布式数据库怎样打造一个分布式数据库、什么时候需要分布式数据库、 mycat、otter、HBase → 分布式文件系统mfs、fastdfs → 分布式缓存缓存一致性、缓存命中率、缓存冗余 → 限流降级Hystrix、Sentinal → 算法共识算法、Raft 协议、Paxos 算法与 Raft 算法、 拜占庭问题与算法、2PC、3PC 02 微服务 SOA、康威定律 → ServiceMeshsidecar → Docker &amp; Kubernets→ Spring Boot→ Spring Cloud 03 高并发 → 分库分表 → CDN 技术→ 消息队列ActiveMQ 04 监控 → 监控什么 CPU、内存、磁盘 I/O、网络 I/O 等 → 监控手段进程监控、语义监控、机器资源监控、数据波动 → 监控数据采集日志、埋点 → Dapper 05 负载均衡 tomcat 负载均衡、Nginx 负载均衡 四层负载均衡、七层负载均衡 06 DNS DNS 原理、DNS 的设计 07 CDN数据一致性 6 扩展篇 01 云计算 IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess 02 搜索引擎 Solr、Lucene、Nutch、Elasticsearch 03 权限管理Shiro 04 区块链 哈希算法、Merkle 树、公钥密码算法、共识算法、 Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名 → 比特币挖矿、共识机制、闪电网络、侧链、热点问题、分叉 → 以太坊→ 超级账本 05 人工智能 数学基础、机器学习、人工神经网络、深度学习、应用场景。 → 常用框架TensorFlow、DeepLearning4J 06 loT 07 量子计算 08 AR &amp; VR 09 其他语言 Groovy、Python、Go、NodeJs、Swift、Rust 7 推荐书籍 《深入理解 Java 虚拟机》《Effective Java》《深入分析 Java Web 技术内幕》《大型网站技术架构》《代码整洁之道》《架构整洁之道》《Head First 设计模式》《maven 实战》《区块链原理、设计与应用》《Java 并发编程实战》《鸟哥的 Linux 私房菜》《从Paxos 到 Zookeeper》《架构即未来》 基于BIO实现的Server端，当建立了100个连接时，会有多少个线程？如果基于NIO，又会是多少个线程？ 为什么？ 通常来说基于NIO实现的Server端，会用多少个线程去处理IO事件，为什么？ 一个典型的客户端集群-&gt;LB-&gt;服务端集群这样的结构中，如客户端采用连接池，长连接的方式，这种设计你觉得可能会出现什么问题？如果客户端采用的是单个长连接的方式呢？如果有问题，你觉得应该怎么解决？ cglib和Java的动态代理相比，具体有什么不同？ 在基于Netty实现FrameDecoder时，下面两种代码的表现会有什么不同？ 第一种 private void callDecode(…) { List&lt;Object&gt; results = new ArrayList&lt;Object&gt;(); while (cumulation.readable()) { int oldReaderIndex = cumulation.readerIndex(); Object frame = decode(context, channel, cumulation); if (frame == null) { if (oldReaderIndex == cumulation.readerIndex()) break; else continue; } else if (oldReaderIndex == cumulation.readerIndex()) { throw new IllegalStateException( &quot;.....&quot;); } results.add(frame); } if(results.size() &gt; 0) fireMessageReceived(context, remoteAddress, results); } 第二种 private void callDecode(…) { int oldReaderIndex = cumulation.readerIndex(); Object frame = decode(context, channel, cumulation); if (frame != null) fireMessageReceived(context, remoteAddress, frame); } 用Executors.newCachedThreadPool创建的线程池，在运行的过程中有可能产生的风险是？ new ThreadPoolExecutor(10,100,10,TimeUnit.MILLISECONDS,new LinkedBlockingQueue(10));一个这样创建的线程池，当已经有10个任务在运行时，第11个任务提交到此线程池执行的时候会发生什么，为什么？ 实现一个自定义的ThreadFactory的作用通常是？ 除了用Object.wait和Object.notifyAll来实现线程间的交互外，你还会常用哪些来实现？ 为什么ConcurrentHashMap可以在高并发的情况下比HashMap更为高效？ AtomicInteger、AtomicBoolean这些类之所以在高并发时高效，共同的原因是？ 请合理的使用Queue来实现一个高并发的生产/消费的场景，给些核心的代码片段。 请实现让10个任务同时并发启动，给些代码片段。 在Java程序运行阶段，可以用什么命令行工具来查看当前Java程序的一些启动参数值，例如Heap Size等。 用什么命令行工具可以查看运行的Java程序的GC状况，请具体写出命令行格式。 用什么工具，可以在Java程序运行的情况下跟踪某个方法的执行时间，请求参数信息等，并请解释下工具实现的原理。 当一个Java程序接收请求，很长时间都没响应的话，通常你会怎么去排查这种问题？ Java进程突然消失了，你会怎么去排查这种问题？ 以下这段代码思路，你觉得在运行时可能会产生的风险是，应该如何改进？ public List getUsers(String[] userIds){ // 从数据库查找符合userIds的user记录 // 将返回的记录组装为User对象，放入List并返回 } 以下两种代码，在运行时有什么不同？为什么？ 第一种 private static final boolean isLoggerDebugEnabled = log.isDebugEnabled(); public void xx(User user){ if(isLoggerDebugEnabled){ log.debug(&quot;enter xx method, user id is: &quot; + user.getId()); } } 第二种 public void xx(User user){ log.debug(&quot;enter xx method, user id is: &quot; + user.getId()); } Java程序为什么通常在刚启动的时候会执行的比较慢，而处理了一些请求后会变快，AOT能带来什么帮助？ Parallel GC、CMS GC、ZGC、Azul Pauseless GC最主要的不同是？背后的原理也请简单描述下？ 请写一段程序，让其运行时的表现为触发5次ygc，然后3次fgc，然后3次ygc，然后1次fgc，请给出代码以及启动参数。 Go的Coroutine和Java的线程机制最主要的不同是？如果Java语言要透明的实现Coroutine，你觉得主要的难点是？ 1、MySQL的复制原理以及流程 基本原理流程，3个线程以及之间的关联； 2、MySQL中myisam与innodb的区别，至少5点 (1)、问5点不同； (2)、innodb引擎的4大特性 (3)、2者selectcount()哪个更快，为什么 3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义 (1)、varchar与char的区别 (2)、varchar(50)中50的涵义 (3)、int（20）中20的涵义 (4)、mysql为什么这么设计 4、问了innodb的事务与日志的实现方式 (1)、有多少种日志； (2)、事物的4种隔离级别 (3)、事务是如何通过日志来实现的，说得越深入越好。 5、问了MySQL binlog的几种日志录入格式以及区别 (1)、binlog的日志格式的种类和分别 (2)、适用场景； (3)、结合第一个问题，每一种日志格式在复制中的优劣。 6、问了下MySQL数据库cpu飙升到500%的话他怎么处理？ (1)、没有经验的，可以不问； (2)、有经验的，问他们的处理思路。 7、sql优化 (1)、explain出来的各种item的意义； (2)、profile的意义以及使用场景； 8、备份计划，mysqldump以及xtranbackup的实现原理 (1)、备份计划； (2)、备份恢复时间； (3)、xtrabackup实现原理 9、mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？ 10、500台db，在最快时间之内重启 . 11、innodb的读写参数优化 (1)、读取参数 (2)、写入参数； (3)、与IO相关的参数； (4)、缓存参数以及缓存的适用场景。 12、你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？ . 13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？ 14、你们数据库是否支持emoji表情，如果不支持，如何操作？ . 15、你是如何维护数据库的数据字典的? 16、你们是否有开发规范，如果有，如何执行的 17、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问 (1)、您是选择拆成子表，还是继续放一起； (2)、写出您这样选择的理由。 18、MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？ . 19、如何从mysqldump产生的全库备份中只恢复某一个库、某一张表？ 开放性问题：据说是腾讯的 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。 Part4:答案 1、MySQL的复制原理以及流程 基本原理流程，3个线程以及之间的关联； 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中； 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中； 从：sql执行线程——执行relay log中的语句； 2、MySQL中myisam与innodb的区别，至少5点 (1)、问5点不同； 1&gt;.InnoDB支持事物，而MyISAM不支持事物 2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁 3&gt;.InnoDB支持MVCC, 而MyISAM不支持 4&gt;.InnoDB支持外键，而MyISAM不支持 5&gt;.InnoDB不支持全文索引，而MyISAM支持。 (2)、innodb引擎的4大特性 插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead) (3)、2者selectcount()哪个更快，为什么 myisam更快，因为myisam内部维护了一个计数器，可以直接调取。 3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义(1)、varchar与char的区别char是一种固定长度的类型，varchar则是一种可变长度的类型(2)、varchar(50)中50的涵义最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)(3)、int（20）中20的涵义是指显示字符的长度但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加020表示最大显示宽度为20，但仍占4字节存储，存储范围不变；(4)、mysql为什么这么设计对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；4、问了innodb的事务与日志的实现方式(1)、有多少种日志；错误日志：记录出错信息，也记录一些警告信息或者正确的信息。查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。二进制日志：记录对数据库执行更改的所有操作。中继日志：事务日志：(2)、事物的4种隔离级别隔离级别读未提交(RU)读已提交(RC)可重复读(RR)串行(3)、事务是如何通过日志来实现的，说得越深入越好。事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”5、问了MySQL binlog的几种日志录入格式以及区别(1)、binlog的日志格式的种类和分别(2)、适用场景；(3)、结合第一个问题，每一种日志格式在复制中的优劣。Statement：每一条会修改数据的sql都会记录在binlog中。优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).使用以下函数的语句也无法被复制： LOAD_FILE() UUID() USER() FOUND_ROWS() SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)同时在INSERT …SELECT 会产生比 RBR 更多的行级锁2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的 变更。6、问了下MySQL数据库cpu飙升到500%的话他怎么处理？(1)、没有经验的，可以不问；(2)、有经验的，问他们的处理思路。列出所有进程 show processlist 观察所有进程 多秒没有状态变化的(干掉)查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,,,,当然不排除网络状态突然断了,,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)7、sql优化(1)、explain出来的各种item的意义；select_type表示查询中每个select子句的类型type表示MySQL在表中找到所需行的方式，又称“访问类型”possible_keys指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用key显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULLkey_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度ref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值Extra包含不适合在其他列中显示但十分重要的额外信息(2)、profile的意义以及使用场景；查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等8、备份计划，mysqldump以及xtranbackup的实现原理(1)、备份计划；这里每个公司都不一样，您别说那种1小时1全备什么的就行(2)、备份恢复时间；这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考20G的2分钟（mysqldump）80G的30分钟(mysqldump)111G的30分钟（mysqldump)288G的3小时（xtra)3T的4小时（xtra)逻辑导入时间一般是备份时间的5倍以上(3)、xtrabackup实现原理在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。9、mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？–skip-extended-insert[root@helei-zhuanshu ~]# mysqldump -uroot -p helei –skip-extended-insertEnter password:KEY idx_c1 (c1),KEY idx_c2 (c2)) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=latin1;/!40101 SET character_set_client = @saved_cs_client /;– Dumping data for table heleiLOCK TABLES helei WRITE;/!40000 ALTER TABLE helei DISABLE KEYS /;INSERT INTO helei VALUES (1,32,37,38,’2016-10-18 06:19:24’,’susususususususususususu’);INSERT INTO helei VALUES (2,37,46,21,’2016-10-18 06:19:24’,’susususususu’);INSERT INTO helei VALUES (3,21,5,14,’2016-10-18 06:19:24’,’susu’);10、500台db，在最快时间之内重启puppet，dsh11、innodb的读写参数优化(1)、读取参数global buffer pool以及 local buffer； (2)、写入参数；innodb_flush_log_at_trx_commitinnodb_buffer_pool_size (3)、与IO相关的参数；innodb_write_io_threads = 8innodb_read_io_threads = 8innodb_thread_concurrency = 0 (4)、缓存参数以及缓存的适用场景。query cache/query_cache_type并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更 第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache 12、你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？监控的工具有很多，例如zabbix，lepus，我这里用的是lepus 13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等 14、你们数据库是否支持emoji表情，如果不支持，如何操作？如果是utf8字符集的话，需要升级至utf8_mb4方可支持 15、你是如何维护数据库的数据字典的？这个大家维护的方法都不同，我一般是直接在生产库进行注释，利用工具导出成excel方便流通。 16、你们是否有开发规范，如果有，如何执行的有，开发规范网上有很多了，可以自己看看总结下 17、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问(1)、您是选择拆成子表，还是继续放一起；(2)、写出您这样选择的理由。答：拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择 18、MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？答：InnoDB是基于索引来完成行锁例: select * from tab_with_index where id = 1 for update;for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起 . 19、如何从mysqldump产生的全库备份中只恢复某一个库、某一张表？答案见：http://suifu.blog.51cto.com/9167728/1830651 开放性问题：据说是腾讯的一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。1、如果A表TID是自增长,并且是连续的,B表的ID为索引select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200; 2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。select * from b , (select tid from a limit 50000,200) a where b.id = a .tid; 数据库数据库三范式 主从复制 原理、实现 读写分离 原理、实现 事务 类型使用可能引起的问题 存储引擎 InnoDBMyISAM区别、联系、锁机制、适用场景 索引 类型使用什么样的字段适合做索引SQL优化 1、一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15 ？2、mysql的技术特点是什么？3、Heap表是什么？4、mysql服务器默认端口是什么？5、与Oracle相比，mysql有什么优势？6、如何区分FLOAT和DOUBLE？7、区分CHAR_LENGTH和LENGTH？8、请简洁描述mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？9、在mysql中ENUM的用法是什么？10、如何定义REGEXP？11、CHAR和VARCHAR的区别？12、列的字符串类型可以是什么？13、如何获取当前的mysql版本？14、mysql中使用什么存储引擎？15、mysql驱动程序是什么？16、TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？17、主键和候选键有什么区别？18、如何使用Unix shell登录mysql？19、 myisamchk是用来做什么的？20、mysql数据库服务器性能分析的方法命令有哪些?21、如何控制HEAP表的最大尺寸？22、MyISAM Static和MyISAM Dynamic有什么区别？23、federated表是什么？24、如果一个表有一列定义为TIMESTAMP，将发生什么？25、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？26、怎样才能找出最后一次插入时分配了哪个自动增量？27、你怎么看到为表格定义的所有索引？28、LIKE声明中的％和_是什么意思？29、如何在Unix和mysql时间戳之间进行转换？30、列对比运算符是什么？31、我们如何得到受查询影响的行数？32、mysql查询是否区分大小写？33、LIKE和REGEXP操作有什么区别？34、BLOB和TEXT有什么区别？35、mysql_fetch_array和mysql_fetch_object的区别是什么？36、我们如何在mysql中运行批处理模式？37、MyISAM表格将在哪里存储，并且还提供其存储格式？38、mysql中有哪些不同的表格？39、ISAM是什么？40、InnoDB是什么？41、mysql如何优化DISTINCT？42、如何输入字符为十六进制数字？43、如何显示前50行？44、可以使用多少列创建索引？45、NOW（）和CURRENT_DATE（）有什么区别？46、什么样的对象可以使用CREATE语句创建？47、mysql表中允许有多少个TRIGGERS？48、什么是非标准字符串类型？49、什么是通用SQL函数？50、解释访问控制列表51、mysql支持事务吗？52、mysql里记录货币用什么字段类型好？53、mysql数据表在什么情况下容易损坏？54、mysql有关权限的表都有哪几个？55、mysql中有哪几种锁 数据库知识 → MySQL 执行引擎 → MySQL 执行计划如何查看执行计划，如何根据执行计划进行 SQL 优化 → 索引Hash 索引、B 树索引（B+树、和B树、R树） 普通索引、唯一索引 覆盖索引、最左前缀原则、索引下推 → SQL 优化→ 数据库事务和隔离级别事务的隔离级别、事务能不能实现锁的功能 → 数据库锁行锁、表锁、使用数据库锁实现乐观锁、 → 连接内连接，左连接，右连接 → 数据库主备搭建→ binlog→ redolog→ 内存数据库h2 → 分库分表→ 读写分离→ 常用的 NoSql 数据库redis、memcached → 分别使用数据库锁、NoSql 实现分布式锁→ 性能调优→ 数据库连接池]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《少有人走的路》]]></title>
    <url>%2F2019%2F02%2F17%2F%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8B%2F</url>
    <content type="text"><![CDATA[人生苦难重重 马上就要进入新的阶段，看看这本书，给自己打打鸡血。大概初中的时候第一次读这本，当时的感觉这不是本好书，理解或者说体会不了，如今这本书有一次又一次的出现在我眼前，于是重新拿起这本书 人可以拒绝任何东西，但绝不可以拒绝成熟。拒绝成熟，实际上是在回避问题、逃避痛苦。回避问题和逃避痛苦的趋向，是人类心理疾病的根源，不及时处理，你就会为此付出沉重的代价，承受更大的痛苦 人生是面对一连串的问题，并解决的过程。就像写程序一样，不要妄想写出没有BUG的系统，人生也不可能既舒适又顺利。学会如何解决问题，如何解决BUG，会激发我们的智慧和勇气 承受面对问题和解决问题的痛苦，并从痛苦中学到更多的东西，也正是在这个不断解决的过程中，心智才能不断成熟和成长。聪明和成熟的人不会因为害怕痛苦就选择逃避，他们会迎上前去，坦然承受问题到来的痛苦直至解决它 兜兜转转好久去寻找引起自己头疼的原因，脑子里就像有个死结在，轻微抑郁，精力也没有之前那么充沛，一个人独处的时候，很难让自己闲下来，脑子总是紧绷绷的，趁着放寒假的时候，好好休息并思考了为什么会这样。一年半高强度的学习，没有双休，每天十几个小时的学习，放任何一个人都会撑不住，再如何自律也不是这样不放过自己。总是口口声声的说要思想开放，学会包容不同的新思想，却忘记了学习如何放弃旧有的思想。要放弃自己年轻活力的观念，放弃以自我为中心的观念，一直想从书中寻找答案，却没有审视自己内心原有的错误或者陈旧的观念。把看书作为一个任务，每次都给自己定下任务，而不是把看书作为一种享受，一种精神洗礼。这样想想自己好像骗了自己好久 神经官能症患者为自己强加责任，不管做什么，他们都觉得自己能力不及他人，不够资格，因而缺乏勇气和个性，总是做出错误的判断，自己的性格更偏向神经官能症，人格失调症患者则不愿承担原本属于自己的责任，他们的行为完全是迫于外界压力的无奈之举，缺乏自主判断和承担责任的能力 判断自己该为什么事和什么人负责，这是一个永远存在的难题 你不能解决问题，你就会成为问题 昨天睡前思考了很久，去打破自己所有的认知和人格，还发现自己已经丧失了玩的能力，不知道如何让自己空下来，被书这种东西深深的捆绑住，陷入了一个深深的泥塘中 要维持自律，必然会碰到各种各样的困难，在解决这些困难的过程中，心智不断成长和成熟。自律是人类心灵进化的工具和手段。自律又意味着自我束缚，是什么推动人类去甘愿承受苦难，我们把这种力量归结为爱，爱是自律的原动力。因此人们常说要想做好一件事，首先要热爱，之后才愿意投入精力去做到完美 心智成熟到底是什么？想想成熟到底是什么意思，果实成熟就是内部分子组合成了一定有序的结构。而心智的成熟，就是不断解答自己内心的疑惑，理顺自己的思想，明白了一些终极问题，并为自己认为有意义的价值不断努力 什么是爱？没人能准确定义，也许是《星际穿越》中说的“超越人类理解的另一维度的东西”，也许是我所猜测的和量子有某种关联的东西，不管怎么样，都不能忽视爱的存在和作用 人人都有自己的信仰，对人生的认识和了解都属于信仰的范畴，人们又有着或宽阔或狭隘的人生观和世界观，只是未必说出来而已 一个人的信仰与世界观，只有一小部分属于意识层面，多数人无法体验到自己的潜意识的内容，以及对世界真正的看法和整体的观念。这意味着表面上人们信仰着善良的上帝，但潜意识中可以还信奉着相反的邪恶的上帝 人的信仰多来自文化环境，并容易接纳周围人的信仰，并把口耳相传的东西视为真理。人始终无法超越文化、父母和童年经历，只能依靠狭窄的人们参照系来待人处事，我们依赖的经验并不是放之四海而皆准的法则 要建立和现实相适应的信仰和世界观，我们必须不断学习，增进对世界的认知，我们必须突破自我界限，涉足更广阔的领域，修正我们的地图 有些人面对难以想象的打击时，也不至于自寻死路，而有些人哪怕小小的挫折，都会产生轻生的念头。是什么力量在引导着人们 越来越多的人认为，所有疾病都属于心理学的范畴，心理出现问题后，导致身体免疫系统失效，抵抗力下降，进而产生疾病 爱的唯一目的乃是促进心智的成熟和人性的进步 爱的真正对象应该是人。只有人类的心灵，才有成长与进步的能力 真正的爱的本质之一，或是希望对方拥有独立自主的人格 爱不是无原则地接受，也包括必要的冲突，果断的拒绝和严厉的批评 区别爱与非爱的关键不是自私或无私，而是行为的目的。真爱的目的永远都是促进心智的成熟 爱是行动，不是空想 拓展自我界限就如同走路一样，每多走一步，都要逐步对抗与生俱来的惰性，抵御因恐惧二产生的排斥心理 倾听不是容易的事情，它是对他人表达关注的具体表现 在倾听时，要把个人想法和欲望放在一边，努力去体会说话人的内心世界和感受 勇气，并不意味着永不恐惧，而是面对恐惧时能够坦然行动，克服畏缩心理 完整的人生势必伴随着痛苦，其中最大的痛苦之一，就是心爱之人的逝去 生命的本质就是不断改变、成长和衰退的过程 要正视死亡，虽然听上去可怕，但却可以丰富心灵，让我们变得更加睿智、理智和现实，进而去体会人生的宏达意义 人生的最大一场冒险，就是成长。走出童年的懵懂和混沌的状态，迈向成年的理智和清醒 人生唯一的安全感，来自于充分体验人生的不安全感 每天面临的挑战也是成长的机遇 动辄和所爱的人发生冲突，多半是意味自己在见识和道德上高人一等 诚实和谦虚，意味着有自知之明。善于自我反省的人，才会表现出诚实和谦虚 给他人提出批评之前，要经过反思，不要好为人师 冲突和批评，是人际关系中特殊的控制能力，恰当作用可以改进人际关系 真正懂得爱的人，必须懂得自我约束，去掌控情感，到这不意味着生活缺少激情和活力，反而会使情感更为深刻和成熟 认为小我应该为大我牺牲的极端集体主义和一味强调个人价值的极端基本主义都是错误的 理想的婚姻是分工和合作并存的制度，双方都有责任照顾家庭，也要追求各自的进步，攀登个人价值的人生巅峰 一个人的信仰，只有一小部分是属于意识层面 只有学习和进步，才能摆脱昔日经验的限制 可以相信医生，科学家的二手知识，但不能接受二手信仰来生活 科学本身是一种信仰，其包含了众多信条，如宇宙是真实可观测的；人类容易受偏见和迷信误导，在解释宇宙时犯错等等 科学作为一种更好的信仰的一个原因就是其显著的国际性，它超过了自身文化的小宇宙，更加接近人类和世界的本质 科学家成熟的标志之一就是能够意识到，像其他任何宗教一样，科学也可能流于教条主义 对于别人教给我们的一切，包括通常的文化观念以及一切陈规旧习，采取冷静和怀疑的态度，才是心智成熟不可或缺的元素 人们不经意说出的奇怪的话，做出的奇怪的举动，往往是受到压抑的东西的一种自然流露 当意识不愿意承认处理消极感受的痛苦时，这种感受就会被转入潜意识，进而引发心理疾病 为在复杂的社会上获得生存，找到自己的位置，每个人都带上了面具 意识塑造的自我，与潜意识塑造的自我，有时候相距甚远，但潜意识终究会看清真相 我们在教育别人的时候，并不是在把某种新的东西强塞进他们的思维，而是把这种东西从他们的思维中引导出来 肉体的衰老是不可避免的结果，但心灵会不断进化，乃至发生根本性的改变 人们总是倾向于把事物理解为实质，但总有些东西超过了实物的存在，无法用看得见摸得着的东西来验证 进化过程本身就是一个奇迹，因为它违背熵的自然规律。自然进化朝着越来越有序的方向发展，而自然法则则是朝着混乱去发展 心灵的成长，就像自然进化，要不断去对抗自然法则，和忠于现状的力量做抗衡，从原始的心灵中发展出人性，进而实现自我完善，并推动社会文化的进步 懒惰是人类的原罪之一。但是懒惰不是通常意义上的。这种懒惰是恐惧改变，恐惧接受新的信息和事物。接受新的事物，就需要承受更大的风险，也意味着会失去现有的一切 由于懒惰，人们宁可维持可怜的现状，也不愿意通过努力摆脱困境 一个人心智越成熟，越能感觉到自身的懒惰，越是自我反省，越能找到懒惰的痕迹。与熵的对抗是永恒的战斗 邪恶是为所欲为，横行霸道的懒惰 世界上存在两种力量，政治的力量和心灵的力量 知道的越多，就更加难以采取行动 心智越成熟的人，越不可能推卸责任和过错，他们没有跟自己处境和感受相当的人，以便容许自己释放压力，发泄痛苦。这会让他们在心智成熟的道路上，感受到孤独 我们都趋向于逃避一切痛苦和折磨，因此对某些消极现象可能熟视无睹，对残酷的现实可能不闻不问，目的只是为了捍卫自己的意识 由于人们采取上述防御措施，就会阻碍个人的认知，使得意识与现实脱节，进而产生严重的心理疾病 恩典来自于潜意识，但体内的惰性，却使我们去拒绝恩典。因为恩典的降临，意味着更多的责任，更大的权利。唯有深入认识这份恩典，体验他的力量，内心才会产生宁静]]></content>
      <tags>
        <tag>成长</tag>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《1984》]]></title>
    <url>%2F2019%2F02%2F02%2F%E3%80%8A1984%E3%80%8B%2F</url>
    <content type="text"><![CDATA[恐怖的1984，多一个人看奥威尔，对自由就多一分保障。对文化大革命、极权政治和思想禁锢有了体会 看了小部分，就跑过来写文字。自己很容易把书中透露的恐惧带到现实社会中去，去思考现实社会是不是也是这样一个“老大哥”社会，我想不管是哪个年代，只要由政治存在的地方，多少都能看到1984的影子？这就是这本书令人恐怖的地方，害怕所处的环境会朝着1984迁移 在1984中，历史从来不是一面镜子，而是一块黑板，所有不符合现实的记录都可以被擦除和修改，最可怕的不是历史可以被修改而是后人察觉不到历史被修改的痕迹，可是后人有谁敢说前人记录的历史是绝对客观真实的呢？ 新话的全部目的是要缩小思想范围，到最后，我们将会让思想罪变得不可能再犯，因为没有单词可以表示它。语言完美之时，就是革命完成之日 正统意味着不去想、不必想，正统思想意味着无意识 无产阶级总是缺乏全局观念，他们只关注细枝末节的不满，那些罪大恶极的事他们总是视而不见 伪造过去的眼前利益显而易见，但最终动机却深不可测。如果历史和外部世界只存在于意识当中，而意识本身又不可控制，那又该如何？我们要捍卫那些明了的、朴素的、真实的一切，不言自明的就是真理，世界是客观存在的，其规律不会改变 所谓自由，就是可以说二加二等于四的自由 彩票是无产阶级活下去的主要理由，也许不一定是彩票，但是具有的同样性质的美好事物，这是他们人生的乐趣，愚蠢的证据，止痛的灵丹和大脑的兴奋剂 对性的压抑会导致人们的歇斯底里，而这正是党所希望的，因为它能转化成对战争的狂热和对领袖的崇拜。像游行、欢呼、挥舞旗帜无非是变了质的性欲的宣泄 在看不到未来的现在苟且偷生，好像是人难以克制的本能，就好像只要由空气存在，人的肺部总要继续呼吸一样 大约从新石器时代结束之后，世上的人就被分为三类：上等、中等和下等，他们会被冠以不同的名称，相对人数和对待彼此的态度因时代而异，然而社会的基本结构却从未改变，即使经历了天翻地覆的动荡和似乎无法逆转的转变，依然能恢复原有的格局，这三个阶层的目标完全不可调和。上层阶级的目标是保住他们现有的地位，中等阶级的目标是和上等阶级调换位置，下等阶级就是要消灭一切差异，创建一个人人平等的社会。三个阶级之间的斗争会一次次上演。中等阶级会假装为了自由和正义去拉拢下等阶级去推翻上等阶级统治，达到目的后又会将下等阶级踢回受奴役的地位，从下等阶级的视角来看，历史的变更只是主宰者的名称变了，从未向人人平等的理想迈出一步。就像三角形一样，三这个格局才是唯一稳定存在的，回想一家三口、三国，和数字3都密切相关，世界最终会被分为三个超级大国 现代战争的主要目的是消耗机器制造的产品，而不是提高人民的生活水平 人人平等本就是伪命题，这样的社会是不可能长期稳定，从长远看，等级社会只会建立在贫穷和无知的基础上，我们既不能回到农业社会，又不能停止工业生产，如何让工业的车轮持续运转却不增加世界的财富，惟一的办法就是连续不断的战争 战争的根本行为是毁灭，不一定毁灭人，但一定毁灭人的劳动成果，否则这些劳动成果就会让人们的生活过于舒适，从长远看，这会使人们过于聪明。战争总是努力计划将可能存在的超过本国人们最低需求的那部分物资消耗殆尽 最好的书就是将已知的东西告诉自己，书中的思想和自己的相近，但更加有力、系统和无畏 人类面临两种选择，自由或者幸福，而对大多数人而言，选择幸福更好 什么是权力（power）？能改变个人或者团体的力量。以前总在想军队的首长有什么破本事，随便一个军人用蛮力就能替代它的位置，现在想想，这种想法真是愚蠢！ 从无产阶级那里，没有什么可以担心的。你不去惹他们，他们就会一代又一代地、一个世纪又一个世纪地做工、繁殖、死亡，不仅没有造反的冲动，而且也没有能力理解可以有一个不同于目前世界的世界。只有在工业技术的发展使得你必须给他们以较高的教育的时候，他们才会具有危险性；但是由于军事和商业竞争已不复重要，民众教育水平实际已趋下降。群众有什么看法，或者没有什么看法，已被视为无足轻重的事。因为他们没有智力，所以不妨给予学术自由。而在一个党员身上，哪怕在最无足轻重的问题上都不容有丝毫的不同意见 “知与不知，知道全部真实情况而却扯一些滴水不漏的谎话，同时持两种互相抵消的观点，明知它们互相矛盾而仍都相信，用逻辑来反逻辑，一边表示拥护道德一边又否定道德，一边相信民主是办不到的一边又相信党是民主的捍卫者，忘掉一切必须忘掉的东西而又在需要的时候想起它来，然后又马上忘掉它，而尤其是，把这样的做法应用到做法本身上面——这可谓绝妙透顶了：有意识地进入无意识，而后又并不意识到你刚才完成的催眠。即使要了解”双重思想”的含义你也得使用双重思想。” 其实我们每天都生活在这种“双重思想”的迷宫里。我们总是那么的无奈。我们总认为我们是自由的，却又下意识的提醒自己要屈服于现实。我们总认为我们的未来是光明，却又常常觉得自己的前途暗淡。我们一直希望脱离工作、金钱的羁绊，可是却会下意识的寻找更高的薪酬。我们总说现在的权力机构是如此的腐败黑暗，却削减脑袋的挤进权利机构。我们总是这样言行不一致，生活在矛盾中 双重思想意味着一个人在头脑中同时保持并接受两种相互矛盾的想法的能力。“双重思想”这个概念的重要性我看是远远超过这个概念本身。双重思想这个概念不仅让我看到了我们当下的环境是如此恶劣，而且还看到我们内心的挣扎与矛盾。这一切，除了外在因素以外，难道没有我们内心的因素吗？固然，环境对我们的影响是很大的，我不否认。但作为个体，我更注重反思我内心矛盾的心理原因。对于外在的环境，我们大多数人都是虚弱无力的。不过面对自己，我们自己的内心能改变吗？我们的心真的是一成不变的的吗？显然不是 按照这个思路，我觉得，改变，从自己做起。我想，这个时代缺的不是愤青，也不是阿Q——缺的是真正会思考的人 《1984》是一本超越时代的书，任学者怎么研究都不会过时 题外话：突然害怕自己老了之后，也会成为一个老古董，思想顽固，跟不上时代，我不想成为这样的人]]></content>
      <tags>
        <tag>极权</tag>
        <tag>社会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.io]]></title>
    <url>%2F2019%2F01%2F28%2Fjava-io%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.lang]]></title>
    <url>%2F2019%2F01%2F28%2Fjava-lang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Java基础类。最重要的类是Object（它是类层次结构的根）和 Class（它的实例表示正在运行的应用程序中的类）。把基本类型的值当成一个对象来表示通常很有必要。包装器类 Boolean、Character、Integer、Long、Float和Double 真的庆幸自己现在就开始看源码，就像发现了金矿一样兴奋，很多书中看到的积累的迷惑在源码面前都卸下了面具 object 类 数据类型类 线程类 字符串类 (String 类和 StringBuffer 类 ) 系统及运行类 (System 类和 Runtime 类 ) 错误和异常处理类 (Throwable 、 Exception 、 Error) 过程类 (process) 数学类 (Math) Error和Exception每个包里都会定义一些类、错误、异常和接口。Error和Exception都继承自父类java.lang.Throwablejava.lang.Error: An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. Error是unchecked exceptionsjava.lang.Exception: The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch. Exception分为RuntimeException和checked exceptions ClassStringRunnableThe interface should be implemented by any class whose instances are intended to be executed by a thread. The class must define a method of no arguments called run]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JDK1.8源码阅读系列》]]></title>
    <url>%2F2019%2F01%2F28%2F%E3%80%8AJDK1-8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%E3%80%8B%2F</url>
    <content type="text"><![CDATA[开始进入阅读源码阶段，加油！！！ 把本地源码压缩包导入idea项目中后，要将文件夹标志为resources文件，这样才能生成类继承结构，然后在想查看的类上ctrl+alt+shift+u生成类继承图 lang：常用数据类型 io：输入输出流 util：常用的工具类 nio：非阻塞式io net：网络编程 rmi：远程方法调用 security：安全 sql：数据库连接 text：操作文本 math：科学计算 applet：java的小应用程序 awt：java的画图工具包 beans：主要是类的定义和修饰 每个包下面又有很多子包，像applet包如今没有多大价值，就不深究，重点放在lang、util、io、nio等包中，学习编码风格和设计模式 目录 java.lang java.io]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码阅读]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[学习如何阅读源码 最近在学习Spring框架，想去找一些好一点的书籍，但找来找去，都没有遇到合适的，答案反倒指向了阅读源码这条路，我这才意识到自己似乎跨进了新的阶段，通过阅读源码来进行学习，才会更加直接和深刻，但如何阅读几十万行的源码也是一门技术，因此在在这里记录一些自己的小技巧 首先需要告诉自己阅读源码到底是为了什么？千万不要为了看源码而看源码，要有着手点，知道自己这次看源码的目的是什么，要以任务驱动，不要陷入源码的海洋中。看源码最重要的是求知欲，由求知欲产生的是各种各样的问题，带着这些问题去看源码，才是最有效果的 对我来说我选择阅读源码的第一驱动力就是好奇，我在另一篇文章中也提起过，我在学习计算机的很长一段时间中脑子都会不自觉地想要理清代码是如何转换到0和1的，思考问题的习惯永远都是往下走，而软件工程要传递的思想却是往上走，也就是封装。这种思维惯性就会不自觉的领着自己往底层去探究，也就一步步领着自己走向了阅读源码的道路。其次的原因就很现实为了面试，提升自我价值，为了更高的薪资待遇。但自己从来没有觉得阅读源码是为了提高逼格 源码中我们可以学到很多东西，学习别人高效的代码书写、学习别人对设计模式的熟练使用、学习别人对整个架构的布局，等等。但切记阅读源码也要带着批判思维，没有任何一份源码是完美的，总能找出其中的不足。会使用固然重要，但知道为什么这么使用同样重要。从模仿中学习，从模仿中创新。 如果说框架或者项目是自己的女朋友，那了解女朋友的第一途径就是和女朋友亲自打交道，深入了解源码，不断使用这个框架，不断和女友在一起打磨，但女孩子总是让人猜不透，因此我们也需要通过其他方式来了解 最直接的方式就是官方参考文档，亲生父母往往对孩子是最了解的，对孩子的描述也是最详细的；比如Spring Boot Reference Guide就是对springboot最详细的描述，怎么样使用springboot、springboot特性等等，通过此指南，springboot在你面前一览无遗；但是，springboot毕竟是外国人的孩子，如果英语不好，估计读起来有点头疼了，不过我们有google翻译呀，咬咬牙也是能看的。源码世界的丈母娘、老岳丈是非常慷慨的！ 其次是书籍，国外优秀的有很多，国内也不乏好书，比较推荐此方式，自成体系，让我们掌握的知识点不至于太散。这就是好比是源码的闺蜜，对源码非常了解，重点是挺大方，会尽全力帮助我们了解源码 再次就是博客，虽然可能觉得知识点比较散，但是针对某个知识点却特别的细，对彻底掌握非常有帮助，园子内就有很多技术大牛，写的博客自然也是非常棒，非常具有学习价值。当然还有社区、论坛、github、码云等等。这就是源码的朋友圈，我们从中也能获取到非常多关于源码的信息 上面四种方式其实也对应了我们学习一项技术的不同方式，最简单直观的就是逛社区，这能让我们先从表面去了解一个人，从书籍之后层层往上，让我们一步步接近最真实的面目，这就是学习的不同阶段和境界吧]]></content>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《NoSQL精粹》]]></title>
    <url>%2F2019%2F01%2F27%2F%E3%80%8ANoSQL%E7%B2%BE%E7%B2%B9%E3%80%8B%2F</url>
    <content type="text"><![CDATA[NoSQL = Not Only SQL 题外话：这本书的作者是Thoughtwork公司的首席科学家，然后就去了解这家公司，真心喜欢这家公司的文化 关系型数据库和NoSQL并不矛盾，未来是混合持久化的趋势 关系数据库是尽量不出现相同数据，而非关系数据库则是通过牺牲一些重复数据来获得性能，即时间 什么是关系型数据库？什么是非关系型数据库呢？关系型数据库中存储的数据都是有一定的关系的，如一个库，一张表，存储了名字：张三；年龄：20；性别：男。这三个数据是有关系的，因为他们都是在描述同一个人。但是如果是Redis这种键值式数据库呢，只知道年龄20。至于这个年龄20是在说谁的年龄，Redis并不关心。如果是MongoDB这类的文档式数据库，名字、年龄、性别。这三个属性是一个整体。但是，每个人都必须要记录名字、年龄、性别。而第二个人，李四，假如他多了一个属性，爱好，那么整个表都需要加这个属性吗？MongoDB不需要，文档与文档之间没有必然的联系。也就是说，第一个人有3个属性，第二个人可以有4个属性 关系型数据库的最大缺点就是impedance mismatch，关系模型把数据组织成table和row，或者说是relation和tuple，SQL操作的数据都是relation，但是relational tuple包含的值必须很简单，不能包含nested record或list，但是内存中的数据结构则没有这个限制，因此将内存中复杂一点的数据结构保存到磁盘时，就需要进行关系转换，也就发生了开头说的impedance mismatch，Spring框架集成的对象-关系映射框架（Hibernate、Mybatis）就是为了解决这个问题，而NoSQL或者说是从底层解决这个问题 在Web服务交互中，可以使用嵌套记录以及列表等数据结构，这些数据通常放在XML或者JSON中 互联网不断增加的规模，需要更多的计算资源来应对。一种方式是scale up，另一种是scale out，纵向扩展就需要更大的计算机，这样成本太高，因此选择横向扩展，通过多个计算机组成集群。但是关系数据库不是设计给集群用的，而且商用数据库都是按照单台服务器收费，成本高，因此需要寻找其他解决途径 NoSQ并没有官方的定义，只要是不使用关系模型、开源、基本上不使用SQL的数据库，都可以称为NoSQL 选用NoSQL的两个主要原因 待处理的数据量很大，或对数据访问的效率要求很大，从而必须将数据放在集群上 想采用一种更方便的数据交互方式来提高程序开发效率 数据模型关系模型把存储模型分为元组（行），这是一种受限的数据结构，在NoSQL中，则使用更复杂的结构存放信息，称为聚合（aggregate） 聚合数据模型的特点就是把经常访问的数据放在一起（聚合在一块）； 这样带来的好处很明显，对于某个查询请求，能够在与数据库一次交互中将所有数据都取出来； 当然，以这种方式存储不可避免的会有重复，重复是为了更少的交互；聚合结构对某些交互有利，却阻碍另一些交互；不支持跨越多个聚合的ACID事务 下面的数据模型有点难理解，可以参考文章开头的实例： 键值数据模型：聚合不透明，只包含一些没有多大意义的大块信息，这意味着聚合可以存储任意数据，只能通过键查找 文档数据模型：可以看到结构，定义了允许的结构和数据类型，可以使用聚合中的字段查询，只获取一部分聚合 列族模型：是两级聚合结构 聚合是作为交互单元的数据集合，使数据库在集群上管理数据存储更加方便。当数据交互大多在同一聚合内执行时，选择面向聚合的数据库，否则选择聚合无知数据库 在关系数据库中同时修改多条记录，可以放在事务中，这样在改动时能保证操作的ACID属性，在面向聚合数据库中获取数据以聚合为单位，只能保证单一聚合内的原子性，如何涉及多个聚合，就需要类似于事务的机制保证原子性 如果待处理的数据存在大量关系，即联结，更应该选择关系数据库，但其实关系数据库在这方面也表现不好，大量JOIN谓词使得SQL语句难写，查询效率也变低，因此出现另一种NoSQL数据库 一般NoSQL都是为了在集群环境下运行，图数据库催生的动机则是为了解决上述问题。在捕获社交网络、产品偏好等包含复杂关系的数据时，使用图数据库比较理想 图数据库的基本数据类型就是由边连接若干节点，但不同的图数据库依旧会有些区别，FlockDB只存储节点与边，Neo4J可以将Java对象作为属性，附加到节点与边上等等。以节点与边把图结构搭建好后，就能使用专门的图查询操作搜索图数据库的网络。关系型数据库虽然也能实现这种关系，但是效率很差，图数据库之所以迅速，因为图数据库会多花时间用于插入关系数据 若使用关系型数据库，首先必须定义模式：要有哪些表格，表中有哪些列等等，NoSQL数据库的共同点就是无模式。无模式数据库更加灵活与自由，而且无模式可以避免格式不一致的数据，即不会像关系型数据库中要把不同的字段写成NULL，无模式只要在每条记录上包含需要的数据即可 虽然无模式代表了黑客向往的自由，但是总归是逃脱不了模式的魔爪。在编写数据操作代码时，总会存在隐含模式，对数据结构做出一系列的假设；此外无模式数据库感知不到模式，就无法通过模式来提升存储效率，也无法验证数据 虽然NoSQL数据库没有视图，但是他可以预先计算查询操作的结果，并将其缓存起来，这就叫物化视图。和关系型数据库相比，NoSQL更需要这种视图，因为大多数应用程序都要处理某种与聚合结构不甚相关的查询操作 构造物化视图有两种方式，一种是一旦基础数据有变动，就立即更新物化视图；另一种是可以定期通过批处理操作物化视图 分布式模型面向聚合数据库非常适合横向扩展集群，而聚合此时成为了数据分布单元 分片把数据的各个部分存放在不同的服务器中。在理想情况下，不同服务器会服务不同的用户，每个用户只要与一台服务器通信。为了达到这个理想情况，就需要要访问的数据都在一个节点上 在节点的数据排布上，有几个性能相关的因素，一个就是地理位置，另一个是负载均衡 NoSQL都提供了自动分片，让数据库自己负责把数据分布到各分片上，并且将数据访问请求引导至适当的分片上，而不是由应用程序来负责分片处理 但是分片技术不能改善数据库的故障恢复能力，只要节点出错，该分片的数据就不能访问 主从复制在该模型下，把数据复制到多个节点，其中一个叫主节点，负责存放权威数据和处理数据更新操作。其余节点就是从节点。复制操作就是让从节点和主节点同步 主从复制最有助于提升数据访问性能。只要增加从节点，就能提高处理数据读取请求的能力。但是在写入操作时，由于受限于主节点处理更新能力，并不理想 第二个好处就是读取操作的故障恢复能力。主节点出错，从节点依旧可以处理读取操作，但是只有恢复主节点或者指派另一个主节点，才能处理写入操作。主节点既可以手工指派，也可以自动选择 当主节点处理所有读写操作的同时，从节点可以充当Hot backup（即时备份）。但是该机制依旧需要考虑数据不一致的情况 实现读取故障恢复，还要确保应用程序分别沿着不同的路径发出读取请求和写入请求，这就需要那种分别使用不同的数据库连接来处理读取与写入请求的机制 对等复制主从复制模型提供的故障恢复能力只有从节点出错时才能体现，实际上，主节点依旧是系统的瓶颈和弱点，对等复制模型就能解决这个问题。在该模型下，所有节点地位相同，都可以接受写入和读取请求。但是该模型的最大问题依旧是数据不一致 一致性更新一致性当两个人同时更新同一条数据时，服务器收到请求之后，会将其序列化，也就是决定这两个请求的处理顺序。这时候后一个处理的更新就会覆盖前一个更新，这就发生了更新丢失 在并发环境下维护数据一致性的方式有两种：悲观方式和乐观方式。悲观就是避免发生冲突，乐观则是让冲突发生，然后检测冲突并对发生冲突的操作排序。最常见的悲观方式就是写入锁。乐观方式则是采取条件更新，也就是任意客户在执行更新操作之前，都要先测试数据的当前值和上次读入的值是否相同 上面提到的方法都有个先决条件：更新操作的顺序必须一致。在多服务器中，两个节点就可能以不同的次序执行更新操作，这就会导致数据不一致。在谈到分布式系统的并发问题时，顺序一致性就是所有节点都要保证以相同的次序执行操作 还有一种处理写冲突的乐观方式，就是将两份更新数据都保存起来，并标注它们存在冲突。像Git等分布式版本控制系统就是采取这种方法。该方式和版本控制系统采取相同策略，以某种方式将两个相互冲突的更新合并。系统可以将冲突的值呈现给用户，让其自行处理 并发编程涉及一个根本问题，在安全性和相应能力之间的权衡。悲观方式通常会大幅降低系统相应能力，而且可能会出现死锁，这一情况既难以防范，也不易调试。而针对某份数据的写入操作都交由一个节点来完成，就更容易保持更新操作的一致性 读取一致性为了避免读写冲突造成的逻辑不一致。关系型数据库支持事务的概念。NoSQL虽然没有事务的概念，但由其他途径来实现相同的行为。像图数据库就支持ACID事务，其次，面向聚合的数据库支持原子操作，但是仅限于单一聚合内部 显然我们不能把所有数据放在一个聚合里面， 在执行影响多个聚合的更新中，就会留下时间空白，让客户能读到逻辑不一致的数据，存在不一致风险的时间长度就叫不一致窗口 一旦引入复制机制，又会遭遇全新的不一致问题，即更新操作在复制到全部节点之前，都有可能遭遇读取不一致的问题，这种叫做复制一致性。当然最终更新还是会传播到全部节点，这就叫最终一致性 放宽一致性架构师需要在一致性和其他特性之间做出权衡 单服务器关系数据库的事务也具备放松隔离级别的功能，以允许查询操作读取尚未提交的数据。在实际应用中，大多数应用程序都会从一致性最高的级别（可序列化）往下调，以便提升性能，最常见的隔离级别是只能读取已提交的数据 CAP定理在NoSQL领域，CAP定理是需要放宽一致性约束的原因。 CAP定理：给定“一致性”（Consistency）、“可用性”（Availability）、“分区耐受性”（Partition tolerance）这三个属性，我们只能同时满足其中两个属性 可用性：如果客户可以同集群中的节点通信，那该节点就必然能够处理读取和写入操作 分区耐受性：如果发生通信故障，导致整个集群被分割为成多个无法互相通信的分区时，集群仍然可用 单服务器显然是一种CA系统，也就是具备一致性和可用性 有时候我们要在一致性和可用性之间进行权衡，我们会略微舍弃一致性，以获取某种程度的可用性，这样产生的系统，既不具备完美的一致性，也不具备完美的可用性，但是两种不完美结合起来，却能满足特定需求 举个例子，两位顾客A、B预定一间客房，预定系统使用两个节点的系统 如果为了保持一致性，那么A预定时，访问节点1，就要先告知节点2，但是如果节点之间出现故障，那么就无法预定，系统失去了可用性 如果要维持可用性，可以指派其中一个节点为主节点，所有预定都要通过主节点，这样当两个节点之间出现故障，也能处理预定。但是顾客B访问非主机点时，由于故障，将出现更新不一致现象 当继续提高可用性时，可以让两个节点都接受预定，即使发生故障也如此。这样顾客A、B都可能预定最后一间客房。这样做可能会超额预定，但在现实中，就是这样做的。因为这样做的代价比系统无法接受预定要小的多 在配置数据库时，常常要考虑用户对陈旧数据的容忍程度，以及不一致窗口的时长 放宽持久性有些场合牺牲持久性来获取更好的性能，也是一种选择。如果每个数据库大部分时间都在内存中运行，更新操作也直接写入内存，定期将数据写入磁盘，那就可以大大提升相应速度，代价就是更新数据的可能丢失 仲裁一致性和持久性之间的取舍，不是非此即彼的议题。处理请求的所用的节点越多，避免不一致问题的能力就越强。那如果要保证强一致性，需要使用多少个节点才行？ 假设将某份数据复制到三个节点中，不需要所有节点都确认写入操作，只要超过半数的节点确认就可以。在这种情况下，如果发生两个相互冲突的写入操作，那么只有一个操作能为超过半数的节点认可，这就是写入仲裁 版本戳版本戳是一个字段，每当记录中的底层数据改变时，其值也随之改变 有多种构建版本戳的方法 计数器：每当资源更新，计数值+1，当需要一个主节点保证不同版本的计数器值不重复 GUID：Globally Unique Identifier，一个保证唯一的较大随机数，可以将日期、硬件信息以及一些随机出现的资源组合起来构建此值，缺点就是无法直接判断版本新旧 hash码：只要资源数据相同，生成的hash码就是一样的，只要hash码足够大，就是唯一的，GUID则是完全随机的 时间戳：不需要主节点控制，但多个节点必须时钟同步 在单服务器或主从复制模型中，使用基本的版本戳生成方案就好，但在对等分布模型中，版本戳的生成机制就需要改进 最常用的版本戳形式是vector stamp（数组式版本戳），其由一系列计数器组成，每个计数器代表一个节点，当节点执行内部更新时，将对用计数器+1。只要两个节点通信，就同步其数组式版本戳 MapReduce集群的出现不仅改变了数据存储的规则，而且改变了数据计算的规则 Map-reduce就是一种安排数据处理流程的手段，可以利用集群中的多态计算机，又能将某台计算机所需的数据和处理工作尽量放在本地执行 Map-reduce源自于函数式编程语言对集合的map和reduce（化简） 第一步就是map，他就是一个函数，输入是某个聚合，输出则是一大把键值对。每个应用程序的映射函数各自独立，以便安全执行并发运算。化简函数则接受多个映射函数的输出值作为输入，然后将其合并 许多map-reduce计算，即使将其分布到集群中的多台机器上执行，也比较耗时，而且计算过程中，新数据会不断涌入，为了保证输出的数据不过时，通常将map-reduce组成易于增量更新的形式 在这一形式中，映射阶段较容易处理，只要输入数据改变时，重新执行映射函数。但是化简步骤较麻烦，只要某个映射输出结果改变，就要再次化简。为了减少重新化简的计算量，可以将未改变的部分作为物化视图]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring-事务管理》]]></title>
    <url>%2F2019%2F01%2F25%2F%E3%80%8ASpring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E3%80%8B%2F</url>
    <content type="text"><![CDATA[事务就是以可控的方式对数据资源进行访问的一组操作 为了保证事务执行前后，数据资源处于正确的状态，需要满足四个属性ACID，Atomicity、Consistency、Isolation、Durability 原子性：事务包含的全部操作是一个不可分割的整体 一致性：分布式数据库，常处于不一致的状态 隔离性：主要规定了各个事务之间相互影响的程度，主要面对数据资源的并发访问 持久性：一旦整个事务操作成功提交，对数据所做的变更将被记载并不可逆转，也就是不能通过回滚恢复 隔离性根据不同隔离级别，各个事务对于数据资源访问会有不同的行为 Read Uncommitted：最低的隔离级别，一个事务可以读取另一个事务没有提交的更新结果，追求高性能，但会出现脏读（一个事务读取了另一个事务回滚前的数据，这份数据就是脏数据）、不可重复读取（同一个事务在整个事务过程中对同一笔数据的读取结果不同）、幻读（同一个查询在整个事务过程中多次执行后，查询所得的结果集不同，幻读针对的是多笔记录） Read Committed：大部分数据库采取的默认隔离级别，一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以访问到该结果，这种级别可以避免脏读，但是不能避免幻读和不可重复读 Repeatable Read：保证在整个事务的过程中，对同一笔数据的读写结果是相同的，无法避免幻读 Serializable：所有事务操作都必须依次顺序执行，可以避免所有问题，但是并发性下降，性能最差 大多数数据库都支持这四种隔离级别，Spring、JDBC等数据访问方式也允许为事务指定这四种隔离级别，但最终还是由底层的数据资源决定隔离级别 事务成员 Resource Manager：负责存储并管理系统数据资源的状态，比如数据库服务器 Transaction Processing Monitor：在分布式事务场景中协调多个RM的事务处理，如JTA（Java Transaction API） Transaction Manager：是TP Monitor的核心模块，负责多RM之间事务处理的协调工作，并提供事务界定、事务上下文传播等接口 Application：事务边界的出发点 根据涉及RM的多寡，可以将事务分为全局事务和局部事务 局部事务：只有一个RM参与，比如只对一个数据库更新，或者向一个消息队列发送消息，这时候不需要TP Monitor参与，可以直接使用RM的事务支持 全局事务：TP Monitor协调多个RM之间的事务管理，TP Monitor采取两阶段提交协议保证事务属性 Java平台的事务支持在Java局部事务场景中，通过当前使用的数据访问技术所提供的基于connection的API（如JDBC的Connection和Hibernate的Session）来管理事务 在Java分布式事务管理上，主要通过JTA（Java Transaction API）或者JCA（Java Connector Architecture）提供支持。使用JTA进行分布事务管理有直接使用JTA接口的编程事务管理以及基于应用服务器的声明性事务管理 Java平台提供的事务管理依旧存在许多平台，如局部事务管理绑定到了具体的数据访问方式，这会导致事务管理代码和业务逻辑代码混杂在一起，事务异常不统一，]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring-数据访问》]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%8ASpring-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E3%80%8B%2F</url>
    <content type="text"><![CDATA[Spring提供数据访问层 数据访问层分为以下几个部分 统一的数据访问异常层次体系：将特定的数据访问技术相关的异常封装成一套标准的异常层次体系 JDBC API的最佳实践：JDBC是一套数据访问标准，规范了各个数据库厂商的之间的数据访问接口，但依旧存在问题，Spring在其基础上提供了更好的实践 以统一的方式对各种ORM方案的集成：除了使用JDBC，还使用ORM（Object Relational Mapping，对象-关系映射） 总的来说，Spring的数据访问层就是以统一的数据访问异常层次体系为核心，以JDBC API和集成ORM方案为两翼 DAO（Data Access Object 数据访问对象）设计模式封装对于数据源的操作，数据源可能是文件、数据库等任意存储方式（可以与数据库或者文件进行交互，业务层在去操作数据层时，不需要知道数据层底层的存储实现）。DAO模式对于屏蔽不同数据访问机制的差异性起到举足轻重的作用 统一异常处理不同的数据访问机制会抛出不同形式的异常，如果把这些异常交给客户处理，那定义统一的数据访问接口就会显得没有用，而且如果存着数据访问机制的添加，访问接口要不断修改，这就破坏了使用DAO设计模式的初衷 为解决上述问题，只要在DAO实现类内部，将不同的异常以统一的格式封装即可。不过依旧存在一个问题，不同数据库厂商表达具体的错误信息时，采用不同的方式，这意味着客户要根据不同的数据库厂商采取不同的信息提取方式来获取具体的错误信息，这是很糟糕的，为此我们通过异常的分类转译来屏蔽这种差异。因此我们需要完成两个任务，一是完成对错误信息的提取工作，二是对错误信息进行分类，抛出统一的异常（如获取资源失败、数据一致性冲突）等，可以通过定义RuntimeException的子类来实现 通过上面的机制，不管数据访问方式如何变化，只要将相应的数据访问方式的异常转译到这套自定义的完整异常体系中，对于客户端来说，异常处理逻辑就巍然不动了 Spring就根据上述思路实现了数据访问异常层次体系，这个异常体系以DataAccessException为统领，并根据职能划分为不同的异常子类型，具体信息可以查看Spring的Javadoc 上面介绍了统一的数据访问异常层次体系出现的背景和演化过程 ORM集成Spring对流行的ORM集成体现在 统一的资源管理方式：Spring以统一的方式封装ORM，使得对JDBC和ORM都使用统一的方式 特定于ORM的数据访问异常到Spring统一异常体系的转译 统一的数据访问事物管理及控制方式 Spring对Hibernate和IBatis等ORM等方案都有集成包，虽然集成方案千篇一律，但我们应该根据具体场景选择具体的ORM方案 Hibernate比作自动步枪，JDBC是手动步枪，iBATIS就是半自动步枪，学习成本低]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章 线程]]></title>
    <url>%2F2019%2F01%2F23%2F%E3%80%8AAPUE-%E7%BA%BF%E7%A8%8B%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《Spring-IoC》]]></title>
    <url>%2F2019%2F01%2F21%2F%E3%80%8ASpring-IoC%E3%80%8B%2F</url>
    <content type="text"><![CDATA[让别人为你服务 Inversion of Control（控制反转），别名Dependency Injection（依赖注入） 在IoC场景中，被注入对象和被依赖对象之间通过IoC Service Provider沟通，两者由IoC Service Provider统一管理 被注入对象有三种方式告诉IoC Service Provider需要哪些被依赖对象，即依赖注入的方式 构造方法注入：通过在构造方法中申明被依赖对象的参数列表，IoC Service Provider会检查被注入对象的构造方法，取得依赖对象列表，对象构造完成后，即进入就绪状态，缺点在于依赖对象多的时候，构造列表很长；构造方法无法被继承，且不能设置默认值；依赖对象不同需要不同的构造方法 setter方法注入：对于Javabean对象来说，通常用setXXX()设置属性，当前对象只要为依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中，相比于构造注入，这种方法可以在构造完成后再注入 接口注入：不提倡，因为要强制被注入对象实现不必要的接口，处于退役边缘 IoC的附加值：不会对业务对象产生很强的侵入性，对象具有更好的测试性、可重用性、可扩展性，解耦各种业务对象依赖关系额度对象绑定方式 IoC Service Provider是一个抽象的概念，指代任何将IoC场景中的业务对象绑定到一起的实现，主要有两个职责：业务对象的构建管理、依赖绑定 IoC Service Provider有多种方式记录对象之间的对应关系 直接编码：通过程序编码将被注入对象和依赖对象注册到容器中，并确定相互之间的依赖注入关系 配置文件： BeanFactoryApplicationContext注解]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring-AOP》]]></title>
    <url>%2F2019%2F01%2F21%2F%E3%80%8ASpring-AOP%E3%80%8B%2F</url>
    <content type="text"><![CDATA[OOP无法解决类似于日记、安全检查等系统功能散落在系统中的问题，AOP则可以对这些需求进行模块化的组织，AOP引入Aspect以模块化的形式对系统中的横切关注点进行封装，Aspect对于AOP，就像Class对于OOP，AOP只是对于OOP的一种补足 AOP只是一种概念，可以使用不同的语言来实现这个概念，并且可以和系统语言不同，实现AOP的语言称为AOL，例如如果业务需求系统实现使用的是Java，系统需求实现使用的则可以是C实现的AOP，最后通过Weave过程将两个组件集成到一个系统 AOP经过了两个阶段 静态AOP时代：相应的横切关注点以Aspect实现之后，通过特定的编译器，将实现后的Aspect编译到系统的静态类中，达到融合Aspec和Class的目的。这种方式的优点就是Aspect直接以Java字节码的形式编译到Java类中吗，JVM像普通类一样加载类运行。缺点是横切关注点需要改变织入的位置时，就需要重新编写、编译 动态AOP时代：由于Java提供的动态特性，大多数AOP都是由Java实现，各种概念实体就是普通的Java类。和静态AOP不同的是AOP的织入过程在系统运行开始之后，并且织入信息大都是采用外部XML文件格式存储，可以在不改变其他模块的同时，实现调整织入点一级织入逻辑单元。缺点就是对AOP类加载都在系统运行期间，会有部分性能损失 Java上AOP实现机制 动态代理：将横切关注点逻辑封装到动态代理的InvocationHandler中，然后再系统运行期间，根据横切关注点需要织入的模块位置，将横切逻辑织入到相应的代理类中 动态字节码增强：可以为需要织入横切逻辑的模块类在运行期间，通过动态字节码增强技术，为这些系统模块类生成相应的子类，并将横切逻辑加到这些子类中，让应用程序在执行期间使用的是这些动态生成的子类，从而达到将横切逻辑织入系统的目的 自定义类加载器：通过读取外部文件规定的织入规则和必要信息，在加载Class文件期间就可以将横切逻辑添加到系统模块类的现有逻辑中，再将改动后的Class交给JVM执行。这种方法最大的问题是某些应用服务器会控制整个类加载体系 AOL扩展：AOP各种概念在AOL中都有意义对应的实体，可以使用扩展过的AOL，实现任何AOP甚至OOP概念实体 AOP成员 Joinpoint：要在其之上进行织入操作的系统执行点，基本上只要允许，程序执行过程中的任何时点都可以作为横切逻辑的织入点。如方法调用、方法调用执行、构造方法调用、字段设置、字段获取、异常处理执行和类初始化等 Pointcut：需要参照Pointcut规定的信息，草才最终知道应该往系统的哪些Joinpoint上织入横切逻辑，Pointcut有几种表达形式，如正则表达式、使用特定的Pointcut表述语言，这些表达式之间也可以做运算 Advice：是单一横切关注点逻辑的载体，代表将会织入Joinpoint的横切逻辑，Aspect如果是OOP中的Class，Advice就是Class中的Method Aspect：是对系统中的横切关注点逻辑进行模块化封装的AOP概念实体 织入和织入器：织入是OOP和AOP之间的桥梁，AspectJ有专门的编译器完成织入操作，Spring APO使用ProxyFactory这组类完成织入，不管形式如何，相同的职责都是完成横切关注点逻辑到系统的最终织入 目标对象：被织入横切逻辑的对象 其中Advice成员根据在Joinpoint位置执行时机的差异或者完成功能的不同，可分成不同的形式 Before Advice：在Joinpoint位置之前执行，可以使用该方法做一些系统初始化的工作，如设置系统初始值 After Advice：又可以细分为After returning Advice在Joinpoint正常完成执行流程之后才会执行，After throwing Advice在Joinpoint抛出异常才会执行，After Advice和finally块一样，不管正常执行还是抛出异常都会执行 Around Advice：可以在Joinpoint之前和之后都能执行相应的逻辑]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2019%2F01%2F20%2FHF-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。 我们有多种不同的方式来实现代理。如果按照代理是创建的时期来进行分类的话， 可以分为两种 静态代理：由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了 动态代理：可以动态创建代理并且处理对所代理方法的调用，在动态代理上所做的调用都会被重定向到单一的调用处理器上，它的工作是揭示调用类型并确定相应的对策，Spring AOP默认使用动态代理 只要想将额外的操作从实际对象中分离到不同的地方，特别是当想要很容易做出修改，从没有使用额外操作转为使用这些操作，代理就显得很有用 静态代理有一个最大的缺陷：接口与代理类是1对1的，有多个接口需要代理，就需要新建多个代理类，繁琐，类爆炸 同时代理多个类，依然会导致类无限制扩展 如果类中有多个方法，同样的逻辑需要反复实现]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2019%2F01%2F20%2FHF-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[将对象的创建工作交给类自己去完成 工厂模式分为简单工厂、工厂方法和抽象工厂三种 简单工厂模式中，User的代码不会因为产品的添加而改变，所有类的创建都交给工厂处理 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《未来世界的幸存者》]]></title>
    <url>%2F2019%2F01%2F19%2F%E3%80%8A%E6%9C%AA%E6%9D%A5%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85%E3%80%8B%2F</url>
    <content type="text"><![CDATA[技术变革导致人类社会的变革,人们要翻身只会越来越难,要为此早早准备出路 一下午就翻完了这本书,整本书都体现了阮一峰的危机感、对技术利弊的不确定性和些许悲观，说的很浅显易懂，多半是自己认知范围的东西，就算是一个总结吧 人工智能的出现，会消灭一大部分的岗位，但人们总安慰自己技术也会产生很多的其他岗位，但是当技术取代岗位的速度大于产生新岗位的速度时，就会大大的改变社会结构，穷人翻身的机会越来越小，因为现在要翻身需要的不仅仅是努力，穷人努力工作面对的不是人类，而是永远不知道疲惫的机器人，穷人看不到翻身的希望，在政治上就意味着政治自杀，阶级流动越来越僵化，收入差距越来越大，社会秩序就会因此瓦解 要想工作不被机器人取代，可以着重锻炼以下能力 人性化和人格魅力 创意 决策和领导力 总拿“终身学习”来要求自己，通过终身学习这个途径来保持就业竞争力对大部分人来说是很困难的，而且程序员这个行业本身属性决定了他就是一个吃青春饭的行业。技术更迭太快，积累了几年的技术，瞬间就会变得没有用。而一个人又经得起几次从头开始学习的挑战呢？不要指望现在学习的技术能让自己一辈子无忧，要时刻充满危机感，准备好不同的出路 未来青年的机会不会像以前一样多，竞争会越来越激烈，越来越多的人会发现通过努力学习，考上很好的学校，然后努力工作，最后只会过上穷忙的人生，即使再努力，也只能在现有阶级挣扎 未来文凭的价值将会越来越低，大学的教育来源于欧洲修道院模式，要求学生不断修行苦熬才能毕业，演变到现在就是传授老化的知识，浪费学生的时间。大学的培养计划都是脱离实际工作环境几十年，思维模式已经过时的人制作的，对于现在的大学生已经没有用处，而且大学教授的知识主要面对学术研究领域的学生，对于大部分选择工作的学生来说，并没有什么用处。大学使我们把自己最宝贵的青春关在了教室和图书馆，把考试和绩点伪装成我们奋斗的目标，隔离了真实世界但当真正踏上社会的时候，却发现自己的能力反而变弱了，对于上述看法自己深表同感。知识和技术依旧很重要，但是现在获得这两项的途径已经不只是大学这唯一的出路，大学那灌输的教育方式和制度时刻体现他丑陋过时的一面，也阻碍我们真正的成长。我们要主动接触和学习自己感兴趣的方面，做到自主、跨界、终身学习 现在的人们对未来的打算就是找份好工作，干到退休，或者中途换家公司干到退休，但人们都没有意识到这种雇佣关系在人类历史中才存在两三百年时间，反而觉得这种模式是理所当然的。而这种模式只对资本家有利，对被雇佣方不利，是永远被压榨的一方。公司把工作分配的越来越细化，这样没有人是不可以替代的，公司依赖人才的成本也就越低。因此对自己的职业发展一定要有明确的方向，在大公司里面干活，要想技术上有造诣，真正的突破是业余深造，让自己的路越走越宽 我们不能是他人的工具，成为他人眼中的骡子或者码农，要有自己的价值有过一种有乐趣、有追求、自己做主的生活，而不是像骡子一样被他人使用。要制定自己的B计划，这个计划也许不会带来经济上的成功，但可以从中获得自由、自我认同和成就感 这本书中又一次提到了熵的概念，熵是能量，也是系统的混乱度所有封闭系统都会想混乱度最大的状态移动，除非从外注入能量。这意外着维持美好的事物需要能量注入，人类文明的进步，是混乱度降低的过程，这意味着要越来越多的能量注入（牲畜、火、水电、核电），才能支持人类继续想文明有序的方向发展。但是物理学告诉我们，没有办法消除熵和混乱，人类做的只是把混乱转移到了其他领域，当局域有序起来。未来如果人们找不到足够的能量注入，秩序就会开始崩塌，陷入混乱 未来在一步步变好，却在一步步变坏]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第21章 并发]]></title>
    <url>%2F2019%2F01%2F18%2F%E3%80%8ATIJ-%E5%B9%B6%E5%8F%91%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本章所讲的并发是通向高级主题的中介，但即使融汇贯通本章内容，也不能说自己是一个优秀的并发程序员。学习并发编程就像进入一个全新的领域 源码分析参见：java.lang相关文章：第十二章：并发编程详细并发教程参见：《Java并发编程实战》 并发通常是为了提高运行在单处理器上的程序性能，而不是直观上的多处理器上。乍看可响应起来有悖常理，多个程序一起运行，不停地切换上下文，看起来可能比程序顺序执行要慢？造成这个错觉的原因就是因为阻塞，程序在执行过程中并不是百分之百使用CPU，因此空闲的那段时间（也就是阻塞）时浪费的，因此使用并发来编写程序时，就可以切换到其他程序继续执行 使用并发可以实现具有可响应的用户界面。某些编程语言被设计为可以将并发任务彼此隔离，这些语言称为函数型语言，其中每个函数调用都不会产生任何副作用，并且可以当做独立的任务来驱动。在面对游戏仿真、分布式系统时，并发机制都能提供更好的编码设计 基本线程机制线程可以驱动任务，通过实现Runnable接口并编写run()方法来定义任务。要实现线程行为，就要显式的把任务附着到线程上去。通过向Thread类构造器传入一个Runnable对象，并调用start()方法为该线程执行必要的初始化操作，然后自动调用run()方法，以便在这个新线程中启动该任务。调用start()后悔迅速返回，但由于Thread对象都注册了自己，所以会继续存在，并独立运行，直到任务退出，垃圾回收器才会清除它 java.util.concurrent包中的执行器可以替我们管理Thread对象，从而简化并发编程，Executor在客户端和任务执行之间提供了一个间接层，由这层来执行任务。ExecutorService（具有服务生命周期的Executor，即线程池，实现该接口的类有ThreadPoolExecutor和ScheduledThreadPoolExecutor）知道如何构建恰当的上下文来执行Runnable对象。Java还提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，以下方法都是静态创建对象 newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程 newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，并一次性预先执行代价高昂的线程分配，需要线程的事件直接从池中获取，超出的线程会在队列中等待， newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行 newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行 上面提到具有服务生命周期的ExecutorService指的是其具有shutdown()方法，可以防止新任务被提交到这个Executor。在所有类型的线程池中，现有线程都可能会被自动复用 Java 1.5中引入的Callable接口是具有类型参数的泛型，它和Runnable接口的区别就在于完成任务时有返回值，而且必须使用ExecutorService.submit()方法来调用实现好的call()，submit()会返回一个Future对象，其代表了异步计算结果，并具有方法来获取get()、检查isDone()结果 sleep()可以使任务暂停指定时间单元 getPriority() &amp; setPriority()可以读取和修改现有线程的优先级，通常来说修改优先级都是种错误 yield()让步，当工作做得差不多时，可以通过该方法暗示让别的线程使用CPU 后台线程daemon指在程序运行的时候在后台提供一种通用服务的线程，这种线程不是程序不可或缺的部分，这意味着当所有非后台线程结束时，程序就终止，并杀死所有后台进程。通过setDaemon() &amp; isDaemon()可以设置或判断后台线程 后台线程中run()中的finally块语句不会得到执行，这意味着后台线程的finally语句得不到保证，因此一旦线程都退出，JVM就会立即关闭所有后台进程 加入线程在Java中，Thread类本身并不执行任何操作，它只是驱动赋予它的任务。从物理层面看，把任务从线程中分离出来就变得有意义，因为创建线程的代价很高昂。Java的线程机制是基于C的pthread机制，这种低级特性部分渗透到了Java的实现中，下面就是一个例子 一个线程可以在其他线程上调用join()，其效果是等待一段时间直到第二个线程结束才继续执行，源码给出的注释是Waits for this thread to die,命名来源于posix标准，子线程join到主线程（启动程序的线程，比如c语言执行main函数的线程），阻塞线程仅仅是一个表现，而非目的。其目的是等待当前线程执行完毕后，”计算单元”与主线程汇合，即主线程与子线程汇合之意。对join()方法的调用可以被中断，做法是在调用线程上调用interrupt() 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往先于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再执行并结束自己，这个时候就要用到join()方法 异常由于线程本质特性，不能捕获从线程中逃逸的异常，一旦逃出任务的run()方法，就会向外传播到控制台，Java 1.5之后就可以用Executor解决这个问题。Thread.UncaughtExceptionHandler接口允许在Thread对象上都附着一个异常处理器，Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用 同步一般解决并发模式中共享资源竞争问题，都是采取序列化访问共享资源的方案，这意味着在给定时刻只允许一个任务访问共享资源。Java提供synchronized，为防止资源冲突提供了内置支持，当任务执行被synchronized关键字保护的代码片段时，它将检查锁是否可用，然后获取锁，执行代码，释放锁。共享资源都会被包装到一个对象中，然后把所有要访问这个资源的方法都标记为synchronized，所有对象都会含有单一的锁（监视器），当在对象上调用任意标有synchronized的方法时，该对象就会上锁，其他调用该对象的方法都阻塞直到上一个方法释放锁 一个任务可以多次获得对象的锁，即如果一个方法在同一个对象上调用了第二个方法，后者又调用同一个对象的另一个方法。JVM会负责追逐对象被加锁的次数 java.util.concurrent.locks提供了显式的互斥机制，Lock对象必须被显式的创建、锁定和释放。在使用这种方法时，要用到try-finally语句，这意味着有机会做任何清理工作，以维护系统使其处于良好状态 Brain同步规则：如果正在写一个常量，他可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，就要使用同步，并且要使用相同的锁 原子性与易变性原子操作是不能被线程调度机制中断的操作，一旦操作开始，它一定可以在可能发生的上下文切换之前执行完毕。不要为了避免同步而使用原子性 JVM对于long double变量的读写和写入当做两个分离的32位操作来执行，这产生了在读取和写入操作中间发生上下文切换时，会导致不同的任务可以看到不正确结果，如果使用volatile关键字，就能获得原子性 对于多核处理器系统来说，任务做出的修改对其他任务可能是不可视的（例如修改只是暂时保存在本地处理器的缓存中），volatile保证了修改的应用可视性，对volatile域的修改，其他读操作都能看到，volatile域会立即被写入主存中。一个会被多个任务访问的域，就应该是volatile，或者由同步来访问，因为同步也会导致向内存中刷新 原子性和易变性是不同的概念，在Java中自增和自加都不是原子性的？？ 临界区（同步控制块）：防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法，这种方法可以使多个任务访问对象的时候性能得到显著提高 防止共享资源冲突的第二种方法是根除对变量的共享，线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，这使得状态和线程关联起来 终结任务线程协作死锁]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第20章 注解]]></title>
    <url>%2F2019%2F01%2F18%2F%E3%80%8ATIJ-%E6%B3%A8%E8%A7%A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[注解(元数据)为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻方便使用这些数据 从JDK 1.6开始提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，有了这些API之后，我们的代码就可能干涉编译器的行为，对于语法树中的任意元素，甚至包括代码注释都可以在插件中访问到 注解使得我们能 以将由编译器来测试和验证的格式，存储有关程序的额外信息 可以生成描述符文件，甚至或是新的类定义，有助于减轻编写样板的负担 将元数据保存在Java源代码中，并构造处理工具 简单易读 Java内置了三种注解 @Override：定义覆盖超类的方法，如果签名对不上，就会出错 @Deprecated：如果使用了注解为它的元素，就会发出警告 @SuppressWarnings：关闭不当的编译器警告信息 基本语法与其他任何Java接口一样，注解也会编译成class文件123@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123;&#125; 上面就是最简单的标记注解（没有元素），@Target @Retention是两个元注解，第一个定义了注解应用在什么地方（构造器、域、局部变量、方法、包、参数、类、接口等），第二个定义注解在哪个级别可用（SOURCE、CLASS、RUNTIME） 123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UseCase &#123; public int id(); public String desciption() default "no description";&#125; 上面的注解可以用来跟踪一个项目的用例，如果一个方法实现了某个需求，程序员就可以为该方法加上注解，如下所示1234567public class PasswordUtils &#123; @UseCase(id = 47,description = "Password must contain at least one numeric") public boolean validatePassword(String password) &#123; return password.matches("\\w*\\d\\w*"); &#125; &#125; 编写注解处理器如果没有读取注解的工具，那注解和注释并没与两样，因此使用注解的很大一部分工作就是创建和使用注解处理器，底层实现是反射机制的API，同时还提供apt帮助解析带有注解的源代码 123456789101112131415161718192021222324252627public class UseCaseTracker &#123; public static void trackUseCases(List&lt;Integer&gt; useCases,Class&lt;?&gt; cl) &#123; for(Method m : cl.getDeclaredMethods()) &#123; UseCase uc = m.getAnnotation(UseCase.class); if(uc != null) &#123; System.out.println("Found Use Case:" + uc.id() + " " + uc.description()); useCases.remove(new Integer(uc.id())); &#125; &#125; for(int i : useCases) &#123; System.out.println("Warning:Missing use case-" + i); &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; useCases = new ArrayList&lt;Integer&gt;(); Collections.addAll(useCases, 47,48,49,50); trackUseCases(useCases,PasswordUtils.class); &#125;&#125;//运行结果Found Use Case:47 Password must contain at least one numericWarning:Missing use case-48Warning:Missing use case-49Warning:Missing use case-50 上面就是简单的注解处理器，将用它来读取PasswordUtils类，先提供一组id，它会列出类中找到的用例和缺失的用例 这个程序用到了两个反射方法：getDeclaredMethods()和getAnnotation()，它们都属于AnnotatedElement接口（Class、Method和Field等类都实现了该接口？？），getAnnotation()就是返回指定类型的注解对象，然后通过调用注解对象的方法来提取元素的值 注解元素可用类型有所有基本类型、String、Class、enum、Annotation、以上类型数组。由此可见注解可以嵌套，这将非常有用 编译器对于注解元素的默认值有很大的限制，要么元素具有默认值，要么在使用注解时提供值，不能用null作为值，这使得处理器很难表现一个元素的存在或缺失的状态，为了绕开这个限制，只能使用空字符串或负数来表示元素不存在 生成外部文件（ORM）有些framework需要一些额外的信息来能和源代码协同工作，如String中的ORM（Mybatis、Hibernate），这就是注解的价值所在！ 假如希望提供一些基本的对象/关系映射功能，能够自动生成数据库表，用以存储Javabean对象，可以选择XML描述文件，指明类的名字，每个成员以及数据库映射的相关信息，但是如果使用注解，所有信息都保存在Javabean源文件中，为此只要一些新的注解，用来定义与Javabean关联的数据库表的名字，以及与Javabean属性关联的列的名字和SQL类型 12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface DBTable &#123; public String name() default "";&#125; 该注解通过该元素为处理器创建数据库表提供表的名字1234567@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Constraints &#123; boolean primaryKey() default false; boolean allowNULL() default true; boolean unique() default false;&#125; 注解处理器通过Constraints提取出数据库表的元数据，虽然相对于数据库能提供的属性来说，只是一部分 123456@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLInteger &#123; String name() default ""; Constraints constraints() default @Constraints;&#125; 1234567@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLString &#123; int value() default 0; String name() default ""; Constraints constraints() default @Constraints;&#125; 上面两个注解定义的是SQL类型，Constraints constraints() default @Constraints;这里即采取了嵌套注解，默认值是@Constraints，当然也可以这样定义Constraints constraints() default @Constraints(unique=true); 123456789101112131415161718192021@DBTable(name = "MEMBER")public class Member &#123; @SQLString(30) String firstName; @SQLString(50) String lastName; @SQLInteger Integer age; @SQLString(value = 30,constraints = @Constraints(primaryKey = true)) String handle; static int memberCount; public String getHandle() &#123; return handle; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public String toString() &#123; return handle; &#125; public Integer getAge() &#123; return age; &#125;&#125; 上述代码则应用了之前定义的注解，当然也有不同的方式来实现上面的功能，那种灵活且简洁就选那种 注解目前不支持继承 下面的代码实现了上面的定义的注解的处理器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.util.List;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.util.ArrayList;public class TableCreator &#123; public static void main(String[] args) throws Exception &#123; if(args.length &lt; 1) &#123; System.out.println("arguments:annotated classes"); System.exit(0); &#125; for(String className : args) &#123; Class&lt;?&gt; class1 = Class.forName(className); DBTable dbTable = class1.getAnnotation(DBTable.class); if(dbTable == null) &#123; System.out.println( "No Dbtable annotations in class " + className); continue; &#125; String tableName = dbTable.name(); if(tableName.length() &lt; 1) &#123; tableName = class1.getName().toUpperCase(); &#125; List&lt;String&gt; columnDefs = new ArrayList&lt;String&gt;(); for(Field field : class1.getDeclaredFields()) &#123; String columnName = null; Annotation[] annotations = field.getDeclaredAnnotations(); if(annotations.length &lt; 1) continue; if(annotations[0] instanceof SQLInteger) &#123; SQLInteger sqlInteger = (SQLInteger)annotations[0]; if(sqlInteger.name().length() &lt; 1) columnName = field.getName().toUpperCase(); else columnName = sqlInteger.name(); columnDefs.add(columnName + "INT" + getConstraints(sqlInteger.constraints())); &#125; if(annotations[0] instanceof SQLString) &#123; SQLString sqlString = (SQLString)annotations[0]; if(sqlString.name().length() &lt; 1) columnName = field.getName().toUpperCase(); else columnName = sqlString.name(); columnDefs.add(columnName + " VARCHAR(" + sqlString.value() + ")" + getConstraints(sqlString.constraints())); &#125; StringBuilder createCommand = new StringBuilder( "CREATE TABLE " + tableName + "("); for(String columnDef : columnDefs) createCommand.append("\n " + columnDef + ","); String tableCreate = createCommand.substring( 0,createCommand.length() - 1) + ");"; System.out.println("Table Creation SQL for " + className + " is:\n" + tableCreate); &#125; &#125; &#125; private static String getConstraints(Constraints con) &#123; String constraints = ""; if(!con.allowNULL()) constraints += " NOT NULL"; if(con.primaryKey()) constraints += " PRIMARY KEY"; if(con.unique()) constraints += " UNIQUE"; return constraints; &#125;&#125;//运行结果Table Creation SQL for annotations.Member is:CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30));Table Creation SQL for annotations.Member is:CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30), LASTNAME VARCHAR(50));Table Creation SQL for annotations.Member is:CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30), LASTNAME VARCHAR(50), AGE INT);Table Creation SQL for annotations.Member is:CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30), LASTNAME VARCHAR(50), AGE INT, HANDLE VARCHAR(30) PRIMARY KEY); 虽然上面的代码对现在的自己来说大开眼界！但是对于真正的对象/关系映射框架来说，还是太幼稚！例如使用@DBTable注解给出表的名字，如果要修改表的名字，就要重新编译Java代码，这显然不是希望看到的！ 详细的对象/关系映射框架参见《Spring-数据访问》]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java并发编程实战》]]></title>
    <url>%2F2019%2F01%2F18%2F%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%2F</url>
    <content type="text"><![CDATA[介绍了一些并发编程的设计规则和思维模式 初识并发编程可以参见 多线程的优势 发挥多处理器的能力 建模简单：当手头只有一项工作时，只需要埋头苦干，可当有多项任务时，就需要花精力去考虑任务的安排，对于软件也是，如果为每种类型的任务都分配一个专门的线程，就可以形成串行执行的假象，就好像所有人都在专注于自己手头的事情，并只在特定的同步位置进行交互，上述目的可以通过Servlet和RMT等框架实现，框架会处理请求管理、线程创建、负载平衡等细节问题，而对于开发人员都不需要了解这些，看起来就像一个单线程程序 异步时间的简化处理：单线程应用在遇到读写阻塞的时候，对于其他处理也将停顿，为了处理这个问题，单线程应用使用非阻塞I/O，这种I/O的复杂性远高于同步I/O。但是如果每个请求都对于一个处理线程，也能解决上述问题。早期的操作系统只能创建少量的线程，大约在几百个，因此像Unix就提供一些方法来实现多路I/O，例如select和poll系统调用，为了调用这些方法，Java类库提供了一组实现非阻塞I/O的包（NIO）。如今线程数量大幅提升（可达数十万个），有能力给每个客户端提供一个线程 线程无处不在 当JVM启动时，会为JVM的内部任务（垃圾回收、终结操作）创建后台进程，并创建一个主线程来运行main方法。 框架通过在框架线程中调用应用程序代码将并发性引入程序中，在代码中将不可避免地访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的，因此对于线程安全性的需求在程序中蔓延开来 下面的模块都将在应用程序之外的线程中调用应用程序的代码 Servlet和JavaServer Page（JSP）：Servlet框架用于部署网页应用程序以及分发来自HTTP客户端的请求，到达服务器的请求可能会通过一个过滤器链被分发到正确的servlet或JSP，每个servlet都是一个程序逻辑组件，多个客户端可能同时请求同一个servlet服务，因此在servlet框架中需要满足servlet被多个线程同时调用，即servlet需要是线程安全的 RMI：使代码能够调用在其他JVM中运行的对象。当RMI调用某个远程方法时，传递给方法的参数必须打包到一个字节流，通过网络传输给远程JVM，再由其拆包并传递给远程方法 目录 线程安全性]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载机制]]></title>
    <url>%2F2019%2F01%2F18%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Spring MVC》]]></title>
    <url>%2F2019%2F01%2F17%2F%E3%80%8ASpring-MVC%E3%80%8B%2F</url>
    <content type="text"><![CDATA[开始之前要对Servlet和JSP有所了解 ServletServlet学习笔记，不管之后web应用的开发怎么演化，都将是以Servlet为基础进行 JSPJSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。 JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。 JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。 JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息 以下步骤表明了 Web 服务器是如何使用JSP来创建网页的： 就像其他普通的网页一样，您的浏览器发送一个HTTP请求给服务器。 Web服务器识别出这是一个对JSP网页的请求，并且将该请求传递给JSP引擎。通过使用URL或者.jsp文件来完成。 JSP引擎从磁盘中载入JSP文件，然后将它们转化为Servlet。这种转化只是简单地将所有模板文本改用println() 语句，并且将所有的JSP元素转化成Java代码。 JSP引擎将Servlet编译成可执行类，并且将原始请求传递给Servlet引擎。 Web服务器的某组件将会调用Servlet引擎，然后载入并执行Servlet类。在执行过程中，Servlet产生HTML格式的输出并将其内嵌于HTTPresponse中上交给Web服务器。 Web服务器以静态HTML网页的形式将HTTP response返回到您的浏览器中。 最终，Web浏览器处理HTTP response中动态产生的HTML网页，就好像在处理静态网页一样。 回顾历史使用单一的Servlet开发，出现的最常见弊端就是Magic Servlet，将控制逻辑、视图显示逻辑、业务逻辑、数据访问路逻辑结合在一起，为后期维护造成麻烦，简单说就是在一个Servlet实例中，一块是输出HTML视图语句，一块是查询数据库语句，杂合在一起 即使将数据访问逻辑封装起来，也还是避免不了视图逻辑的混乱，这时候就出现了JSP，来将Servlet视图渲染逻辑独立抽象出来并使用模板化的方法。JSP的提出，成为了Java平台上开发web应用程序的模板化视图标准 现在JSP专职负责视图的渲染工作，Servlet得以进一步解脱，只需通过requestDispatcher.forward(request,response)将当前request传递到jsp，或者把新的资源包括到当前响应中 JSP与其他模板技术一个主要区别就是它最终都是编译为Servlet来运行的，这使得JSP拥有更大的能量，可以将所有逻辑都编写到JSP中，甚至是数据库连接代码（当然这样做是不对的）。其次，一般的Servlet处理请求，在web.xml中都要注册URL和相应Servlet的一一映射关系，因此会充斥很多的配置文件，而使用JSP则可以省去麻烦，直接通过链接就能访问 JSP的出现是为了解决Magic Servlet，现在所有功能都放到了JSP中，又变成了Magic JSP。为此，Sun又引入了JavaBean，对相关业务逻辑进行封装 至此，我们已经引出了SpringMVC的三个角色，由Java开发人员来开发Servlet，负责处理控制流程，前端人员开发JSP，负责视图的渲染，JavaBean则封装业务逻辑并负责与数据层进行交互。这一模型成为JSP Model2，该模型是web开发的一个里程碑 该模型已经具备了MVC的雏形，还是有些许差别 最初意义上的MVC模式中 控制器负责接收视图发送的请求并进行处理，它会根据请求条件通知模型进行应用程序状态更新，之后选择合适的视图显示给用户 模型封装应用的逻辑以及数据状态，当控制器通知模型进行更新时，模型封装的相应逻辑将被调用。执行完后，模型通过事件机制通知视图 视图是面向用户的接口，当用户同视图发出请求时，视图将这些请求转发给控制器进行处理 上述模型中，有个问题就是模型无法实现Push数据到视图这样的功能，只能做出调整，使得控制器在原来通知模型更新状态的基础上，还要获取模型更新的数据，然后将数据模型一并转发给视图，这就变成了控制器从模型中Pull数据给视图 曾经Web应用中都是使用多个Servlet作为控制器，这就要求为每个请求处理流程定义一个Servlet，并利用Web容器（即Web服务器）的URL映射匹配能力来解决Web请求到Servlet的映射。但是随着规模不断变大，配置文件web.xml的体积越来越大，不利于维护，因此舍弃这种方式 所有Web请求都经由单一的Servlet控制器来进行，虽然这样做不多是把web.xml的膨胀转移到了Servlet控制器，而且所有判断流程都成了硬编码，灵活性和可扩展性下降，但我们可以通过引入合适的设计模式，避免上述问题 制约JSP Model2模型发展的就是将流程控制等通用相关逻辑进行硬编码的实践方式，这直接导致了架构的不可重用性，因此每次开展新的web应用，就要从头编写Servlet控制器的URL分析和流程控制等逻辑。这促使我们去寻找解决方法 Web框架就是顺应这个需求诞生。当前Web开发框架有两种类型 请求驱动Web框架：这种框架基于Servlet的请求和相应处理模型构建的，例如Struts、Spring MVC 事件驱动Web框架：采用与Swing等GUI开发框架类似的思想，将视图组件化，以淘汰 请求驱动的Web框架多是基于JSP Model2的基础发展而来，如今的框架依旧使用单一的Servlet作控制器，但是结合了Front Controller和Page Controller设计模式对单一Servlet的问题进行改进 接下来就开始Spring MVC之旅吧！！！]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第17章 容器深入]]></title>
    <url>%2F2019%2F01%2F17%2F%E3%80%8ATIJ-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E3%80%8B%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第14章 类型信息]]></title>
    <url>%2F2019%2F01%2F17%2F%E3%80%8ATIJ-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本章讨论Java如何让我们在运行时识别对象和类的信息，一种是传统的RTTI（Run-Time Type Information），它假定我们在编译时已经知道了所有的类型；另一种是反射机制，它允许我们在运行时发现和使用类的信息 面对对象编程中基本的目的就是：让代码只操纵对基类的引用，减少了解对象的具体类型，只和通用表示（基类）打交道，这样代码更容易维护、改变，实现上述功能的机制就是多态，他能帮助找到具体类型和具体方法，实现动态绑定 为了理解RTTI的工作原理，就要知道类型信息在运行时是通过称为Class对象的特殊对象完成的，它被用来创建类的所有常规对象，记录了类有关信息，也就是说每创建一个类，就会产生一个Class对象（也就是同名的.class文件，关于JVM中加载该文件的机制可参见《深入理解Java虚拟机》，最简单的机制就是程序对于类的静态成员应用时，类加载器就会加载该类对应的.class文件，由此可以看出构造器默认就是静态成员方法） Class对象和其他对象一样，可以获取并操作它的引用，也可以使用它的很多方法 forName(String)：返回一个Class对象的引用，如果在运行时使用类型信息，就必须获得恰当的Class对象的引用，这个方法就是实现上述功能的简便途径 getInterfaces()：返回的是Class对象，表示对象包含的接口 getSuperclass()：返回直接基类，进而可以查询发现一个对象的完整类继承结构 newInstance()：实现“虚拟构造器”，其允许你申明不知道确切类型，但是无论如何都可以创建自己，这个类必须带有默认的构造器 除了forName()之外，还可以使用类字面常量来生成对Class对象的引用，即demo.class，类字面还可以应用于接口、数组以及基本数据类型 Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象，通过添加泛型语法可以对Class引用所指向的Class对象的类型进行限定 RTTI形式 传统的类型转换，由RTTI确保类型转换的正确性 代表对象的类型的Class对象，通过查询Class对象可以获取运行时信息 instanceof 注册工厂参见 工厂模式 上述的方法中RTTI能告诉对象的确切类型的前提是这个类型在编译时必须已知，但有时候在编译时程序无法获知对象的类信息（如RMI)，这时候就需要使用反射概念，由Class类和java.lang.reflect类库一起实现反射概念，类库中包含Field、Method、Constructor类，这些类型的对象由JVM在运行时创建，用于表示未知类的成员，并通过相应方法就能在运行时确定匿名对象的类信息 反射没有什么神秘之处，和RTTI真正的区别就在于.class文件在编译期是不可以获取的，要由JVM在运行时打开和检查.class文件。反射是为了支持Java其他特性的，如对象序列化和JavaBean 动态代理：可以动态创建代理并且处理对所代理方法的调用，在动态代理上所做的调用都会被重定向到单一的调用处理器上，它的工作是揭示调用类型并确定相应的对策，Spring AOP默认使用动态代理 通过调用静态方法Proxy.newProxyInstance()创建动态代理，这个方法需要一个类加载器，一个需要该代理实现的接口列表以及InvocationHandle接口的一个实现，这样这个动态代理就可以把所有调用重定向到调用处理器上，因此在调用处理器的构造器传递一个实际对象，由它来实际执行代理，即将请求转发。在调用处理器只需要实现一个invoke()方法，在内部，接口的调用将被重定向对代理的调用 代理模式参见 代理模式 引入反射也会带来坏处，这样不管是private、protected方法都可以通过反射机制访问到，但反射带来的好处是不言而喻的]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一等函数]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8AFP-%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[在Python中，函数是一等对象，和整数、字符串和字典没有区别，有了一等函数，就可以使用函数式风格编程 一等对象的定义 在运行时创建 能赋值给变量或者数据结构的元素 能作为参数传给函数 能作为函数的返回结果 从这个定义，把C、Java的对象代进去，就会想到之前在写C的时候，在想为什么函数只能返回数值，连数组都不能返回（指针除外），Python把函数作为一等对象，不就能解除这个限制。又去联想了一下在SICP上一直接触的lisp，对函数式编程的理解就像是被打通了]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《流畅的Python》]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84Python%E3%80%8B%2F</url>
    <content type="text"><![CDATA[之前看过一部分,但总觉得学不到什么,现在看完了《计算机程序的构造与解释》，我觉得我有能力和视野来阅读这本书了 由于先入为主的影响，开发者总会在学会第一门编程语言之后，在其他语言的编写上带上之前语言的思维。本书就是要讲解Python特有的语言特性，将其独有的特性和其他语言剥离开来 Python是一门多范式编程语 数据模型集合类型把函数作为一等对象 一等函数 面向对象控制流程元编程]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 寄存器机器里的计算]]></title>
    <url>%2F2019%2F01%2F14%2F%E3%80%8ASICP-%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[折磨了自己好久，终于看到了最后一章，也终于打通了自己的任督二脉，抓到了藏在计算机中的那只精灵 编译通用计算机是寄存器机器，它的组织形式也是围绕这一组寄存器和一组操作，这些元素构成了数据通路集合。通用计算机的控制器也是一个寄存器机器语言的解释器。用机器语言写出的程序就是指令的序列 为了在高级语言和寄存器机器语言之间的鸿沟上架设一座桥梁，存在两种常见策略 解释：用有关机器的本地语言写出一个解释器，它设法配置好这部机器，是他能够执行某个语言（源语言）的程序。这种源语言的基本过程被实现为一个子程序库，用给定机器的本地语言写出。]]></content>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《哥德尔·艾舍尔·巴赫》]]></title>
    <url>%2F2019%2F01%2F13%2F%E3%80%8A%E5%93%A5%E5%BE%B7%E5%B0%94%C2%B7%E8%89%BE%E8%88%8D%E5%B0%94%C2%B7%E5%B7%B4%E8%B5%AB%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一本空前的奇书，以精心设计的巧妙笔法介绍了数理逻辑、可计算理论、人工智能等领域的艰深理论，是计算机领域的科普入门书 即使记录了一些笔记，但绝不代表自己真的看懂这本书！ GEBEGB人工智能研究中的一个重大问题，就是要指出如何跨越两种描述的鸿沟，即如何构造这个系统，使它可以接收一个层次上的描述，然后从中生成另一个层次上的描述 自我认知时的混乱，是因为我们本身由许多层次构成，同时我们用重叠的语言在所有层次上描述自己计算机系统也有许多层次的描述共存。计算机程序在运行的时候，可以在若干个层次上观察它在低层次，描述复杂的就像对电视屏幕上光点的描述一样，但就某些目的而言，这是最重要的视角，在最高层次，描述极大程度地组块化 存储器被分为若干称为字的物理上分离的单元，一个字可以分为计算机科学的原子的东西：位。一个位不过是一个开关，但是就像钱可以有各种不同的用途，32位组成的字也可以解释成不同的功能 汇编语言的主要意义不在于它和机器语言并不显著的区别，而是一个关键想法，程序完全可以在不同的层次上编制 任何程序都是在机器语言层次运行，但是用汇编语言来考虑同样合理，没有理由排斥一个以更好层次观点进行的事物描述 计算机靠自己把程序从高层次翻译到了低层次 把高级语言翻译成低级语言的过程就像从应用题传换成方程式一样复杂 50年代，编译程序被编制出来，同时解释程序被发明出来，这两者就像同声翻译和书面翻译 不妨把Lisp语句只看成一条条数据，它们被连续送到一个不停运行的机器语言程序即Lisp解释程序 第一个编译程序是用汇编程序书写的。随着复杂度升高，人们意识到，一个部分完成了的编译程序可以对其他部分进行编译，这称为自举。就像刚学会母语的幼儿，可以利用语言取得新的语言，因而语言能力飞速增长 程序在出毛病的时候，能够在不同的层次上思考才变得重要起来。报告程序出错的说明往往低于程序书写该程序的层次 对于编写编译程序、解释程序的程序员，最大的问题就是想办法编写差错子程序，以便给那些程序出错的用户提供高层而非底层的问题描述说明 实际上，大脑中一定存在着某种类似操作系统的事件，同时控制多重刺激，决定哪一种优先于其他，优先权保持多久，紧急情况和偶发事件造成的中断，等等 理解和构造智能的关键之一就存在于语言的不断开发和改进之中 程序员在使用那种语言时，就被引入程序空间的那些区域，因而为程序员做某些事情提供便利 使用不同的语言编程就像使用不同的调式作曲，每个调式都有独特的感情色彩 软件和硬件的区别到底是什么？就像我们自身，我们不能期望长出任何颜色的头发，但我们能为我们的心智重新编程。这意味着我们不能让大脑的神经元兴奋一些或慢一点，不能重建他们的内部结构，但我们仍能够控制自己的思维方式。但我们的心智不能让我们快速学会一门语言，思考好几件事情，这就是大脑结构也就是硬件导致的缺陷 例如球队中的球员，他们在成为更大的系统的一部分时，自身的个性已经改变，这种系统称为几乎可分解系统，物理学中的原子结构就印证了这一点，但是物理中也有其反例，系统中包含的极强的相互作用，使得其成分被系统吞没，丧失部分或全部个性。例如夸克，它是一种假象的粒子，它能帮助理解质子和中子的某些性质，但自身的存在可能永远无法被单独确认，这种系统称为几乎不可分解系统 在科学的层次结构中，层次间总是有些渗透的，因此化学家无法完全不考虑低层的物理学，生物学家无法不考虑化学，但是两个相距较远的层次间几乎没有渗漏 一个人所需的一切不过是一个关于最高层活动方式的模型？？ 编程序的语言层次越高，越无法确切知道你让计算机干的事。计算机只能做你告诉它去做的事 旁效现象：类似于量变引起质变，就像运动员100米能跑10秒，这个时间是他的身体构造和反应时间的一个结果，但这个值却没有存储在体内的任何地方。又如，操作系统也许只能应付35个以内的用户，超过35个反应时间就会变得很慢，这个数值也并没有烧录在计算机内部，但是整个系统组织一个可以看见的结果]]></content>
      <tags>
        <tag>科普</tag>
        <tag>逻辑</tag>
        <tag>计算机</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章 元语言抽象]]></title>
    <url>%2F2019%2F01%2F12%2F%E3%80%8ASICP-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[从这里开始，我们要把自己看做语言的设计者，而不仅仅是别人设计好的语言的的使用者 之前一张讲述的是面对对象编程，这一章开始讲解函数式编程 任何一门语言都不足以满足我们的需要，因而需要转向新的语言，去更有效的表达我们的想法，因为新语言可以使我们以一种完全不同的方式，利用不同的原语，不同的组合方式和抽象方式去描述和思考所面对的问题 元语言抽象就是建立新的语言，我们不仅可以设计语言，还可以通过构造求值器（解释器）去实现这些语言 求值器决定了一门程序设计语言中各种表达式的意义，但它本身不过就是一个过程。处理大规模计算机系统的技术，与构造新的程序设计语言的技术紧密联系，而计算机科学本身不过就是有关如何构造适当的描述语言的学科 元语言求值器用与被求值的语言同样的语言写出的求值器成为元循环 求值的环境模型包括两个部分 在求值一个组合式时，首先求值其中的子表达式，而后将运算符子表达式的值作用于运算对象子表达式的值 在将一个复合过程应用于一集实际参数时，我们在一个新的环境里求值这个过程的体。构造这一环境的方式就是用一个框架扩充该过程对象的环境部分，框架中包含的是这个过程的各个形式参数与这一过程应用的各个实际参数的约束 这两条规则描述了求值过程的核心部分，也就是它的基本循环。在这一循环中，表达式在环境的求值被归约到过程对实际参数的应用，而这种应用又被归约到新的表达式在新的环境中的求值，直到我们下降到符号（其值可以在环境中找到）或者基本过程（可以直接应用）]]></content>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F2019%2F01%2F11%2FHF-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Head First 设计模式》]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 装饰者模式 工厂模式 代理模式]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第18章 Java I/O流]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8ATIJ-Java-I-O%E6%B5%81%E3%80%8B%2F</url>
    <content type="text"><![CDATA[创建一个好的I/O系统是个艰难的任务，因为要覆盖所有可能性。不仅存在各种I/O源端和想要与之通信的接收端（文件、控制台、网络套接字等），还需要以各种不同的方式与他们通信（顺序、随机存取、缓冲、二进制、按字符、按字节、按行等）。Java设计者通过创建大量的类来解决上述问题 输入和输出流这个概念表示任何有能力产出数据的数据源对象或有能力接受数据的接收端对象，流屏蔽了实际的I/O设备中处理数据的细节]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 文件I/O]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8AAPUE-%E6%96%87%E4%BB%B6IO%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本章描述不带缓冲的I/O函数，原子操作，如何在多个进程间共享文件，以及内核相关的数据结构 不带缓冲指的是每个read和write都调用内核中的一个系统调用 对于内核而言，所有打开的文件都通过文件描述符引用 函数open&amp;openat用于打开和创建一个文件open：int open(const char *path,int oflag,.../* mode_t mode */;openat：int openat(int fd,const char *path,int oflag,.../* mode_t mode */); 使用下面的参数进行或运算构成oflag参数 O_RDONLY：只读打开 O_WRONLY：只写打开 O_RDWR：读写打开 O_EXRC：只执行打开 O_SEARCH：只搜索打开（用于目录） 上述五个参数必须制定一个且只能制定一个，下面的参数则是可选的 creatcloselseakreadwrite文件共享原子操作函数dup&amp;dup2sync、fsync&amp;fdatasyncfcntlfile control ioctl]]></content>
      <tags>
        <tag>Unix</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四章 高级I/O]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8AAPUE-%E9%AB%98%E7%BA%A7IO%E3%80%8B%2F</url>
    <content type="text"><![CDATA[非阻塞I/O、记录锁、I/O多路转接、异步I/O、存储映射等 非阻塞I/O使我们可以发出open、read和write这样的I/O操作，使这些操作不会永远阻塞，如果这种操作不能完成，则调用立即出错返回，表示该操作如果继续执行将阻塞 I/O多路转接对于一个进程由多个输入输出时，显然不能使用阻塞I/O 一种方法是多进程，每个进程处理一条数据通路，但是这种方法会由于进程间通信而是程序变得复杂 另一种方法仍然使用一个进程，但使用非阻塞I/O，通过轮询机制去查看不同描述符是否有数据可读，这种方法的缺陷在于浪费CPU时间，大部分轮询都是无意义的 异步I/O：进程告诉内核，当描述符准备好可以进行I/O时，用一个信号告诉它。这种技术一个问题是标准不一样，移植不方便，二是这种信号对于进程来说只有一个，进程无法判断该信号是对指示了哪个描述符准备好了，况且信号数量远小于潜在的打开文件描述符的数量，因此仍然需要将描述符设置为非阻塞的，当信号来的时候，轮询不同的描述符 I/O多路转接：先构造一张感兴趣的描述符的列表，然后调用一个函数，直到这些描述符中的一个已准备好进行I/O时，该函数才返回]]></content>
      <tags>
        <tag>Unix</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 标准I/O库]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8AAPUE-%E6%A0%87%E5%87%86IO%E5%BA%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[文件I/O函数都是围绕文件描述符来描述的，而对于标准I/O库来说，它的操作都是围绕流进行的，当用标准I/O库打开或者创建一个文件时，已使一个流与文件相关联 流和文件描述符区别流是文件描述符的抽象，文件描述符是系统层次的调用。 当向一个文件读入或者输出时，既可以选择流，也可以选择使用文件描述符。文件描述符是int类型的，而流是用FILE来表示的。 文件描述符提供了一个原始、低层次的输入输出接口。文件描述符和流都可以表示一个连接，可以是和设备的（例如终端），或者管道，或者一个和另一个进程的套接字，或者就是一个正常的文件（normal file)。但是，如果你想要对特殊设备进行特定的操作，你必须使用文件描述符。另外，如果你的程序需要以特殊模式进行输入输出（例如nonblocking, polled input)，也必须使用文件描述符。 而流提供了一个基于原始的文件描述符的高层次接口。流接口对于所有类型的文件的操作大多都是类似的，唯一的区别就是缓冲的策略 使用流的主要优势是操作流的函数比文件描述符多得多，而且更加强大方便。文件描述符仅仅提供了一个单一的函数用来传输字符块，但是流接口提供了很多格式化的输入输出（例如printf和scanf）和一些字符函数以及列读入输出函数。因为流是基于文件描述符的，所以实际上你可以“拆解”一个流得到对应的文件描述符然后进行低层次的操作。相反地，你也可以先用文件描述符和一个文件建立连接，然后建立一个链接这个文件描述符的流对象。通常情况下，你都应该使用流来进行输入输出，这样不仅方便强大，而且可以保证程序的移植性：你可以在任何一个遵守ISO C标准的机器上使用流，但是在一个非GNU机器上你可能无法使用文件描述符。 流对于ASCII字符集，一个字节表示一个字符；对于国际字符集来说，多个字节表示一个字。标准I/O文件流可以用于单字节或是多字节字符集 流的定向（Strea’s Orientation）决定了所读、所写的字符是单字节还是多字节的，一个流初创建的时候，并没有被定向，只有在该流上使用I/O函数，才会被定向是多字节还是单字节的 fwide函数可用于设置流的定向，但不改变已定向流的定向：int fwide(FILE *fp,int mode)]]></content>
      <tags>
        <tag>Unix</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《UNIX环境高级编程》]]></title>
    <url>%2F2019%2F01%2F11%2F%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[Code 第三章 文件I/O 第五章 标准I/O库 第十一章 线程 第十四章 高级I/O]]></content>
      <tags>
        <tag>Unix</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《狗十三》]]></title>
    <url>%2F2019%2F01%2F10%2F%E3%80%8A%E7%8B%97%E5%8D%81%E4%B8%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[能和这部影片产生过多共鸣的人的青春一定是不幸的，而我是幸运的 一直都反感身处的教育体系，可总归要好好读书，要考个好大学，身处在这个大环境下，却无力跳出这个教育的脏泥潭 “要懂事，要听话”，童年里听过的最多的一句话，要懂事无非是要无条件接受大人强加给自己的观念，要听话无非是大人说话的时候闭上嘴。当你开始明白这个成人的游戏规则，你就长大了。当你学会在什么样的人面前说什么样的话，你就学会了情商课中最重要的一节课，而我始终不愿学会这节课，因为我不想这样长大。我明白这样选择的后果，我可能会一次一次的被生活被社会教训，但那又怎样呢，我觉得我很自由啊 身旁都是一群中国式教育的牺牲品，甚至包括自己。电影中的一幕让我发笑，教室中出现了一只蝙蝠，同学们都在起哄，只有老师大吼：“越是在这个时候，越能看出一个人的定力”，这句话简直和我记忆中一模一样。似乎努力克服自己的本性，顺应家长，顺应老师，顺应领导的学生才是好学生，有自我意识的学生总会被打压 看完这部电影，我才明白自己身处一个多么幸福的家庭，一个无条件支持自己的父亲，虽然总给自己洗脑，让我去考公务员，但从来只是自己说说，不会对自己有多少影响，还有一个始终想不通她的智慧来自哪里的母亲，以这样的受教育经历能做出这样的教育行为，我真的很吃惊。在我的成长路径上，多数决定都是自己做出来的，父母从来不是自己的路障，而是自己的陪伴者 记得自己唯一一次被打，还是因为自己老是拖欠作业，有拖延症的毛病。我想也正是因为那次记忆深刻的被打，现在自己总能准时完成任务。关于早恋，我觉得父母做的也很棒，虽然他们早就知道我谈恋爱，连我都不知道他们知道，但他们没有采取激进的方式，也是睁一只眼闭一只眼。我的成长真的可以说是“自由生长”，连高中压迫自己静下心来学习，也是自己做的决定，而不是被迫。这样的成长经历让我很晚才意识到读书学习的重要性，但又有什么不好呢？ 虽然电影的主角已经妥协，在这种不断被伤害的成长中，选择了适应，但希望自己还能在挣扎多一点，不要太快成长为自己讨厌的样子。因为我明白自己终归也会向社会、向生活妥协 愿每个人的青春回忆起来都是甜的！]]></content>
      <tags>
        <tag>教育、成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《vim学习》]]></title>
    <url>%2F2019%2F01%2F09%2F%E3%80%8Avim%E5%AD%A6%E4%B9%A0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[强大的编辑器，是适合和黑客一样脱离鼠标了 https://vim-adventures.com/ ctrl + &#39;-&#39;：字体缩小ctrl + shift + &#39;=&#39;：字体放大ctrl + s：暂停该程序ctrl + q：继续执行 Vim命令模式下输入：vnew filename，竖向分屏 splite filename：上下分屏 Ctrl+W+L把光标移到左边的屏中Ctrl+W+H把光标移到上边的屏中Ctrl+W+K把光标移到下边的屏中Ctrl+W+J q：退出分屏 set number：显示行号 Sublime 鼠标选中多行，按下 (Command Shift L) 即可同时编辑这些行； 鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑； 鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑； Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac)或使用鼠标中键可以用鼠标进行竖向多行选择； Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑的多处文本 Ctrl Shift L + 上下：交换上下行]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 模块化、对象和状态]]></title>
    <url>%2F2019%2F01%2F08%2F%E3%80%8ASICP-%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[有效的程序综合需要组织原则，他们知道我们系统化完成系统的整体设计，是系统能自然划分为一些具有内聚力的模块，便于开发和维护。这章要研究两种特点鲜明的组织策略，他们分别把注意力放在对象和流上 对象并发时间是一个本质问题】2就对于对象策略，我们关注计算对象可以怎样变化而又同时保持其标志，这迫使我们采取环境模型，这一模型有因为引入时间，使得对并发的处理变得很困难，而流策略可以通过延时求值的技术解决上述问题，解耦模型中对时间的模拟和事件发生的顺序 流流可以缓和状态模拟中的复杂性，流就是一个序列，可以模拟一些包含状态的系统，但却不需要利用赋值或者变动数据，从而避免由于引进赋值而带来的内在缺陷 流使我们可以使用序列操作，又不会带来序列的时间和空间代价。基本想法就是做出一种安排，只是部分地构造出流的结构，并将这部分结构给使用流的程序，如果使用程序还需要未构造的部分，流就会继续构造下去，但只构造当时需要的部分，这就造成一种假象，好像整个流都存在一样。也就是说我们要设计的流，使得流的构造和流的使用是交错进行的，但是这种交错又是完全透明的 为了实现流，采取一种叫做延时对象的对象，它可以看做是对未来的某个时间求值的许诺。和delay一起的还有一个叫做force的过程，它以一个延时对象作为参数，执行相应的求值工作，也就是迫使delay完成它许诺的求值 上述做法松弛了计算中事件发生的实际顺序和过程的表面结构的关系 可以利用这种技术去表述无穷长的序列]]></content>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《目标文件》]]></title>
    <url>%2F2019%2F01%2F07%2F%E4%BF%AE%E5%85%BB-%E3%80%8A%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[编译器编译源码生成的文件就叫目标文件，那目标文件里面到底长什么样？ 目标文件从结构上将，就是编译后的可执行文件格式，只是没有经过链接的过程。这两种文件和操作系统、编译器密切相关 可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面，了解它的结构并深入剖析对理解系统、机理大有好处 可执行文件主要有Windows的PE和Linux的ELF，目标文件如前所说，是未进行链接的中间文件（如Windows的.obj和Linux的.o）。我们可以将其看做同一个类型的文件 除此之外，动态链接库（DLL，如Windows的.dll和Linux的.so）和静态链接库（Windows的.lib和Linux的.a）都按照可执行文件格式存储 但如果要细分这些类型文件，则 可执行文件：如Windows的.exe 共享目标文件：如Windows的.dll和Linux的.so，一种链接器可以将其和其他可重定位文件和共享目标文件链接产生新的目标文件；第二种动态链接器将其与可执行文件结合，成为进程镜像的一部分 可重定位文件：如Windows的.obj和Linux的.o，可以被链接成可执行文件或共享目标文件 核心转储文件：当进程意外终止，系统将进程的地址空间的内容和一些终止信息转储到该文件 目标文件一般按照信息的不同属性，以节（Section）或段（Segment）的形式存储。这里有个问题，在BIOS代码中，段和节是由区别的，而且是包含的关系，这怎么理解？？？12345678910voidreadseg(uint32_t pa, uint32_t count, uint32_t offset)&#123; ... while (pa &lt; end_pa) &#123; readsect((uint8_t*) pa, offset); ... &#125;&#125; 一般机器指令放在代码段（.code或.text），全局变量和局部静态变量放在数据段中（.data） 数据和指令分开放置的好处： 数据和指令在装载后，会被映射到两个虚拟内存区域，这两个区域可以设置不同的读写权限，防止指令被修改 指令和数据分离有利于提高程序的局部性，进而提高缓存的命中率 指令共享，当系统运行多个该程序的副本时，内存中只需要保存一份该程序的指令，这将节省大量空间 用例子说话12345678910111213141516171819202122int printf(const char * format,...);int global_init_var = 84;int global_uninit_var;void func1(int i)&#123; printf("%d\n",i);&#125;int main()&#123; static int static_var = 85; static int static_var2; int a = 1; int b; func1(static_var + static_var2 + a + b); return a;&#125; 使用命令objdump -h simplesection.o来查看ELF文件各个段的信息123456789101112131415161718simplesection.o: file format elf64-x86-64Sections:Idx Name Size VMA LMA File off Algn 0 .text 00000057 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 0000000000000000 0000000000000000 00000098 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 0000000000000000 0000000000000000 000000a0 2**2 ALLOC 3 .rodata 00000004 0000000000000000 0000000000000000 000000a0 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 0000002b 0000000000000000 0000000000000000 000000a4 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000cf 2**0 CONTENTS, READONLY 6 .eh_frame 00000058 0000000000000000 0000000000000000 000000d0 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA Size很好理解；File off指示了段的偏移量，即段所在位置；CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE则表示段的属性，只有标记了CONTENTS才是在文件中实际存在的 使用参数-s可以段的内容以十六进制展现出来，-d可以将所有包含指令的段反汇编 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758simplesection.o: file format elf64-x86-64Contents of section .text: 0000 554889e5 4883ec10 897dfc8b 45fc89c6 UH..H....&#125;..E... 0010 488d3d00 000000b8 00000000 e8000000 H.=............. 0020 0090c9c3 554889e5 4883ec10 c745f801 ....UH..H....E.. 0030 0000008b 15000000 008b0500 00000001 ................ 0040 c28b45f8 01c28b45 fc01d089 c7e80000 ..E....E........ 0050 00008b45 f8c9c3 ...E... Contents of section .data: 0000 54000000 55000000 T...U... Contents of section .rodata: 0000 25640a00 %d.. Contents of section .comment: 0000 00474343 3a202855 62756e74 7520372e .GCC: (Ubuntu 7. 0010 332e302d 32377562 756e7475 317e3138 3.0-27ubuntu1~18 0020 2e303429 20372e33 2e3000 .04) 7.3.0. Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001 .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000 ................ 0020 00000000 24000000 00410e10 8602430d ....$....A....C. 0030 065f0c07 08000000 1c000000 3c000000 ._..........&lt;... 0040 00000000 33000000 00410e10 8602430d ....3....A....C. 0050 066e0c07 08000000 .n...... Disassembly of section .text:0000000000000000 &lt;func1&gt;: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: 48 83 ec 10 sub $0x10,%rsp 8: 89 7d fc mov %edi,-0x4(%rbp) b: 8b 45 fc mov -0x4(%rbp),%eax e: 89 c6 mov %eax,%esi 10: 48 8d 3d 00 00 00 00 lea 0x0(%rip),%rdi # 17 &lt;func1+0x17&gt; 17: b8 00 00 00 00 mov $0x0,%eax 1c: e8 00 00 00 00 callq 21 &lt;func1+0x21&gt; 21: 90 nop 22: c9 leaveq 23: c3 retq 0000000000000024 &lt;main&gt;: 24: 55 push %rbp 25: 48 89 e5 mov %rsp,%rbp 28: 48 83 ec 10 sub $0x10,%rsp 2c: c7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 33: 8b 15 00 00 00 00 mov 0x0(%rip),%edx # 39 &lt;main+0x15&gt; 39: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 3f &lt;main+0x1b&gt; 3f: 01 c2 add %eax,%edx 41: 8b 45 f8 mov -0x8(%rbp),%eax 44: 01 c2 add %eax,%edx 46: 8b 45 fc mov -0x4(%rbp),%eax 49: 01 d0 add %edx,%eax 4b: 89 c7 mov %eax,%edi 4d: e8 00 00 00 00 callq 52 &lt;main+0x2e&gt; 52: 8b 45 f8 mov -0x8(%rbp),%eax 55: c9 leaveq 56: c3 retq 接下来一段段分析 代码段1234567Contents of section .text: 0000 554889e5 4883ec10 897dfc8b 45fc89c6 UH..H....&#125;..E... 0010 488d3d00 000000b8 00000000 e8000000 H.=............. 0020 0090c9c3 554889e5 4883ec10 c745f801 ....UH..H....E.. 0030 0000008b 15000000 008b0500 00000001 ................ 0040 c28b45f8 01c28b45 fc01d089 c7e80000 ..E....E........ 0050 00008b45 f8c9c3 ...E... 最左边是偏移量，因此总共0x57个字节，和上述信息吻合 然后去对照下面的汇编指令，发现一模一样！！！ 数据段.data保存的是初始化的全局静态变量和局部静态变量，也就是static_var global_init_var两个变量 .rodata保存的是只读数据（read only，如const修饰的变量和字符串变量），对应源代码中的%d\n。单独设立该段的好处：在语义上支持了const，OS在加载的时候可以将该段映射到可读的，保证安全性？？ 54000000 55000000也可以看出机器的大端的 BSS段.bss存放未初始化的全局变量和局部静态变量，但有些编译器会将此类变量放在.bss段中，有些则不存放，只是预留一个未定义的全局变量符号 其他段这些段和其他一些功能有关，先不介绍 我们也可以自定义段，让变量或者代码能放到指定的段中，以实现特定的功能，如为了满足某些硬件的内存和I/O的地址布局，或Linux内核用来完成一些初始化和用户空间复制时出现页错误？？？ GCC提供__attribute__((section(&quot;name&quot;)))属性来将变量和函数放到name段中 ELF文件ELF文件的开始是一个File Header，它描述了文件的属性，如文件是否可执行、是静态链接还是动态链接、入口地址、目标硬件、目标OS等信息，除此之外，还有一个Section Table，描述接下来各个段的信息，如各个段在文件的偏移量、段的属性 学习ELF最好的方法就是直接看源码定义，在/usr/include/elf.h，头文件定义分为32位和64位，我们以32位为准 文件头123456789101112131415161718192021/* The ELF file header. This appears at the start of every ELF file. */#define EI_NIDENT (16)typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */&#125; Elf32_Ehdr; 虽然下图是64位可执行文件的文件头，但是依旧可以寻找一一对应关系 关于魔数还有个小故事，这些故事归结起来就是马屁股和航天飞机，也就是经济学中的路径依赖，映射到互联网就是培养用户习惯，在我们的生活中，处处都是路径依赖，因为事务总不能脱离历史发展，那么有办法摆脱路径依赖，或者有办法找到好的路径吗？ 段表段表描述了ELF文件的每个段的信息，如段名、长度、偏移、读写权利等，编译器、链接器和装载器都是依靠段表来定位和访问每个段 123456789101112131415/* Section header. */typedef struct&#123; Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */&#125; Elf32_Shdr; 段的名字只在链接和编译期间有意义，对操作系统没有意义 重定位表重定位表也是ELF的一个段，对于需要重定位的代码段或数据段，都会有一个相应的重定位表 字符串表往往把长度不定的字符串集中起来存放，然后使用字符串在表中的偏移来引用字符串 链接的接口：符号链接的本质就是不同目标文件得到结合，这些目标文件之间必须要固定的规则，才能像积木一样结合在一起 在链接中，将函数和变量统称为符号，符号是链接中的粘合剂，整个链接都是基于符号完成的 每个目标文件都有一个符号表，这个表记录了目标文件中的所有符号，每个符号对应的值，称为符号值，对于变量和函数，符号值就是地址。符号也有分类： 定义在目标文件的全局符号，可以被其他目标文件引用 定义在其他目标文件的全局符号 段名，由编译器产生 局部符号 行号信息 我们只关心全局符号，其他符号对于链接过程都是无关紧要的，readelf objdump nm都能查看符号表 符号表就是一个elf32_sym结构的数组，每个元素对应一个符号1234567891011/* Symbol table entry. */typedef struct&#123; Elf32_Word st_name; /* Symbol name (string tbl index) */ Elf32_Addr st_value; /* Symbol value */ Elf32_Word st_size; /* Symbol size */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf32_Section st_shndx; /* Section index */&#125; Elf32_Sym; 每个元素都会有相关的宏定义，代表不同的含义，具体参考elf.h 特殊符号:在使用ld作为链接器来生成可执行文件时，会定义很多特殊符号，这些符号被定义在ld链接器的链接脚本中。链接器会在程序最终链接成可执行文件的时候将其解析成正确的值，如_executable_start表示程序起始地址 _etext表示代码段结束地址等 编译器默认函数和初始化的全局变量为强符号，未初始化的全局变量为弱符号，也可以通过GCC的__attribute__((weak))定义任何一个强符号为弱符号，且对于强弱符号有以下规则 强符号不能重复定义 优先选择强符号定义 都是弱符号定义时，选择占用空间最大的那个 目标文件会引用定义在其他目标文件中的符号，并在最终链接成可执行文件，如果没有找到该符号定义，就会报错的符号引用称为强引用，反之则为弱引用，可通过__attribute__((weakref))声明对一个外部引用为弱引用]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《静态链接》]]></title>
    <url>%2F2019%2F01%2F07%2F%E4%BF%AE%E5%85%BB-%E3%80%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E3%80%8B%2F</url>
    <content type="text"><![CDATA[如何链接两个目标文件成为一个可执行文件？ 编译与链接一句简单的gcc hello.c可分解为4个步骤，预处理、编译、汇编、链接 预处理1gcc -E hello.c -o hello.i 此过程只处理以#开始的预编译命令 展开所有宏定义，并删除#define 处理所有条件预编译指令，如#if #ifdef #ifndef等 处理所有#include，把包含的文件插入该指令的位置 删除所有注释 添加行号和文件名，为编译器调试和产生错误提供信息 保留所有#pragma 下面是一个预处理之后的文件的一部分 如果无法判断宏定义是否正确或头文件是否正确，可以通过查看预编译后的文件来确定问题 编译这个过程是这个过程的核心部分，包括词法分析、语法分析、语义分析及优化，具体参见《编译原理》 1gcc -S hello.c -o hello.s 参数-S输出编译后的汇编代码文件 GCC这个命令只是后台程序的包装，根据不同的参数去调用预编译编译程序cc1、汇编器as、链接器ld 汇编汇编器将汇编代码转换成机器可以执行的指令，只要根据汇编指令和机器指令的对照表一一翻译就可以 12345as hello.s -o hello.ogcc -c hello.s -o hello.ogcc -c hello.c -o hello.o 上面三条指令都能直接输出目标文件（Object File），可以用objdump查看目标文件内容 链接需要一堆文件链接起来才能得到可执行文件，这涉及到编译、链接和库，甚至时操作系统的底层内容 通常上面的一系列编译，终于产生了目标代码，但是目标代码中的变量可能定义在其他地方，这时候就该链接器出场！链接器的年龄比编译器还长！ 最开始记录程序用的是纸带，穿孔表示0.没穿孔表示1，例如跳转指令就是0001 XXXX，后四位就是跳转地址，而对于这个地址是需要人工去计算的，而且只要程序修改，就要重新计算，这一过程就叫做重定位 为了消除这个繁琐的过程，人们发明了汇编语言，比如用jmp表示0001 XXXX跳转指令。还可以使用符号来标记位置，如.LEF0，比记录当前指令的开始的第几条指令更容易。之后在修改程序之后，汇编器就会重新计算.LEF0的位置，并把所有引用该符号的指令都修正一遍 有了汇编语言以后，代码规模就快速膨胀。软件组织出现了模块化，模块化的拼1接也就是链接。链接过程主要包括地址和空间分配、符号决议、重定位，本质上就是上面的“原始人”所做的工作 空间与地址分配符号解析和重定位静态库链接链接过程控制]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链路层]]></title>
    <url>%2F2019%2F01%2F07%2F%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F2019%2F01%2F07%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络层实现主机到主机的通信服务，在网络中的每一台主机和路由器都有一个网络层部分，是协议栈中最复杂的部分，也是最有趣的部分 要跳出现有系统的限制来思考问题，想想什么是可行的！ 一个人要不断地超越自我，否则还有什么乐趣可言？！ 概述转发与路由选择网络服务模型虚电路数据报网络转发路由器原理路由器有四个组成部分 输入端口：它既要执行将一条输入的物理链路与路由器相连接的物理层功能；还要执行需要与位于入链路远端的数据链路层交互的数据链路层功能；还要完成查找功能，在这里通过查询转发表决定路由器的输出端口 交换结构：将输入与输出端口相连接，这种交换结构完全包含在路由器中，是路由器的网络 输出端口：存储从交换结构接受的分组，并通过执行必要的链路层和物理层功能在输入链路上传输这些分组 路由选择处理器：执行路由选择协议，维护路由选择表以及连接的链路状态信息，并为路由器计算转发表 路由器的转发功能总是用硬件实现，因为该功能是以纳秒时间尺度执行的，这远超过软件实现的速率，路由器的控制功能在毫秒或者秒时间尺度执行，因此用软件实现并在路由选择处理器上执行 输入端口上面说过在这里，路由器通过转发表来查找输出端口，转发表是由路由选择处理器计算和更新的，但是转发表的一份影子副本通常被放在每个输入端口，通过独立总线（如PCI总线）复制到线路卡，这样就能在输入端口做出转发决策 概念上只要搜索转发表查找最长前缀匹配，但这种查找必须在纳秒级执行，因此除了硬件帮助还要快速查找算法 当分组确定了输出端口，就会进入交换结构。在某些设计中，如果其他输入端口的分组当前正在使用交换结构，一个分组可能会在进入时被暂时阻塞，要排队等待调度 除此之外，在输入端口还要做其他操作 必须出现物理层和链路层处理？？ 必须检查分组的版本号、检验和寿命字段，并重写后两个字段 更新用于网络管理的计数器，如接受到的IP数据包的数目 最后，对于在输入端口做的处理，即查找IP地址然后发送该分组进入交换结构，我们抽象成匹配加动作的特定执行，这种抽象作用很大，而且在网络设备中无处不在 交换结构交换可以用许多方式完成 经内存交换：最早的路由器就是传统的计算机，交换是由CPU的直接控制下进行，输出、输出端口就像传统OS的I/O设备一样 经总线交换：输入端口经一根共享总线将分组直接传送到输出端口，不需要路由处理器的干预。让输入端口为分组预先计划一个交换机内部标签，指示本地输出端口，使分组在总线上传送到输出端口。该分组能由所有输出端口收到，但是只有与该标签匹配的端口才能保存该分组。到达后，标签由输出端口去除，因为标签只用于交换机内部来跨越总线。这种方法的缺点在于总线是共享的，一次只能有一个分组能够跨越总线 经互联网络交换：该结构类似于井字格，由2N条总线组成的互联网络，它；连接N个输入端口和N个输出端口，交叉点通过交换结构控制器能在任何时候开启与关闭。因此纵横式网络能够并行转发多个分组，但是对于有相同输出端口的分组，依旧有阻塞、排队的现象 输出端口处理取出存放在输出端口内存中的分组并将其发送给输出链路上 排队排队的位置取决于流量负载、交换结构的相对速率和线路速率。当队列增大时，就会出现缓存空间耗尽的情况，此时就会出现丢包 假设所有分组都发向相同的输出端口，这时候输出端口的队列就会无限增大。那路由器需要多少缓存来吸收流量负载的波动？一种经验方法是和平均往返时延和链路容量之间的函数决定 当输出端口出现排队，就需要分组调度程序来决定选取一个分组来发送。这种选择的原则有先来先服务调度（FCFS）、加权公平排队（WFQ） 如果实在没有足够内存来缓冲一个分组，就需要策略来决定丢掉分组。一种是丢弃到达的分组（弃尾）；另一种就是删除一个或者多个分组，来为新的分组腾出空间 在缓冲填满前便丢弃分组，以便向发送方提供一个拥塞信号，这种策略统称为主动队列管理（AQM）算法。其中随机早期检测（RED）是一种广泛应用的AQM算法。在RED算法中，为输出队列维护一个加权平均值，如果队列长度小于最小阈值，则接纳分组，如果大于最大阈值，则丢弃分组，如果介于最大阈值和最小阈值之间，则以某种概率被丢弃，该概率是平均队列长度、最大阈值、最小阈值之间的函数 当然输入端口也会出现分组排队现象。 这时候会出现一种叫做线路前端阻塞现象，即在一个输入队列中排队的分组必须等待通过交换结构发送，即使输出端口使空闲的，因为他被位于线路前部的另一个分组阻塞 网际协议因特网编制和转发是网际协议（IP）的重要组件，目前有两个版本的IP在使用，IPv4和IPv6 因特网的网络层有三个组件 IP协议 路由选择部分：决定数据包从源到目的地流经的路径 ICMP协议：报告数据包中的差错和对某些网络层信息请求进行相应的设施 路由选择路由选择算法，是网络层为从发送方到接收方的分组确定所采取的路径的策略 链路状态路由选择算法距离向量路由选择算法层次路由因特网中的路由选择广播和多播路由选择]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运输层]]></title>
    <url>%2F2019%2F01%2F07%2F%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二章：并发编程]]></title>
    <url>%2F2019%2F01%2F07%2FCSAPP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[《CSAPP》第十二章：并发编程 更详细的参考《Java并发编程实战》 并发不仅仅是操作系统内核用来运行多个应用程序的机制，在应用程序中也扮演很重要的角色，应用级并发的作用 访问慢速I/O设备：内核遇到应用在等到I/O数据时，会运行其他进程，使CPU保持繁忙，应用程序也可以模仿类似思路，交替执行I/O请求和其他操作 与人交互：现代视窗系统通过并发实现用户可以在打印文档的同时，调整窗口大小，实现更好的人机交互 通过推迟工作以降低延迟：应用程序通过推迟其他操作和并发地执行它们，利用并发来降低某些操作的延迟 服务多个网络客户端：这允许服务器同时服务多个客户端，避免慢速客户端独占服务器 在多核计算机上进行并行计算 使用应用级并发的程序成为并发程序，现代操作系统提供三种基本的构造并发程序的方法 进程：每个逻辑控制流都是一个进程，由内核来调用和维护，因为进程由独立的虚拟地址空间，控制流需要显式的进程间通信机制来和其他逻辑控制流通信 I/O多路复用：应用程序在一个进程的上下文中显式地调度它自己的逻辑流？？？ 线程：线程是运行在单一进程上下文中的逻辑流，由内核调度，可以把线程看做上述两种方法的混合，像进程流一样由内核调度，又像I/O多路复用一样享受同一个虚拟地址空间 基于进程构造并发服务器最自然的方法就是在父进程接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。使用熟悉的函数，如fork exec waitpid 进程有独立的地址空间既是优点又是缺点，优点是进程不可能覆盖另一个进程的虚拟内存，缺点则是使得进程共享状态信息变得困难。为了共享信息，必须使用显式的IPC机制，除此之外进程控制和IPC（进程间通信）开销也大 12345678910111213141516171819202122232425262728293031#include "csapp.h"void sigchld_handler(int sig)&#123; while(waitpid(-1,0,WNOHANG) &gt; 0) ; return;&#125;int main(int argc,char **argv)&#123; ... Signal(SIGCHLD,sigchld_handler); listenfd = Open_lisentfd(argv[1]); while(1)&#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd,(SA *) &amp;clientaddr,&amp;clientlen); if(Fork() == 0)&#123; Close(listenfd); echo(connfd); Close(connfd); exit(0); &#125; Close(connfd); &#125;&#125;void echo(int connfd)&#123; ... &#125; 父进程也就是服务器派生一个子进程，这个子进程获得服务器描述符表的完整副本，子进程要关闭监听描述符，父进程要关闭已连接描述符，如果不及时关闭已连接描述符，将导致内存泄漏，是系统崩溃 服务器会运行很长时间，因此需要一个SIGCHLD处理程序，来回收僵死子进程的资源，因为SIGCHLD处理程序执行时，SIGCHLD信号是阻塞的，而Linux信号是不排队的，所有该处理程序必须准备好回收多个僵死子进程的资源、 UNIX IPC机制包括信号和waitpid()、套接字接口、管道、先进先出、系统V共享内存、系统V信号量等 基于I/O多路复用当服务器同时遇到用户从标准输入键入的交互命令和客户端发起的连接命令是，该如何选择呢？ 基本思路就是使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序 1234567891011121314151617181920212223242526272829#include "csapp.h"void echo(int connfd)&#123;...&#125;void command(void)&#123;...&#125;int main(int argc,char **argv)&#123; ... listenfd = Open_lisentfd(port); FD_ZERO(&amp;read_set); // clear read set FD_SET(STDIN_FILENO,&amp;read_set); // add stdin to read set FD_SET(listenfd,&amp;read_set); // add listenfd to read set while(1)&#123; ready_set = read_set; Select(listenfd+1,&amp;ready_set,NULL,NULL,NULL); if(FD_ISSET(STDIN_FILENO,&amp;ready_set)) command(); // read command line from stdin if(FD_ISSET(listenfd,&amp;ready_set))&#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd,(SA *)&amp;clientaddr,&amp;clientlen); echo(connfd); // echo client input util EOF Close(connfd); &#125; &#125;&#125; select函数会处理类型为fd_set的集合，称为描述符集合，函数会一直阻塞，直到该集合至少有一个描述符准备好可以读 上面实现了基于I/O多路复用的迭代服务器，下面则是基于I/O多路复用的并发服务器 基于I/O多路复用的并发事件驱动服务器I/O多路复用可以作为并发事件驱动程序的基础，在事件驱动程序中，某些事件会导致流向前推进。事件驱动模型本质上就是状态机。对于一个新的客户端$k$，此服务器会创建一个新的状态机$s_k$，并将其与已连接描述符$d_k$联系起来 服务器使用I/O多路复用，借助select函数检测输入事件的发生，当每个已连接描述符准备好可读时，服务器就为相应的状态机执行转移，在这里就是从描述符读写一个文本行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include "csapp.h"typedef struct&#123; /* represents a pool of connected descriptors */ int maxfd; // largest descriptor in read_set fd_set read_set;// set of all active descriptors fd_set ready_set; int nready; int maxi; int clientfd[FD_SETSIZE]; rio_t clientrio[FD_SETSIZE];&#125;pool;int byte_cnt = 0; // counts total bytes received by server int main(int agrc,char **argv)&#123; int listenfd,connfd; int post; socklen_t clientlen; struct sockaddr_storage clientaddr; static pool pool; port = atoi(argv[1]); if(argc != 2)&#123; fprintf(stderr,"usage:%s &lt;port&gt;\n",argv[0]); exit(0); &#125; listenfd = Open_listenfd(port); init_pool(listenfd,&amp;pool); while(1)&#123; /* wait for listening/connected descriptor to become ready */ pool.ready_set = pool.read_set; pool.nready = Select(pool.maxfd+1,&amp;pool.ready_set,NULL,NULL,NULL); /* if listening descriptor ready,add new client to pool */ if(FD_ISSET(listenfd,&amp;pool.ready_set))&#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd,(SA *)&amp;clientaddr,&amp;clientlen); add_client(connfd,&amp;pool); &#125; /* echo a text line from each ready connected descriptor */ check_clients(&amp;pool); &#125;&#125; 在上述代码中，pool结构里维护着活动客户端的集合，在调用init_pool之后，服务器进入无限循环。在每次循环中，服务器调用select函数来检测两种不同类型的输入事件 来自一个新客户端的连接请求到达 一个已存在的客户端的已连接描述符准备好可以读 当连接请求到达时，服务器打开连接，并调用add_client函数，将该客户端加入池里，最后调用check_clients，把来自每个准备好的已连接描述符的一个文本行送回去 1234567891011void init_pool(int listenfd,pool *p)&#123; int i; p-&gt;maxi = -1; for(i = 0;i &lt; FD_SETSIZE;i++) p-&gt;clientfd[i] = -1; p-&gt;maxfd = listenfd; FD_ZERO(&amp;p-&gt;read_set); FD_SET(listenfd,&amp;p-&gt;read_set);&#125; 上述函数初始化客户端池，clientfd数组表示已连接描述符集合，-1表示可用槽位，此时监听描述符是最大且唯一的描述符 1234567891011121314151617181920void add_client(int connfd,pool *p)&#123; int i; p-&gt;nready--; for(i = 0;i &lt; FD_SETSIZE;i++) if(p-&gt;clientfd[i] &lt; 0)&#123; p-&gt;clientfd[i] = connfd; Rio_readinitb(&amp;p-&gt;clientrio[i],connfd); FD_SET(connfd,&amp;p-&gt;read_set); if(connfd &gt; p-&gt;maxfd) p-&gt;maxfd = connfd; if(i &gt; p-&gt;maxi) p-&gt;maxi = i; break; &#125; if(i == FD_SETSIZE) app_error("add_client error:Too many clients");&#125; 上述函数添加一个新的客户端到活动客户端中，在clientfd数组中找到空的槽位，就将已连接描述符添加到数组中，并初始化RIO读缓冲区，然后将已连接描述符添加到读集合中，并更新全局数值 123456789101112131415161718192021222324252627void check_clients(pool *p)&#123; int i,connfd,n; char buf[MAXLINE]; rio_t rio; for(i = 0;(i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; 0);i++)&#123; connfd = p-&gt;clientfd[i]; rio = p-&gt;clientrio[i]; if((connfd &gt; 0) &amp;&amp; (FD_ISSET(connfd,&amp;p-&gt;ready_set)))&#123; p-&gt;nready--; if((n = Rio_readlineb(&amp;rio,buf,MAXLINE)) != 0)&#123; byte_cnt += n; printf("Server received %d (%d total) bytes on fd %d\n", n,byte_cnt,connfd); Rio_writen(connfd,buf,n); &#125; else&#123; Close(connfd); FD_CLR(connfd,&amp;p-&gt;read_set); p-&gt;clientfd[i] = -1; &#125; &#125; &#125;&#125; 上述函数回送来自每个准备好的已连接描述符的一个文本行，还维护了一个从所有客户端接受全部字节的累计值 上面说到该服务器是事件驱动的，也就是状态机，对应的，select函数检测到输入事件，add_client创建新的逻辑流（状态机），check_clients回送输入行，执行状态转移，并在完成文本行发送后，删除该状态机 现代高性能服务器（如Node.js、Nginx）使用的都是基于I/O多路复用的事件驱动的编程方式，虽然有其缺点，但是相比于进程和线程，它有明显的性能优势，因为不需要进程上下文切换来调度新的流 使用事件驱动设计的一个好处在于比基于进程设计给了程序员更多的对程序行为的控制，另一个好处在于只运行单一进程的上下文中，每个逻辑流都能访问该进程的全部地址空间，这就可以使用GDB来调试并发服务器。缺点则是编码复杂和不能充分使用多核处理器 参见APUE的第十四章 高级I/O 基于线程是上述两种方法的混合，线程就是运行在进程上下文中的逻辑流。线程上下文的切换比进程切换快很多，其次线程不按照进程一样有严格的父子层次，和一个进程有关的线程组成一个线程池，线程池中的线程可以杀死他的任何对等线程，或者等待他的任意线程终止 Posix线程（Pthreads）是在C语言中处理线程的一个标准接口，定义了约60个函数，运行程序创建、杀死和回收线程，与对等线程安全的共享数据，还可以通知对等线系统状态的变化。下面是最简单的线程程序 1234567891011121314151617#include "csapp.h"void *thread(void *vargp);int main()&#123; pthread_t tid; Pthread_create(&amp;tid,NULL,thread,NULL); Pthread_join(tid,NULL); exit(0);&#125;void *thread(void *vargp)&#123; printf("Hello world!\n"); return NULL;&#125; 创建线程：pthread_create(pthread_t *tid,pthread_attr_t *attr,func *f,void *arg)，arg是输入变量，f是线程例程，attr可以修改新创建的线程的默认属性 终止线程有多种方式 顶层线程例程返回，线程隐式终止 pthread_exit(void *thread_return)：显式终止，主线程调用该函数，他会等待所有其他对等线程终止，然后在终止主线程和整个进程 对等线程调用exit函数，该函数终止进程以及所有与进程相关的线程 pthread_cancel(pthread_t tid)：对等线程调用该函数，终止线程ID为tid的线程 回收资源：pthread_join(pthread_t tid,void **thread_return)，该函数会阻塞，直到线程tid终止，将线程例程返回的通用指针赋值给thread_return指向的位置，然后回收已终止线程占用的所有内存资源 分离线程：pthread_detach(pthread_t tid)，一个可结合的线程能够被其他线程回收和杀死，再被其他线程回收之前，它的内存资源是不释放的，一个分离的线程不能被其他线程回收或杀死，内存资源由系统自动释放，该函数分离可结合线程tid。为了防止内存泄漏，线程要么被其他线程显式回收，要么通过调用该函数被分离，由系统来回收。在Web服务器中通常采取这种方式回收线程，因为没有必要显式地等待每个对等线程终止 初始线程：pthread_once(pthread_once_t *once_control,void (*init_routine)(void))，初始化与线程例程相关的状态 基于线程的并发服务器123456789101112131415161718192021222324252627282930313233343536#include "csapp.h"void echo(int connfd);void *thread(void *vargp);int main(int argc,char **argv)&#123; int listenfd,*connfdp; socklen_t clientlen; struct sockaddr_storage clientaddr; pthread_t tid; if(argc != 2)&#123; fprintf(stderr,"usage:%s &lt;port&gt;\n",argv[0]); exit(0); &#125; listenfd = Open_listenfd(atoi(argv[1])); while(1)&#123; clientlen = sizeof(struct sockaddr_storage); connfdp = Malloc(sizeof(int)); *connfdp = Accept(listenfd,(SA *) &amp;clientaddr,&amp;clientlen); Pthread_create(&amp;tid,NULL,thread,connfdp); &#125;&#125;void *thread(void *vargp)&#123; int connfd = *((int*)vargp); Pthread_detach(pthread_self()); Free(vargp); echo(connfd); Close(connfd); return NULL;&#125; 在调用Pthread_create，通过传递一个指向已连接描述符的指针*connfdp，将描述符传递给对等线程 但是这样做却会引入竞争，试想一下，如果对象线程中的赋值在下一个Accept之前完成，那局部变量将得到正确的值，但是在之后完成，就会得到下一个连接的描述符，这样两个线程就会使用同一个描述符，为此，我们将accept返回的每个已连接描述符分配到它自己的动态分配的内存块？？？ 另一个要注意的地方就是分离线程，避免内存泄漏，还要释放主线程分配的内存块 参见APUE的第十一章 线程 多线程的共享变量线程的吸引力就在于多个线程能共享程序变量，但是为了编写正确的多线程程序，就需要对所谓的共享如何工作有清楚地了解 一组并发线程运行在一个进程的上下文中，每个线程都有自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和寄存器值，并共享其余部分，包括只读文本、读写数据、堆、共享库代码和打开文件 线程内存模型参见《程序员的自我修养》 多线程的C程序中变量根据存储类型被映射到虚拟内存 全局变量：虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用 本地自动变量：定义在函数内部但是没有static属性的变量，每个线程的栈包含自己的所有本地自动变量实例 本地静态变量：定义在函数内部且有static属性的变量，和全部变量一样，虚拟内存的读/写区域只包含一个实例 共享变量就是当它的实例被一个以上的线程引用，例如在多线程程序下的全局变量 信号量互斥共享变量十分方便，却引入了同步错误的可能性。一般而言，不能预测OS是否将为线程选择一个正确的顺序 为此引入了叫做信号量（$s$，semaphore）的特殊类型变量，是具有非负整数的全局变量，只能有两种特殊操作处理 $P(s)$：如果$s$是非零的，将其减一，并立即返回，如果为零，就挂起这个线程，直到$s$变为非零， $V(s)$：将$s$加一，如果任何线程阻塞在$P$等待$s$变为非零，就重启这些线程中的某一个且是不可预测的 $P$和$V$操作都是不可分割的，这使得信号量$s$绝不可能变为负值，这种属性称为信号量不变性，$P$和$V$来自荷兰语测试和增加 信号量提供一种方便的方法来确保对共享变量的互斥访问，基本思想就是将每个共享变量和一个信号量联系起来，然后使用$P(s)$和$V(s)$将相应的临界区包围起来 这种信号量又称为二元信号量，因为它的值总是0或1，也常叫做互斥锁，相应的$P$和$V$操作就叫做加锁和解锁 调度共享资源信号量的另一个作用是调度对共享资源的访问，在这种场景中，一个线程用信号量操作来通知另一个线程，程序状态的某个条件已经为真。经典例子就是生产者-消费者和读者-写者问题 生产者-消费者生产者和消费者线程共享一个有$n$个槽的有限缓冲区，生产者线程反复生成新的项目，并插入缓冲区，消费者线程不断从缓冲区取出这些项目 为此，我们要保证对缓冲区的访问是互斥的，还有调度对缓冲区的访问，例如如果缓冲区是满的，就要挂起生产者线程 生产者-消费者模型很普遍，例如生产者编码视频帧，消费者解码并在屏幕上呈现出来，缓冲区的目的就是为了减少视频流的抖动 123456789typedef struct&#123; int *buf; /* buffer array */ int n; /* maximun number of slots */ int front; /* buf[(front+1)%n] is first item */ int rear; /* buf[rear%n] is last item */ sem_t mutex;/* protects accesses to buf */ sem_t slots;/* counts available slots */ sem_t items;/* counts available items */&#125;sbuf_t; 上面定义了sbuf_t类型的缓冲区，项目存放在动态分配的整数数组buf中，front和rear记录数组的第一项和最后一项，三个信号量分别提供对缓冲区、空槽位和已用项目数量的互斥访问 读者-写者该问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象，有些线程只读对象，叫做读者；有些线程只修改对象，叫做写者。写者必须拥有对对象的独占的访问，读者可以和无限个读者共享对象 该模型也很常见，例如航空预定系统中，允许无限个用户查看座位，但是正在预定的写者必须拥有对数据库的独占的访问，在多线程缓存web代理中也是相同的模型，无限个线程从共享页面缓存中取出已有的页面，但向缓存写入新页面的线程必须独占的访问 该线程也有多个变种，分别区别于读者和写者的优先级。如果读者优先，要求不要让读者等待，读者不会因为有一个写者在等待而等待，第二类，则是写者优先，要求一旦一个写者准备好可以写，就会尽可能完成写操作，如果有读者到来，就必须等待，即使写者也是等待的 Java线程用Java Monitor的机制来同步，它是对信号量互斥和调度能力的更高级别的抽象，具体参见第21章 并发 基于预线程化的并发服务器服务器由一个主线程和一组工作者线程构成，主线程不断接受来自客户端的连接请求，并将得到的连接描述符放在一个有限缓冲区，每个工作线程反复从共享缓冲区取出描述符，为客户端服务 编译的时候一直显示重复定义，都要烦死了，最后发现自己好像修改过csapp.h文件，自己加了#include &quot;csapp.c&quot;进去作死，而且应该是和csapp.c文件一起编译链接，笨死了！ 1234567891011121314151617181920212223int main(int argc, char **argv)&#123; int i, listenfd, connfd, port; socklen_t clientlen=sizeof(struct sockaddr_in); struct sockaddr_in clientaddr; pthread_t tid; if (argc != 2) &#123; fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]); exit(0); &#125; port = atoi(argv[1]); sbuf_init(&amp;sbuf, SBUFSIZE); //line:conc:pre:initsbuf listenfd = Open_listenfd(port); for (i = 0; i &lt; NTHREADS; i++) /* Create worker threads */ //line:conc:pre:begincreate Pthread_create(&amp;tid, NULL, thread, NULL); //line:conc:pre:endcreate while (1) &#123; connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen); sbuf_insert(&amp;sbuf, connfd); /* Insert connfd in buffer */ &#125;&#125; 在调用sbuf_init初始化缓冲区之后，创建一组工作线程，然后进入无限循环 123456789101112131415161718192021222324252627static int byte_cnt;static sem_t mutex;static void init_echo_cnt(void)&#123; Sem_init(&amp;mutex,0,1); byte_cnt = 0;&#125;void echo_cnt(int connfd)&#123; int n; char buf[MAXLINE]; rio_t rio; static pthread_once_t once = PTHREAD_ONCE_INIT; Pthread_once(&amp;once,init_echo_cnt); Rio_readinitb(&amp;rio,connfd); while((n = Rio_readlineb(&amp;rio,buf,MAXLINE)) != 0)&#123; P(&amp;mutex); byte_cnt += n; printf("server received %d (%d total) bytes on fd %d\n", n,byte_cnt,connfd); V(&amp;mutex); Rio_writen(connfd,buf,n); &#125;&#125; 真正有趣的是上面这段代码，全局变量byte_cnt记录从所有客户端接受的所有累计字节数，先调用Pthread_once(&amp;once,init_echo_cnt);，要求主线程显式地调用一个初始化函数，byte_cnt作为共享变量，是被$P$和$V$保护着的 并行性在多核处理器中，OS在多个核中并行的调度并发程序，并行程序是运行在多个处理器的并发程序，因此并行程序是并发程序集合的真子集 作为示例，为$0,…,n-1$个数求和，每个线程负责一个区域 最为简单的就是把线程的和放在一个共享全局变量gsum中，用互斥锁保护123456789101112131415void *sum_mutex(void *vargp)&#123; long myid = *((long *)vargp); long start = myid * nelems_per_thread; long end = start + nelems_per_thread; long i; for(i = start;i &lt; end;i++)&#123; P(&amp;mutex); gsum += i; V(&amp;mutex); &#125; return NULL;&#125; 这种方式速度很慢，而且核数越多，性能越差，因为同步操作（$P$和$V$）代价太大，甚至出现了错误，原因是因为要假设整数$n$假设为线程数的倍数 另一种方式就是每个对等线程在一个私有变量计算它的部分和，不和其他线程共享12345678910111213void *sum_array(void *vargp)&#123; long myid = *((long *)vargp); long start = myid * nelems_per_thread; long end = start + nelems_per_thread; long i; for(i = start;i &lt; end;i++)&#123; psum[myid] += i; &#125; return NULL;&#125; 虽然只改动了很小的一部分，但性能的提升是数量级的 写并发程序并不是轻而易举的事情，要避免错误，还要兼顾效率 其他同步从根本上来说是很难的问题，这一节论述在编写并发程序中会遇到的典型问题，如线程安全、可重入性、竞争、死锁等，更详细的同步可参见《Java并发编程实战》 线程安全一个函数是线程安全的，当且仅当被多个并发线程反复地调用时，一直产生正确的答案 下面是几类线程不安全的函数 不保护共享变量的函数。这类函数只要引入$P$和$V$，就能变成线程安全，缺点就是同步操作造成的代价 保持跨越多个调用的状态的函数。？？ 返回指向静态变量的指针的函数。如果并发线程调用这些函数，一个线程使用的结果可能会被另一个线程悄悄覆盖 调用线程不安全函数的函数 可重入当它们被多个线程调用时，不会引用任何共享数据。可重入函数是线程安全函数的子集 如果所有函数参数都是传值传递的（即没有指针），且所有数据引用都是本地自动栈变量，那么该函数就是显式可重入的。如果调用线程小心传递指向非共享数据的指针，那就是隐式可重入的 可重入性即是调用者属性也是被调用者的属性？？？ 大部分Linux函数都是线程安全的，如果要调用线程不安全的函数，可以使用以_r结尾的安全版本，最好的办法就是加锁-复制？？？ 竞争通常发生竞争都是因为程序员假定线程将按照某种特殊的轨迹穿过执行状态空间，但是多线程的程序必须对任何可行的轨迹线都安全 12345678910111213141516171819202122232425#include "csapp.h"#define N 100void *thread(void *vargp);int main()&#123; pthread_t tid[N]; int i; for(i = 0;i &lt; N;i++) Pthread_create(&amp;tid[i],NULL,thread,&amp;i); for(i = 0;i &lt; N;i++) Pthread_join(tid[i],NULL); exit(0);&#125;void *thread(void *vargp)&#123; int myid = *((int *) vargp); printf("hello from thread %d\n",myid); return NULL;&#125; 主线程在创建对等线程的时候，传入了一个指向本地栈变量i的指针，问题就出在线程如果在i++之前就引用了该值，就会获得其他线程的ID 上面是N=4，下面是N=100，每次运行结果都不尽相同 死锁信号量引入了潜在的运行时错误死锁，它指的是一组线程被阻塞了，等待一个永远不会为真的条件。进程图对于理解死锁是无价的工具 死锁是不可避免，且很难复现的，下面的规则能有效避免死锁 互斥锁加锁顺序规则：给定所有互斥操作的一个全序，如果每个线程都以一种顺序获得互斥锁并以相反的顺序释放，那就是无死锁的？？]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十章：系统级I/O]]></title>
    <url>%2F2019%2F01%2F07%2FCSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[《CSAPP》第十章：系统级I/O ANSI C提供标准I/O库，C++提供重载操作符，在Linux系统中使用内核提供的系统级Unix I/O函数来实现较高级别的I/O函数，学习Unix I/O有利于 理解其他系统概念。I/O是系统不可或缺的一部分，它们之间是循环依赖。例如，I/O在进程的创建和执行中扮演关键角色，进程创建又在不同进程间的文件共享中扮演关键角色？？ 除了使用Unix I/O以外别无选择。例如标准I/O库没有提供读取文件元数据的方式，I/O库本身也存在问题，不能用于网络编程 这章的学习将为学习网络编程和并发性奠定坚实的基础 Unix I/OLinux中，所有I/O设备都被模型化为文件，这种方式允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这就使得所有输入输出都以一种统一的方式执行 打开文件：应用程序要求内核打开相应文件，内核就返回一个小的非负整数，叫做描述符。内核记录有关打开这个文件的所有信息，应用程序只需记住这个描述符 标准输入、输出和错误：Shell创建每个进程的时候都会打开三个文件（可查看xv6源码的8507行） 改变文件位置：这是从文件开头起始的字节偏移量，可通过seek显示设置文件的当前位置 读写文件：读写文件就是磁盘和内存的交换 关闭文件：当通知内核关闭程序时，内核就会释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中 文件Linux文件也有不同的类型 普通文件：对内核而言，文本文件和二进制文件没有区别 目录：包含一组链接的文件，其中每个链接都有一个文件名映射到一个文件 套接字：用来与另一个进程进程跨网络通信的文件 打开作为上下文的一部分，每个进程都有一个当前工作目录，来确定在目录层次结构中的当前位置 进程通过调用open函数来打开一个已经存在的文件或创建新文件1int open(char *filename,int flags,mode_t mode); 该函数将filename转换为文件描述符并返回，返回的描述符是进程中未使用的最小描述符。 flags参数指明访问方式，如O_RDONLY O_WRONLY O_RDWR O_CREATE等模式，具体参考书 mode参数指明新文件的访问权限位。作为上下文一部分，每个进程都有一个umask，它通过调用umask函数来设置，此时文件的访问权限为mode &amp; ~umask，例如12345#define DEF_MODE S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IWOTH#define DEF_UMASK S_IWGRP | S_IWOTHumaks(DEF_UMASK);fd = open("foo.txt",O_CREATE | O_WRONLY,DEF_MODE); 上面常见的文件就只有S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IWOTH &amp; ~(S_IWGRP | S_IWOTH)，也就是只有S_IRUSR | S_IWUSR | S_IRGRP属性，也就是文件的拥有者有读写权限，而所在组拥有写权限 读写通过下面两个函数执行输入输出12ssize_t read(int fd,void *buf,size_t n);ssize_t write(int fd,const void *buf,size_t n); read函数从描述符fd的当前位置复制最多n个字节到内存位置buf，返回-1表示错误，返回0表示EOF，否则返回实际传送的字节数量 在x86-64系统中，size_t定义为unsigned long，ssize_t定义为long，因为read函数可能返回负数，必须是有符号数，因为这个原因，该函数能读取的最大字节数减少了一半 有些时候，两个函数传送的字节数量比定义的n值要少，这意味着出错误 遇到EOF 从终端读取文本行：如键盘和显示器，每个read函数读取一个文本行，返回的不足值就是文本行大小 读写网络套接字：内部缓冲约束和网络延迟会引起返回不足值 RIORIO提供了两类不同的函数 无缓冲的输入输出函数：直接在文件和内存之间传送数据，没有应用级缓存，它们对二进制数据读写到网络和从网络读写二进制数据很有用 带缓冲的输入函数：这些函数是线程安全 无缓冲12345678910111213141516171819202122232425/* * rio_readn - robustly read n bytes (unbuffered) *//* $begin rio_readn */ssize_t rio_readn(int fd, void *usrbuf, size_t n)&#123; size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft &gt; 0) &#123; if ((nread = read(fd, bufp, nleft)) &lt; 0) &#123; if (errno == EINTR) /* Interrupted by sig handler return */ nread = 0; /* and call read() again */ else return -1; /* errno set by read() */ &#125; else if (nread == 0) break; /* EOF */ nleft -= nread; bufp += nread; &#125; return (n - nleft); /* return &gt;= 0 */&#125;/* $end rio_readn */ rio_readn从描述符fd的当前位置最多传送n个字节到内存位置usrbuf，可我并没有理解这样做怎么就产生鲁棒性？？ 带缓冲rio_readlineb从一个内部读缓冲区复制一个文本行，当缓冲区变空时，会自动调用read函数重新填满缓冲区，对于既包含文本行也包含二进制文件，则可以使用rio_readnb1234567891011121314/* Persistent state for the robust I/O (Rio) package *//* $begin rio_t */#define RIO_BUFSIZE 8192typedef struct &#123; int rio_fd; /* Descriptor for this internal buf */ int rio_cnt; /* Unread bytes in internal buf */ char *rio_bufptr; /* Next unread byte in internal buf */ char rio_buf[RIO_BUFSIZE]; /* Internal buffer */&#125; rio_t;/* $end rio_t */void rio_readinitb(rio_t *rp, int fd);ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n);ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen); 每打开一个描述符，都会先调用rio_readinitb，将描述符fd和地址rp处的一个类型为rio_t的读缓冲区联系起来 上述函数的核心是rio_read函数，这个函数是最原始Linux read函数的带缓冲版本123456789101112131415161718192021222324252627282930313233343536/* * rio_read - This is a wrapper for the Unix read() function that * transfers min(n, rio_cnt) bytes from an internal buffer to a user * buffer, where n is the number of bytes requested by the user and * rio_cnt is the number of unread bytes in the internal buffer. On * entry, rio_read() refills the internal buffer via a call to * read() if the internal buffer is empty. *//* $begin rio_read */static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)&#123; int cnt; while (rp-&gt;rio_cnt &lt;= 0) &#123; /* Refill if buf is empty */ rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, sizeof(rp-&gt;rio_buf)); if (rp-&gt;rio_cnt &lt; 0) &#123; if (errno != EINTR) /* Interrupted by sig handler return */ return -1; &#125; else if (rp-&gt;rio_cnt == 0) /* EOF */ return 0; else rp-&gt;rio_bufptr = rp-&gt;rio_buf; /* Reset buffer ptr */ &#125; /* Copy min(n, rp-&gt;rio_cnt) bytes from internal buf to user buf */ cnt = n; if (rp-&gt;rio_cnt &lt; n) cnt = rp-&gt;rio_cnt; memcpy(usrbuf, rp-&gt;rio_bufptr, cnt); rp-&gt;rio_bufptr += cnt; rp-&gt;rio_cnt -= cnt; return cnt;&#125;/* $end rio_read */ 当缓冲区为空时，调用read函数填满它，如果非空，则从读缓冲区复制min(n, rp-&gt;rio_cnt)字节到用户缓冲区 共享文件内核用三个相关的数据结构来表示打开的文件 描述符表：每个进程都有独立的描述符表，该表的索引就是打开的文件描述符，表项则是指向文件表 文件表：所有进程共享这张表，这张表的表项包括当前文件的位置、引用计数、指向v-node表中对应表项的指针 v-node 表：每个表项包含stat结构的大多数信息（即文件元数据） 多个描述符可以通过不同的文件表项引用同一个文件，这样每个描述符都有自己的文件位置，可以从不同位置获取数据 子进程有一个父进程描述符的副本，因此共享相同的打开文件集合，在内核删除相应文件表表项之前，父子进程必须都关闭各自的描述符 I/O重定向12/* Duplicate FD to FD2, closing FD2 and making it open on the same file. */int dup2 (int oldfd, int newfd); 该函数复制描述符表项oldfd到描述符表项newfd，具体使用查看MIT 6.828 Assignment:Shell 标准I/OC语言定义了一组高级输入输出函数，称为标准I/O库，例如fopen fclose fread fwrite printf scanf 标准I/O库将一个打开文件模型化为流。对于程序员来说，一个流就是指向FILE类型的结构的指针，每个ANSI C程序开始时都有三个打开流stdin stdout stderr 类型为FILE的流是对文件描述符和流缓冲区的抽象，流缓冲区的目的就是使开销较高的Linux I/O系统调用的数量尽可能少 总结 Unix I/O模型是在操作系统内核中实现的，标准I/O和RIO则是在基础上实现的包装函数。大多数情况下，标准I/O是更优的选择，但是因为标准I/O和网络文件的不兼容问题，因此Unix I/O比其更适合网络应用程序 参考 MIT 6.828 book_xv6:Chapter 0 APUE：第五章 标准I/O库]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《2018年总结》]]></title>
    <url>%2F2019%2F01%2F02%2F%E3%80%8A2018%E5%B9%B4%E6%80%BB%E7%BB%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[回顾2018，展望2019 如果以成绩来评价2018，那是失败的一年，但如果从自身发展来说，2018是一个转折点。为什么这么说呢？自己沉寂一年的时间去寻找和真正优秀的人之间的差距到底在哪里？我觉得除了努力之外，最重要的就是书看的太少，思考的不够，思考的不深，我不想自己成为查理口中的铁锤人，所以我选择跳出计算机专业给自己围起来的局限，去看看更精彩的不同的领域，去拓展了自己的知识面，去浅尝了经济、物理、心理、教育、哲学、历史等不同领域的知识，当然专业知识也没有放下，但大多都是在打基础。如果从上述角度来评价2018，那是大丰收的一年 仔细回想了一下2018年做过的事情，唯一两件值的说道的就是博客和澳洲之行。一年的时间看了二三十本书，写了一百多篇博文，经历了难以忘记的一个月Adelaide之行。除此之外，好像就没有什么量化的指标来衡量我2018年取得的成就，但我确实成长了好多，对自我的认知，对现实、社会的认知不再和小孩子一样幼稚了。 回想了好久，我说不上来这些看起来有些空虚的话语对我到底有什么用，它能帮助自己在生活中更好地做决策吗？它能使我离成功更近一点吗？ 对于上述问题，我的一个解释是：我是个说得多、看得多，但做得少的人。喜欢这些虚无的东西，这样就可以逃避现实，把自己一头扎进泥土里。自己立下的Flag也是形同虚设，没实现也就没实现，对于这些问题自己很不敏感，从来不会去想这个Flag没有实现的原因是什么，就很随意的让这个问题飘过。现在的自己不仅是没有发现问题的敏感度，也没有解决问题的机制。就像个无头苍蝇一样，走到哪里算哪里。对于这个遗留已久的问题，要想法设法的解决。 上面提出的那个问题，今天终于想通了：知识的学习是具有滞后性的，不要期望今天学的，明天就能用上，人的进步是一个缓慢的过程，知识的滞后性和积累作用，会让这种缓慢作用在某一天达到质的飞跃。 努力学习的一个目的不就是为了赚一个时间差，比别人更早的看出机会，更早的抓住机会吗？我通过看书去加速我认识这个社会、不同人的特点，而不是通过实际经验来阅人，来阅社会，这就是书本的价值所在，让我更早、更宽的认识世界，比别人更早的认识这些，就比别人有更多的机会 最近几天经历的事情，越发让我体会到独立的作用，也让我体会到了危机感。从出去找兼职毫无门路，到想出去租房子又不想给父母添压力，我这才体会到什么是心酸。所以我才给自己下个学期立下每个月赚1000元的目标，要让自己勇敢走出舒适区。父母每个月给自己打生活费，却从来没有想过有一天这区区生活费断了怎么办，自己不应该倚着父母却不自知，是时候开始狩猎了 我发现自己是个喜欢另辟蹊径的人。为什么大家都喜欢“抢”，喜欢去走“独木桥”呢？世界难道不是“条条大路通罗马”吗？ 2019目标： 网易实习：立这个目标是为了以后找工作或者考研做打算 每月收入1000元：独立！强迫自己去理清自己的财富 读20本书：不断充电，不断拓宽自己 学会平衡生活与学习 这篇文章，我写了好久，一篇年度总结有这么难吗？]]></content>
      <tags>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《乡土中国》]]></title>
    <url>%2F2019%2F01%2F02%2F%E3%80%8A%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%E3%80%8B%2F</url>
    <content type="text"><![CDATA[解读农耕文化下中国社会文化形态的书，处处充盈真知灼见。一种沿袭已久的社会文化形态，有相对的稳定性，不会轻易随着政权和制度的变化而消失，对今天的读者，仍有很大启示意义]]></content>
      <tags>
        <tag>社会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《原则》]]></title>
    <url>%2F2019%2F01%2F02%2F%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B%2F</url>
    <content type="text"><![CDATA[最好弄明白其他时间、其他地点、其他人身上的事，因为如果你不这么做，就不会知道这事情会不会发生在自己身上，而且一旦发生，将不会知道如何应对 你最好总是假设自己没有看到全部 时机就是一切 我努力回想自己过去做的决定，哪些是对，哪些不对。可我想了好久发现，我对过去所做的决定没有一点评判标准，过去在自己脑海里就是一根直线。即意识不到这件是成功的，也意识不到这件事或是失败的，思维中从来都没有建立一个思考反思的循环 当我意识到这一点的时候，我兴奋了好久，我隐约觉得这会是我成长道路的一个转折点。只有自己意识到，应该从每件事的背后获得经验教训，或者说原则，人才能几何成长 觉得自己情商好低，低到连事情的失败都发现不了。就像没有感情的冷血动物，心情就像直线一样没有波动。比如说这次服务外包的失败，自己就像过眼云烟般让他过去，也没有去分析总结这次为什么失败，这样一想，感觉自己毫无责任感，做不成一件事情]]></content>
      <tags>
        <tag>成长</tag>
        <tag>投资</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《MySQL必知必会》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%2F</url>
    <content type="text"><![CDATA[MySQL入门 基本操作MySQL的配置文件在/etc/mysql/mysql.conf/文件夹下面，数据存放在var/lib/mysql下面 DDL USE database_name：选择数据库 SHOW DATABASES：显示所有数据库 SHOW TABLES：显示某一数据库中所有表，使用之前要先选择特定数据库 CREATE DATABASE database_name：创建数据库 CREATE TABLE table_name(col_name_1 type,col_name_2 type,...)：创建表create table `stu_info` (`id` int, `name` varchar(40)); CREATE UNIQUE INDEX index_name ON table_name(col_name)：创建唯一索引（索引只是为了加速查询） CREATE INDEX index_name ON table_name(col_name)：创建简单索引 DROP TABLE：删除表 DROP INDEX：删除索引 数据类型数值MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION) 日期/时间表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值 字符串字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET 通配符LIKE操作符指示MySQL后跟的搜索模式利用通配符而不是直接相等匹配 最常见的通配符是%，表示任何字符出现任意次数123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE &apos;h%eda&apos;; 通配符可以位于搜索模式的任意位置，且搜索可以是区分大小写 另一个通配符是_，与%用处一样，但是只匹配单个字符，不能多也不能少 通配符虽然好用，但是不能过度使用，因为相比其他搜索花费时间更长 插入数据1234mysql&gt; insert into stu_info -&gt; values(17052231, -&gt; &apos;robert&apos;);Query OK, 1 row affected (0.16 sec) 存储过程存储过程就是为以后的使用而保存的一条或多条MySQL语句的集合 使用存储过程的好处就是简单、安全、高性能；但是编写存储过程比写SQL复杂，不一定含有创建存储过程的权限 CALL processname(@parm1,@parm2);：执行存储过程CREATE PROCEDURE pro_name();：创建存储过程DROP PROCEDURE pro_name;：删除存储过程例子 12345678910CREATE PROCEDURE ordertotal( IN onumber INT, OUT ototal DECIMAL(8,2))BEGIN SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num=onumber INTO ototal;END; MySQL支持IN（传递给存储过程）、OUT（从存储过程中传出）和INOUT（对存储过程传入传出）类型的参数 调用该存储过程需要输入变量，MySQL中变量都是以@开始，CALL ordertotal(20005,@total);，改调用语句不产生任何数据，要显示输出变量可以SELECT @total; 只有包含业务规则和智能处理时，才能发挥存储过程的真正威力 SHOW CREATE PROCEDURE pro_name;：显示创建存储过程的语句SHOW PROCEDURE STATUS pro_name：显示何时、由谁创建等详细信息 视图视图是虚拟的表，只包含使用时动态检索数据的查询，不包含实际数据。就像正视图是物体从正面看的样子，视图就是原始表从某个角度看到的样子，而定义这个角度就是查询 有了视图，客户就不用再操心访问的数据是基本数据还是派生数据，这就体现了这种封装方式的方便 使用视图可以 重用SQL语句 在编写查询后，可以方便重用而不必知道他的基础查询细节 使用表的组成部分而不是整个表 保护数据，可以授予用户表的特定部分的访问权限而不是整个表的访问权限 更改数据格式或表示，视图可以返回与底层表不同的的格式 在创建和使用视图时也有一些常见规则和限制 视图唯一命名 视图数目没有限制 创建视图需要访问权限 视图可以嵌套 视图不能索引，没有关联的触发器或默认值 CREATE VIEW：创建视图SHOW CREATE VIEW viewname：查看创建视图的语句DROP VIEW viewname：删除视图CREATE OR REPLACE VIEW：更新视图 下面的例子就创建了vendorlocations视图，通过该视图可以重新格式化检索出的数据12345678CREATE VIEW vendorlocations ASSELECT Concat(PTrim(vend_name),&apos;(&apos;,PTrim(vend_country),&apos;)&apos;) AS vend_titleFROM vendorsORDER BY vend_name;SELECT * FROM vendorlocations; 联结表联结是SQL中最强大的特性 关系表的设计就是要保证把信息分解成多个表，一类数据一个表，各表通过某些常用的值（即关系）相关联 外键为某个表的一列，它包含另一个表的主键值，定义了两个表之间的关系 通过联结，单条SELECT语句可以检索出存储在多个表中的数据。联结不是物理实体，而是MySQL根据需要建立，它存在于查询的执行当中 创建联结：vendors,products两个表通过WHERE子句正确联结，应该保证所有联结都有WHERE子句，下面距离的联结也成为等值联结或者内部联结，可以联结的表的数量没有限制，但是联结的表越多，查询性能下降越厉害1234SELECT vend_name,prod_name,prod_priceFROM vendors,productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name,prod_name; 上面的例子也可以这么写123SELECT vend_name,prod_name,prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id 游标游标是一个存储在MySQL服务器上的数据库查询，是该语句检索出来的结果集，只能用于存储过程 使用游标需要经过几个步骤：创建游标，打开游标，检索、关闭游标 创建游标：DECLARE，如下123456CREATE PROCEDURE processorders()BEGIN DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 打开游标：OPEN CURSOR，在处理OPEN语句时执行查询，检索出来的结果集用于浏览与滚动 关闭游标：CLOSE CURSOR，释放游标使用的所有内存与资源 使用游标数据：FETCH，访问结果集的每一行，指定检索什么数据，检索出来的数据存储在什么地方，还将自动移动到下一行 在下面的例子中，使用FETCH不断检索order_num并写入到新表中，反复执行直到done为真，DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;02000&#39; SET done=1;这条语句即是设置done为真，它指出状态码02000出现时（即没有找到）设置done为真1234567891011121314151617181920212223242526272829CREATE PROCEDURE processorders()BEGIN DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8,2); DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1; CREATE TABLE IF NOT EXISTS ordertotals (order_num INT,total DECIMAL(8,2)); OPEN ordernumbers; REPEAT FETCH ordernumbers INTO o; CALL ordertotal(o,1,t); INSERT INTO ordertotals(order_num,total) VALUES(o,t); UNTIL done END REPEAT; CLOSE ordernumbers;END; 触发器 在学生表中拥有字段学生姓名，字段学生总数，每当添加一条学生信息时，学生的总数就必须同时更改 在学生表中还会有学生姓名的缩写，学生住址等字段，添加学生信息时，往往需要检查电话、邮箱等格式是否正确 上面的例子使用触发器完成时具有这样的特点，需要在表发生改变时，自动进行一些处理。MySQL在触发DELETE INSERT UPDATE语句时就会自动执行所设置的操作，其他SQL语句则不会激活触发器，是一种特殊的存储过程 创建触发器需要4条信息 惟一的触发器名 触发器关联的表 触发器应该相应的活动（DELETE INSERT UPDATE） 触发器何时执行（处理之前还是之后） 123456789101112CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_bodytrigger_name：触发器的名称，不能与已经存在的触发器重复；trigger_time：&#123; BEFORE | AFTER &#125;，表示在事件之前或之后触发；trigger_event:：&#123; INSERT |UPDATE | DELETE &#125;，触发该触发器的具体事件；tbl_name：该触发器作用在tbl_name上；trigger_body：Boby中使用BEGIN、END可以执行多条SQL语句 例子12345CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT &apos;Product added&apos;; 每个表每个事件只允许一个触发器，每个表最多支持6个触发器 删除触发器：DROP TRIGGER newproduct INSERT触发器：可以引用一个NEW虚拟表，访问被插入的行；而且在BEFORE INSERT触发器中，NEW表中的值也可以更新；对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在执行之后包含新的自动生成值，例子1234567CREATE TRIGGER neworder AFTER INSERT ON orders FOR EACH ROW SELECT NEW.order_num;order_num由MySQL自动生成，当插入一个新订单时，触发器从NEW.order_num取得这个值并返回它 DELETE触发器：可以引用OLD虚拟表，访问被删除的行；OLD的值全部都是只读的，不能更新；例子12345678CREATE TRIGGER deleteorder BEFORE DELETE ON orders FOR EACH ROW BEGIN INSERT INTO archive_orders(order_num,order_data,order_id) VALUES(OLD.order_num,OLD.order_data,OLD.order_id); END; UPDATE触发器：既可以引用OLD，也可以引用NEW虚拟表；在BEFORE UPDATE触发器中，NEW的值可以被更新；OLD的值不能更新 触发器能保证数据的一致性（大小写、格式等）；可以创建审计追踪，通过触发器把更改记录到另一个表 事务在单一操作中更新跨越多张表的数个行，该操作要么成功，要么失败，是数据库运行中的逻辑工作单位，其本质就是一系列操作，但操作的总和要满足ACID属性 事务：一组SQL语句 回退：撤销指定SQL语句的过程 提交：将为存储的SQL语句结果写入数据库表 保留点：事务处理设置的临时占位符，对其发布回退 START TRANSACTION：标识事务的开始，事务处理只管理INSERT、UPDATE和DELETE命令，对于DREATE、DROP操作，即使执行回退，也不会撤销 ROLLBACK：用于回退，只能在一个事务处理内使用，即在START TRANSACTION命令之后，执行ROLLBACK之后，事务自动关闭，更改隐含提交 COMMIT：一般的MySQL语句是隐含提交的，当在事务处理模块时，提交必须显式提交，使用COMMIT，且只在不出错的时候写出更改 SAVEPOINT：为了回退部分事务处理，可以在事务处理合适的位置放置占位符，回退时只需回退到某个占位符，这些占位符就称为保留点，保留点在事务处理完成后会自动释放，也可以显式释放RELEASE SAVEPOINT，如 1234567START TRANSACTION...SAVEPOINT delete1;...ROLLBACK TO delete1;...COMMIT SET autocommit=0;：默认是自动提交所有更改，设置该标志可以取消自动提交更改 如下例子12345678910111213141516171819202122232425mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into stu_info values ( 17052230, &apos;sam&apos;);Query OK, 1 row affected (0.09 sec)mysql&gt; select * from stu_info;+----------+--------+| id | name |+----------+--------+| 17052231 | robert || 17052230 | sam |+----------+--------+2 rows in set (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.03 sec)mysql&gt; select * from stu_info;+----------+--------+| id | name |+----------+--------+| 17052231 | robert |+----------+--------+1 row in set (0.00 sec) 维护有多种方式可以实现数据备份 使用命令行工具mysqldump转储所有内容到某个外部文件 使用命令行工具mysqlhotcopy从一个数据库复制所有数据 BACKUP TABLE file_name或者SELECT INTO OUTFILE file_nameSQL语句来转储所有数据到某个外部文件 MySQL提供一些语句来保证数据库正确运行 ANALYZE TABLE：检查表键是否正确 CHECK TABLE：针对许多问题对表进行检查 多数MySQL服务器是作为系统进程或服务自动启动的，在派出系统启动问题时，要学会使用命令行工具，mysqld用于启动执行 查看日志也很重要 错误日志：包含启动和关闭问题以及关键错误的细节，位于data目录下，名称为hostname.err，日志名可以通过--log-error命令行选项修改 查询日志：记录所有MySQL活动，名称为hostname.log，可通过--log修改 二进制日志：记录更新过数据或者可能更新过数据的所有语句 缓慢查询日志：记录执行缓慢的任何查询，在确定优化时很有用 外键定义语法1234[CONSTRAINT symbol] FOREIGN KEY [id] (index_col_name, ...)REFERENCES tbl_name (index_col_name, ...)[ON DELETE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;][ON UPDATE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;] 被引用的表称为父表，引用的表称为子表。ON DELETE和ON UPDATA表示对父表进行DELETE和UPDATE操作时，对子表的操作选择 常用命令SHOW PROCESSLIST;：展示MySQL线程列表和状态]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《为什么学生不喜欢上学》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E7%94%9F%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%B8%8A%E5%AD%A6%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《上帝投骰子吗》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E4%B8%8A%E5%B8%9D%E6%8A%95%E9%AA%B0%E5%AD%90%E5%90%97%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《大问题》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E5%A4%A7%E9%97%AE%E9%A2%98%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《局外人》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《从一到无穷大》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E4%BB%8E%E4%B8%80%E5%88%B0%E6%97%A0%E7%A9%B7%E5%A4%A7%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《寻路中国》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E5%AF%BB%E8%B7%AF%E4%B8%AD%E5%9B%BD%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《万历十五年》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《重构：改善既有代码的设计》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8A%E9%87%8D%E6%9E%84%EF%BC%9A%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[《Spring揭秘》]]></title>
    <url>%2F2018%2F12%2F29%2F%E3%80%8ASpring%E6%8F%AD%E7%A7%98%E3%80%8B%2F</url>
    <content type="text"><![CDATA[这本书帮助了解如何使用spring框架外，还展现了spring框架中展现的开发理念和方法学，穿插了spring实现中体现的设计模式和思想 Spring是03年兴起的一个轻量级Java开发框架，目的是为了简化Java EE的企业级应用开发，倡导一切从实际出发，倡导基于POJO（Plain Old Java Object）的轻量级开发理念 上图是Spring总体框架，抓住了这副骨架，也就抓住了Spring框架的学习主线 Core：这是整个框架的核心，用于帮助我们以依赖注入的方式管理对象之间的依赖关系 AOP：Aspect Oriented Programming面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 DAO：事务管理抽象 ORM：提供了数据访问的形式统一的集成支持 JEE服务集成：提供了针对这些Java EE服务的集成服务，避免了Java EE的繁琐难用 Web：Spring框架提供了一套自己的Web MVC框架，并且不排斥其他Web框架，如Struts Spring经过多年的发展，已经形成了一个巨大的家族，包括spring boot、spring security，但要向上爬，就要实实在在了解spring框架这一根基 《Spring-IoC》 《Spring-AOP》 《Spring-数据访问》 《Spring-事务管理》 《Spring MVC》]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层]]></title>
    <url>%2F2018%2F12%2F28%2F%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[Web、YouTube、QQ，网络应用无处不在，应用层协议也就无处不在 应用程序的体系结构 进程通信 Web和HTTP 电子邮件 DNS 应用程序的体系结构网络核心设备（路由器、分组交换器）在较底层协议上运作，特别是网络层协议一下，而应用层协议则最接近于我们编写的软件，对于软件开发者来说，网络体系都是固定五层模型，而应用程序体系结构则由应用程序开发者来设计实现，主要有以下两种： 客户-服务器体系结构：最常见的应用有web、Telnet和电子邮件，在该结构中，有一个总是开机、处于核心地位的服务器，来接受其他客户主机的请求，该服务器具有一个IP地址，并且该IP地址是公共的、众所周知的 P2P体系结构：常见应用有迅雷、BitTorrent，减少了对于中心服务器的依赖，主机和主机上的应用直接通信，P2P最显著的特点就是自扩展性，每个对等方的加入即能获取其他对等方的资源，也能为其提供服务能力 进程通信计网中的进程通信不同于操作系统中的进程通信，计网中的进程通信是在不同的主机进程上的通信，两个进程通过计网交换报文（message）来相互通信。在单一主机上，应用进程和下面的网络层通过Socket（套接字）的软件接口来和其他主机进程通信，Socket是应用层和运输层之间的接口 开发者对于控制应用层的一切，但对于控制层的仅限于：选择运输层协议和设定少数几个参数（最大缓存等）。为了指定和特定主机的特定进程通信，就需要两个标志信息：主机地址（IP）和主机接受进程标识符（端口） 应用层协议定义了应用程序进程如何通过Socket相互传递message： 交换的报文类型（请求/相应） message字段定义和含义 进程相应规则 位于公共域的应用层协议（如HTTP），只要相应的应用遵从协议规则，就能和同样遵从该协议的其他主机的应用‘ Web和HTTPWeb的应用层协议为HyperText Transfer Protocol（HTTP，超文本传输协议），Web浏览器（Chrome、IE、Firefox）就对应了体系结构中的客户，Web服务器就对应了体系中的服务器（Apache Tomcat）。HTTP是一个无状态协议，即服务器并不会记住用户行为（连鱼七秒钟的记忆都没有） 通过一个单独的TCP连接发送（用完就毁）的HTTP称为非持续连接的HTTP，而使用同一条TCP的则称为持续连接的HTTP HTTP请求报文 有以下字段 方法：GET、POST、HEAD、PUT、DELETE URL：请求对象的标识 HTTP VERSION：浏览器实现的HTTP版本 Host：请求对象所在的主机 Connection：使用的是持续还是非持续HTTP连接 User-agent：指明浏览器类型 Accept-language：对象的语法版本 Entity Body：使用GET方法时，实体为空，只在使用POST方法时才使用实体（如用户在表单字段中的输入值），当然在GET方法也可以加入表单字段，如“129.204.105.84:8080/user/?json”，即作为URL的参数 HEAD方法和GET类似，但服务器不返回请求对象；PUT则把对象上传到服务器指定目录；DELETE允许用户删除Web服务器的对象 HTTP响应报文 200 OK：请求成功，信息在返回的响应报文中 301 Moved Permanently：请求对象永久转移，新的URL在响应报文的Location 400 Bad Request：请求不能被服务器理解 404 Not Found：请求的文档不在服务器上 505 HTTP Version Not Supported：不支持HTTP协议版本 CookieCookie的运行流程 Cookie通过在请求报文的首部行加入Cookie，即在无状态的HTTP之上建立起了一个用户会话层，服务器就能根据Cookie来返回特定的内容 Web缓存当浏览器被配置，使得对于某个对象的请求定向到Web Cache（Proxy Server），当缓存器没有该对象时，才会和初始服务器建立TCP，并发送HTTP请求Web Cache好处 可以大大的减少对客户请求的响应时间 减少一个机构的接入链路到因特网的通信量 引入Web Cache的同时也会引入一个问题：怎么保证Proxy Sever存储的对象都是最新的？答案就是HTTP中的条件GET方法，条件GET首要意味着HTTP请求使用的是GET方法，其次要在报文中的首部行中包含一个“If-Modified-Since”字段 当用户第一次请求某一个对象时，初始服务器的响应报文中会包含“Last-Modified”字段，代理服务器会将对象和该字段的值保存在本地，当用再一次请求该对象时，代理服务器就会发送一个条件请求报文，并把“Last-Modified”的值作为“If-Modified-Since”的值，初始服务器只在对象在该值之后被修改才会发送对象作为相应，否则只会有一个状态码304 Not Modified，即申明该对象为最新的，可以直接转发给用户 电子邮件email主要分成三部分： user agent（用户代理）：如outlook、QQ mail，允许用户阅读、转发、回复、保存、撰写报文 Simple Mail Transfer Protocol（SMTP）：简单邮件传输协议，使用TCP作为可靠数据传输服务 mail server（邮件服务器）：运行SMTP协议 一封邮件的旅程：从用户代理Alice’s agent出发，通过SMTP协议，邮件可以从代理到达用户服务器，也可以从用户服务器到达接收方服务器，这里就遇到了一个问题：接收方代理不一定一直都开机，也就是说邮件不能一步就到接收方代理，这就需要一种邮件访问协议，使得代理可以去访问服务器上的邮件，并做出修改操作。也就是说在第六步需要不同的协议，而不是SMTP。常见的邮件访问协议有POP3（Post Office Protocol-Version3）、IMAP（Internet Mail Access Protocol）和HTTP SMTPSMTP和HTTP的区别 HTTP是Pull protocol，用户使用HTTP从装载信息的server拉取信息，TCP是由想接受文件的端发起的 SMTP是Push protocol，TCP是由发送该文件的端发起的 SMTP要求报文使用7比特ASCII码格式？？ HTTP把每个对象分散封装到HTTP响应报文中，SMTP则把所有对象放在一个报文中 POP3是一个极为简单的邮件访问协议，当用户代理打开和邮件服务器端口110的一个TCP连接时，POP3就开始工作，并有三个阶段：Authorization（特许）、事务处理和更新。 特许：用户代理明文发送用户名和口令到服务器鉴别用户 事务处理：用户代理取回报文，并对报文做标记（如删除标记、取消删除标记等等），用户代理可是使用list、retr、dele和quit四条命令。有“下载并删除”和“下载并保留”两种方式，第一种方式类似于永久删除，即一个PC客户端选择下载并删除，则将在邮件服务器删除该邮件，其他手机端等将无法下载该邮件 更新：当用户结束POP3对话（quit），服务器就删除那些标记为删除的报文 IMAP为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令，还提供了在远程文件夹查询邮件的命令，按指定条件去查询匹配的邮件IMAP还具有允许用户代理获取报文组件的命令，例如只读取报文首部等 HTTP越来越多的用户使用浏览器收发电子邮件，这时候用户代理就是浏览器，于是用户代理和服务器之间的通信就通过HTTP进行 DNS一种能将主机名转换到IP地址的目录服务，即DNS（Domain Name System，域名系统） DNS是一个分层的DNS服务器实现的分布式数据库，也是一个主机能够查询分布式数据库的应用层协议,DNS协议运行在UDP之上，使用53端口 DNS协议不同于其他应用层协议，它不和用户直接打交道，而是向其他应用层协议提供核心功能，可以说它是HTTP、SMTP等协议的基石，当HTTP要发送一个到“baidu.com”的报文，他首先要通过DNS去查询“baidu.com”对应的IP地址，当接收到DNS返回的报文，才想改IP地址主机发送连接请求，因此DNS为网络应用带来了时延 DNS还提供负载分配的功能。同一个应用可能需要多台服务器去提供相应的服务，这意味着同一个主机别名对应着多个IP地址，当用户发出一个DNS请求时，DNS服务器就返回IP地址集合，并在每次回答时循环这个地址集合，用户通常用排在前面的IP地址，也就达到了负载分配的效果 DNS服务器以层次方式组织，有三种类型服务器：根、顶级域和权威DNS服务器。DNS对服务器的查询有递归查询和迭代查询两种。DNS采取缓存的机制改善时延性能并减少在因特网上到处传输的DNS报文数量]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分布]]></title>
    <url>%2F2018%2F12%2F27%2FJVM%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[把内存管理交给虚拟机，但不可依赖于虚拟机的内存管理机制，这就是学习虚拟机的原因之一 内存划分 对象创建 对象内存布局 对象访问定位 Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，如下图，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁 程序计数器（PC）：和计组中的概念一样，都是存放程序，或者说是进程要执行的下一条字节指令，每个线程都有自己私有的程序计数器 栈：描述方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧，用于存放局部变量表、操作数帧、动态链接、方法出口等信息，方法的开始结束对应于栈帧的入栈出栈 本地方法栈：和栈类似，不过对应的是native方法，即Java调用非Java代码的接口 堆：线程共享，所有对象和数组都要在堆上分配内存，堆是垃圾收集器作用的区域，因此成为GC堆 方法区：线程共享，存储已被虚拟机加载的类信息、常量、静态常量、JIT编译后的代码数据 运行时常量池：存放编译期产生的各种字面量和符号引用，在运行期间也能将常量放入池中 直接内存：可以使用native函数库直接在堆外分配内存，然后通过堆中的DirectByteBuffer对象引用这块内存 对象的内存布局分为对象头、实例数据和对齐填充三部分 对象头：运行时数据指的就是GC分代年龄、HashCode、锁状态标志等数据，类型指针即对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例 实例数据：存储真正的有效信息，即程序代码中定义的各种类型的字段内容 对齐填充：自动内存管理系统要求对象的大小必须是8字节的整数倍，对象头固定是8字节的1倍或2倍，所有当实例数据部分没有对齐是，就需要对齐填充 堆上的对象访问分为两种 句柄访问：在堆划分出一块句柄池，reference存储的就是对象的句柄地址，而句柄则保存对象实际的真实地址，这种方式的好处就是reference保存的是稳定的句柄地址，对象被移动时，只改变句柄中对应实例的数据指针 直接指针：reference直接保存对象的实际地址，好处就是速度快]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络》]]></title>
    <url>%2F2018%2F12%2F26%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[点这里呀！ 无知的我在没有学习计网前，以为网络就是一根线、一台电脑和一台路由器。学了之后被其层次结构和魅力所吸引 首先必须明确，相对于整个计算机网络来说，我们还都处于网络边缘，我们作为客户，通过ISP（Internet Service Provider，如中国电信，校园网）提供的网络服务与网络相连，低层的ISP（校园网）再和高层的ISP连接，低层和高层之间独立管理，运行着相同的网络协议。处在第一层ISP的提供商大约有十几个，如AT&amp;T、NTT，其他区域ISP都要想连接的上层ISP支付费用，当然也有像Google这样的内容提供商，创建自己的网络，绕过了第一层ISP和区域ISP，尽可能和底层ISP或端用户相连 说起计网不得不提的就是协议，人们只有对协议的作用取得一致认识，才能创造协同工作的计算机网络，因此由Internet Engineering Task Force（IETF，因特网工程任务组）制定了Request For Comment（RFC，请求评论），以此来定义TCP、IP、HTTP等网络协议，当然对大量的协议也要进行分层，也要对实现这些协议的软硬件进行分层，最出名的当然是下图的五层因特网协议栈，除此之外还有七层ISO OSI参考模型的协议栈从上图体现了一个计网中最重要的一个概念：封装，应用产生的信息从应用层开始被不断封装，最后通过物理链路进行传输，到达接收端有一层层往回进行拆分 对计网有了大局了解后，我们就要进入不同协议栈中不同协议的学习，其中最重要的协议就是TCP/IP协议，我们会跟随书中自顶向下的方法讲解每一层协议，并通过小实验进行巩固 应用层 运输层 网络层 链路层]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门]]></title>
    <url>%2F2018%2F12%2F26%2FJVM%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[像个小孩玩泥巴一样，其乐无穷 Java技术体系 JVM历史 Java何去何从 下面是自己目前接触到的粗略的Java体系结构，常说的安装JDK（Java Development Kit），说的就是Java程序设计语言、Java 虚拟机和Java API类库 Java虚拟机其实是千差万别的物理机上的一层抽象，屏蔽了不同物理机上的不同机器组成和操作系统的差异，隐藏了底层技术的复杂性，这真的应验了那句话“计算机领域中，没有加一个中间抽象层解决不了的问题” 对于Java虚拟机来说，不仅仅只能运行由Java转换过来的字节码，任何语言只要能转换成符合要求的字节码，就能在Java虚拟机上运行 就像Java语言的不断更新迭代，Java虚拟机也经历了不同时期的变革，各厂商根据Java虚拟机规范，开发出了不同特性的虚拟机，目前主流的虚拟机有 HotSpot VM、J9 VM、Zing VM，其中HotSpot处在大哥大的位置，一般分析JVM，默认都是HotSpot VM 我觉得在未来，Java会在边缘计算、大数据领域再次放出光彩 学会JVM，不仅是自己本原思想的一种体现，也是希望通过剖析JVM，学习到如手术刀般精准和有力的代码判断能力]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》]]></title>
    <url>%2F2018%2F12%2F26%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%2F</url>
    <content type="text"><![CDATA[没有一门语言是完美的，当我们了解Java运作原理和本质之后，就能对写的代码做出一个评价，在追求完美的过程有了信心 入门 内存分布 命令行工具与参数调优 类加载机制 编译期优化 运行期优化：因为涉及到编译原理的知识，等学习之后在看 内存模型与线程 线程安全与锁优化]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《生命是什么》]]></title>
    <url>%2F2018%2F12%2F25%2F%E3%80%8A%E7%94%9F%E5%91%BD%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%8B%2F</url>
    <content type="text"><![CDATA[以一个量子物理学家的角度去看待生物学 交叉学科 统计物理 量子与生物 作者赫赫大名埃尔温·薛定谔，关于他最著名的故事就是“薛定谔的猫”，他说描述的这个实验把量子效应带进了宏观世界，和这本书想要说明的具有异曲同工之妙，也是想通过量子物理去尝试解释生物学上的一些现象 这本写于七十多年前的书，虽然有些观点不一定正确，但薛定谔在文中所体现出的从还原论的角度来研究生命现象的思维模式和丰富的交叉学科能力，仍值得我去学习 文章前言就谈及交叉学科的重要性，University本意是普遍的，则在如今的大学中，专业之间的隔阂越来越大，虽然一直强调交叉学科的重要性，但不管是学校还是学生做的都不够好。但这不也单纯是学生和学校的原因，知识本身的广度和深度对我们学习的人来说会是个不停的考验。如何才能充分掌握比狭隘的一门专业领域更多的知识是我8们面临的难题 薛定谔给出了一个看似很简单的解决办法：勇敢！勇敢的走出自己的擅长的领域，勇敢的将不同学科进行综合，即使这样看起来没有什么依据 为什么我们的感官如此粗糙，不能感知原子的碰撞，可是在缺乏对原子的直接感受下，我们又怎么能做出对原子的假设？ 反过来想，如果我们的感官敏感到能感知每一个原子的碰撞，那世界会是什么样子？那将不会有这个问题的产生，将不会产生有秩序的思维和意识 有机体要产生有序性，其必须服从精确的物理定律，而物理定律都会有不准确性，即所谓的$\sqrt n$律，意思是物理定律的不准确性在$ \frac 1 {\sqrt n}$这个可能的相对误差之内，其中$n$是定律生效的分子数目，因此要想有机体服从精确的物理定律，就必定是一个巨大的分子结构 本书的中间介绍了一堆高中的生物知识，可选择跳过 基因是稳定的，但也存在突变，薛定谔从量子跃迁的角度解释了这一现象。在写这篇文章的过程中，去查阅了资料，发现对于这个观点并没有完整的研究，对于如何产生基因突变也是众说纷纭，所以对于薛定谔这个观点不在深究，暂且放过 有机体的负熵]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《乔布斯传》]]></title>
    <url>%2F2018%2F12%2F23%2F%E3%80%8A%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[伟人都是疯子，天才亦是凡人 专注 自省 现实扭曲 完美主义 这本书对我来说会是一个转折点 我其实从来没有看过人物传记，这是我第一本传记，对自己的影响真的很大。看人物传记，就是去了解他的过往，他的经历，从而窥视他做事的原则和哲学，虽然不可能复制伟人的人生，但总能从他的传记中发现可取之处，从而让自己的人生变得丰富精彩 乔布斯那种叛逆、想要掌控和改变一切的性格，在其童年的时候就埋下了种子。做恶作剧反倒得到父母的支持，为了实现自己的目标，会打电话给惠普去想方设法的完成。这种成长环境造就了他那种现实扭曲的天赋。 书中多次提到的现实扭曲能力，我反倒没有什么体会，因为身边并没有这种能力的人，又或者我没有意识到。我对乔布斯那种极致的完美主义和简约主义印象特别深刻 乔布斯是个素食主义，这种饮食癖好也是他的性格造成的。除此之外，对于家居、装修、产品都不断体现他极其完美主义追求的性格。对于产品，不断不断的修改，近乎偏执。自己虽然做不到他那样偏执，但也要不断不断的逼近他。有天赋的人都是能把自己逼成疯子的人。不管是写程序，还是做事、看书，都要时刻提醒自己不断不断追求完美。从自己手中出去的每样东西都要不断修改，完美到它不需要修改为止。看看现在的自己，从来没有重复看一本书的习惯，做过的事就像泼出去的水，撒手不管。用熟悉的词形容自己就是不负责任和不踏实。能自省发现自己的身上很大一个缺点就要立即改正！ 书中有句话我记在了自己的笔记中“决定做什么和决定不做什么同样重要”，这句话我看到了两点，一是逆向思维，查理经常提及的“反过来想，总是反过来想”。映射到自己的学习中，面对如此多的学科，计算机这么多发展方向，知道怎么选择突破口，知道要舍弃哪些东西，是一个很关键的能力。专注于一个方向，认真踏实做到极致，自然就会成功。想到这里，我的脑海中就会冒出一个想法，如果我在打算深挖的领域没有建树怎么办，我是不是应该广撒网？？就是害怕错过其他机会。想到这里我突然明白查理为什么能成功了，专注于几只股票，仔细研究。捡了芝麻丢了西瓜这个话倒背如流，可是道理却从没有参透 在完美极致主义者面前，世界就是一堆破烂。自己也要可以培养这种角度，对身边看起来毫不在意的东西具有判断力 其实我很好奇，乔布斯为什么能接二连三创造出伟大的产品，到底什么因素造就这种创举？是想象力吗？是好奇心吗？是专注吗？是完美主义吗？都是！！这就是查理常说的lollapalooza效应，没有人会随随便便成功，当上述品质集中在一个人身上出现，不想成功也是很难的自己虽然天生不具有有上述品质，但学习、修炼的目的就是要培养自己这些品质，使自己变得越来越智慧 但自己对自己的做出来的东西能达到百分之百的满意时，离成功也就不远了 题外话 在《大问题》这本书中，看到一个问题“自己是个怎么样的人？”，书中提供了一种方法，想象自己是一本小说的男主角，那这个男主角会是怎么样的人？这种方法确实让自己触到了自省这个概念，所以才会有下面这些思考，但作为思考的雏鸟，这种方法使用的还不是很熟练 常常挂在嘴边的自省二字到底是什么意思？我要怎么做才能真正做到有效率、有用的自省？最近我对这两个问题有了一个明确的答案。 自省就是能清楚的认识到自己，不会自省的人也能评价自己是个怎么样人，他也自认为自己是个会自省的人。所以关键点就是要自己跳出自己围起来的思维栅栏，真正做到清楚、客观的认识自己，清楚客观四字才是自省最本质的特征。 当然要怎么做到这种自省呢？看书，强迫自己不断否定自己，去跳出思维栅栏，听取别人的评价。现在的自己就觉得脑子中有两个自我，两者在不断的否定对方，不断向对方发问，不断否定原有观点。还有一点，要找到跳出做事时的思维的方法，这才能更容易看出自己做的事的缺点]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb入门]]></title>
    <url>%2F2018%2F12%2F23%2FJavaweb%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[花了三个星期，从零开始学习Javaweb的搭建，并第一次上手一个框架，踩过了无数的坑，但收获还是很大 看本文的读者最好有以下基础 Java基础 对HTTP和HTML有所了解 Linux基本操作 对web运作流程有了解 数据库，如MySQL 当然如果不了解也没事，和我一样头铁就是干！ web历史概述我们简单回顾一下Web应用的发展 1991年Web页面在Internet上的首次登场，最早Web主要被一帮科学家们用来共享和传递信息，浏览器中主要展现的是静态的文本或图像信息。不过大家很快就不仅仅满足于访问放在Web服务器上的静态文件，1993年CGI（Common Gateway Interface）出现了，CGI定义了Web服务器与外部应用程序之间的通信接口标准，因此Web服务器可以通过CGI执行外部程序，让外部程序根据不同的Web请求生成动态内容。而在Java Web开发中的Servlet，其原理与CGI是类似的。那个时候编写CGI程序的主要是Perl和C等语言，在程序中输出大片的HTML字符串，可读性和维护性是个大问题。为了处理更复杂的应用，一种方法是把HTML页面中固定的部分存起来（称之为模版），把动态部分打上标记，处理Web请求时，后端程序生成动态的内容然后填充进到模板中去，形成最终返回的HTML。于是1994年PHP诞生了，PHP可以把程序（动态内容）嵌入到HTML（模版）中，不仅能更好的组织Web应用的内容，而且执行效率比CGI还更高。之后96年出现的ASP和98年出现的JSP本质上也都可以看成是一种支持某种脚本语言编程（分别是VB和Java）的模版引擎。 Web开发脚本语言，搭配上后端数据库技术，Web开始大杀四方，类似电子商务系统这样的复杂应用也开始出现在互联网上。如第一部分所述，这时MVC的概念被引入到Web开发中来了。这时一个典型的Java Web应用从架构上看起来应该是这个样子： Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） Controller(Servlet)调用核心业务逻辑——Model部分Model进行数据库存取操作，并将操作结果返回给Model Controller(Servlet)将业务逻辑处理结果交给View（JSP），动态输出HTML内容动态生成的HTML内容返回到浏览器显示 Spring MVC提供了一个DispacherServlet（Spring MVC是以Servlet技术为基础的），这个Servlet把Web应用中Servlet中经常要实现的功能封装起来并提供一层公共抽象，想象对应于一个Web请求后端要做的事情，比如： URL映射（对应HTTP URL和方法，应该调用什么代码） 权限验证（当前的URL是否允许当前用户访问） 参数解析（如何从Servlet中获得参数） 数据绑定（如何将Servlet中的参数，绑定到业务逻辑对象中） 数据验证（判断数据是否符合业务规则，比如邮件格式是否正确） 视图解析（使用哪个视图模板进行渲染） 模型传递与视图渲染（将数据传递给模板，并且在模板中引用） … 有了Spring MVC，你只需写简单的POJO代码（如图所示，用POJO实现Controller），或者实现Spring MVC给你提供的接口（比如实现Interceptor做权限判断），就能完成这些繁琐的功能 而ORM的作用就非常直观了，无须赘述，如图所示它提供了与数据库操作的一层中间抽象，这样Model的代码自然会更加简单。Spring MVC基本可以帮你屏蔽Servlet的API，ORM则可以帮你屏蔽JDBC的API了，也就是说你在更高的抽象层次上写程序了，更高的抽象层次一般意味着以更符合我们思维的方式来思考，自然效率更高。这事实上是软件技术发展的一个重要驱动力之一。你想想，从汇编语言发展出高级语言，从文件系统发展出数据库，其实本质规律是类似的 那Spring的作用是什么呢？ 看到图中大量的箭头没有？ 图中的每一个小方块其实都是大量的Java类来实现，Controller与Model之间，Model与数据访问对象之间的这些箭头，意味这些Java类之间存在大量复杂的依赖关系。Spring的核心功能依赖注入，正是用于管理Java对象之间的依赖关系，所以第一部分我们说Spring是一个一站式的粘合框架，它像神奇的胶水一样，可以以松耦合的方式有机的粘合在一起 回到历史，Web开始大杀四方之时，大型应用在分布式、安全性、事务性等方面的要求进一步催生了J2EE(现在已更名为Java EE)平台在1999年的诞生。但是J2EE的组件技术EJB（Enterprice Java Beans）非常笨重，Spring的初衷是为了替代EJB，让Java EE开发更加简单灵活。它起源于Rod Jahnson 2002年出版的著作《Expert One-on-One J2EE Design and Development》，那本书中分析了Java EE的开发效率和实际性能等方面的问题，从实践和架构的角度探讨了简化开发的原则和方法。以此为基础，他实现了一个名为interface21的轻量级开发框架，成为Spring框架的前身。2004年，Spring正式发布1.0版本，同年Rod Jahnson推出了另一部影响深远的经典著作《Expert one-on-one J2EE Development without EJB》，Spring开始逐步在Java领域流行。现在Spring框架的版本已经演化到了4.x，它已经成为Java开发框架的一种事实标准，对Java EE规范本身也产生了重要影响。比如EJB规范就在发展中逐渐引入了众多Spring框架的优秀特征 好了，你现在应该可以从更高和更广的技术视野来看待这几个框架了吧。看到一门技术的发规律和发展历程，这是一种技术修养的体现，跟人文修养是类似。但是同时我们也应该具有一定的深度，因为我们往往已经站在比较高的抽象层次，比如今天你写几行代码就能把数据库创建好，增删改查的功能也自动生成好了，但是成为高手需要你对底层的原理机制有更透彻的理解，真正遇到问题的时候才能抽丝剥茧迎刃而解 架构先讲讲一些大体上的架构吧！ 服务器端三层被称为经典三层结构，即web层（表现层）、业务逻辑层、数据持久层，出现了很多结合三层JavaEE的设计模式，DAO模式就是数据持久层的设计模式 实际上MVC和JavaEE经典三层结构是由两拨人分别提出的，两者间可以有着如下的对应： 业务层、数据持久层 —- Model web层 JSP —- View web层 Servlet —- Controller Javaweb的传统架构都是模块化的设计逻辑，如Views、Controller、Service和Dao，如果要进行水平扩展，则将应用部署到不同的服务器，并通过Nginx进行负载均衡（即反向代理）现流行的微服务框架则在传统应用架构上，将业务拆分为更细颗粒的服务，每个服务都是一个应用，并对为提供公共API，图中每个API都是一个传统应用架构 申明这次开发所用的环境（包括版本信息）真的很重要，因为我第一次在云服务器上部署tomcat时，所安装的jdk版本是1.7.0，而tomcat是8.5.5，产生的问题就是能顺利打开tomcat自带的界面，却不可以打开我自己部署的项目，这个问题还是我使用一个jsp文件去测试也打不开，才意识到可能是java没有安装成功，所以今后一定要注意版本的问题，不要随便安装。 所用开发工具 jdk版本：云服务器上安装的是jdk1.8.0，本地则是安装的jdk9.0.1，当然最好即使安装相同的版本，不然最后部署出现问题，会很“开心”的 tomcat 8.5.5 MySQL 8.0.13 集成开发环境：IDEA 其他小工具：FileZilla（用于将本地文件传到云服务器上），Navicat（MySQL可视化，连接云端数据库），虚拟机centos7（连接云服务器执行命令） 腾讯云服务器 还是要提醒自己也是提醒读者，版本信息也是一个关注点，我反正长记性了 目标 实现一个登陆和增删改查的简单web，并将其部署到云服务器上 对Spring框架的认识，并对项目涉及到的知识进行深入剖析 掌握几种设计模式（如模板设计模式） 对Java语言深入认识和回顾 锻炼自己的调BUG的能力，如何快速定位出错的原因和位置 我觉得我在这个项目中认识到的最最重要的一点就是一定要记录每次出错，并进行排错的过程步骤，这样不仅知道哪一步骤出错，还能方便回头写总结文档 步骤接下来不啰嗦，进行第一步，选择创建的是maven项目 这里提一句maven是什么，中文名是行家（有点意思），但其实是犹太语，意思是知识的积累，是一个软件项目管理工具，在我们这个项目中就是可以通过一个配置文件pom.xml来引入开发需要的包，而不用自己去下载去引入，只要写一个简单的配置文件maven就可以从本地或者中央存储库（点这里哦！）中将jar包导入这个项目中，除此之外可以自动部署到tomcat上、自动生成war包等等，覆盖了一个项目完整的生命周期，很有用也很好用！ 上图看步骤点击Next，GroupId填的一般是域名，以此区别其他人的开发项目，和Java包的命名方式类似，artifactId就是项目名称（不过artifact是人工制品的意思？？），填完之后就是一路点点击Finish，之后在等待创建项目的时候，右下角会出现这个标签，选择Enable Auto-Import，这样当pom.xml配置文件改变的时候，maven就会自动更改 创建好后的初始文件目录 之后先去配置tomcat，如下图选择”demo::war exploder”包，这样一个简单的网页就算完成了点击”run”运行第一个网页吧！ 将项目部署到云端服务器上先安装jdkyum install jdk-1.8.0-*在安装tomcat 先下载tomcat安装包，再把安装包传输到服务器上，并运行，在将整个项目文件传到tomcat文件下 第二步：修改 $TOMCAT_HOME\conf 下的server.xml文件在server.xml文件中新增节点，一个节点代表一个web应用path:指定访问该Web应用的URL入口。 如“/HelloApp1/”docBase:指定Web应用的文件路径，可以给定绝对路径，可以给定相对路径。。如应用HelloApp1的文件路径为/webapps/HelloApp1reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF，lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。 相关文章：《Spring揭秘》]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
        <tag>Web</tag>
        <tag>Mysql</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《几点感悟》]]></title>
    <url>%2F2018%2F12%2F22%2F%E3%80%8A%E5%87%A0%E7%82%B9%E6%84%9F%E6%82%9F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天在YouTube上看到一个清华留学生的视频，对我触动挺大的。 自律 执行力 推销自己、表达自己 一个十九岁的清华学子，已经能通过制作视频月收入五位数，然后再对比自己，我觉得从那个视频中体现的最大的区别在于执行力和洞察力 在这个视频中，他讲了一个在经营频道初期做出的一个重要决定，从做自己喜欢的物理教学内容，到做用户喜欢的内容，他洞悉到了频道前期subscriber增长较慢的最关键的原因。 让用户参与进来，是这个YouTuber反复提到的一句话，也是雷军的哲学理论。只有写出、做出用户感兴趣的内容，才能实现增长。写到这里，不免提一句乔布斯做产品的理论：他们要做的是在用户还没意识到其需求的时候，就为其提供全新的设备与服务（《乔布斯传》）。这里不去评判那种哲学更好，只是提供不同的观点。 作为一个立志成为企业家的YouTuber，他的努力可以说是近乎疯狂，每天早上四五点起床学习，双休日亦是如此，这就是自己和清华优秀学子的差别。 但是话说过来，真正让自己写这篇文章的动机其实还是利益，是钱。为什么人家看理财的书籍，就能做到每月五位数的收入，而自己也看过一些入门的理财书籍，却什么起色也没有呢？ 其实这个问题自己也意识到很久了，自己虽然也私底下默默努力，但因为性格原因，自己并不愿意主动分享自己的成果。这样显然是不行的。要把自己推广出去，让别人知道自己在做什么，自己会什么。这也是哲学的本意，要把自己的思想完整、清晰的表述给别人听，这方面的能力正是自己缺乏的。 所以才又拾起自己的公众号，博客和知乎，来锻炼自己这方面的能力，并给自己立下flag，每周能产出二到三篇文章。]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 过程抽象]]></title>
    <url>%2F2018%2F09%2F30%2F%E3%80%8ASCIP-%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[心智的活动变现在三个方面 将若干简单认知组合为一个复合认识，由此产生复杂认知 将两个认识放在一起对照，由此得到有关它们的相互关系的认识 将有关认识和那些在实际中和它们同在的所有其他认识隔离开，这就是抽象 计算过程是存在于计算机中的一类抽象事物，这些过程去操作被称为数据的抽象事物，人们创建出一些称为程序的规则模式，以指导这类过程的进行 计算过程就像巫术，看不见摸不着，根本就不是物质组成，然而却很真实 “Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。这种特殊形式能够创建出所需要的过程，和define创建的过程的区别就是这种过程没有与环境中的任何名字相关联]]></content>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 数据抽象]]></title>
    <url>%2F2018%2F09%2F30%2F%E3%80%8ASCIP-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[忘记1表示的是一个苹果，2表示的是两个苹果，数学家不应该停留在这个层面。 最基本的数据就是数值，也就是1，2，3，但是现实事物不只是数值表示，我们需要程序去模拟更复杂的数据对象，目的就是为了提升设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达性。]]></content>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《小狗钱钱》]]></title>
    <url>%2F2018%2F09%2F29%2F%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B%2F</url>
    <content type="text"><![CDATA[当弟弟说他三年级就看过了这本书，我真的心生羡慕。我这个阶段去看这本书绝对没有小的时候看来的影响大，现在的自己思想开始固化，有些书中的观点看过就罢了，没有很大的震撼，所以说看好书要趁早]]></content>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《穷查理宝典》]]></title>
    <url>%2F2018%2F09%2F28%2F%E3%80%8A%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一本汇聚了查理一生智慧的书，一本会改变我人生轨迹的书 终身学习 价值投资 跨学科思维 误判心理学 成功不能复制，但成功的人一定是有共性的。 如果想讲明白这本书说了点什么，很容易；但如果问自己这本书给自己带来了什么，很难。如果把这本书当成是智者语录，那是在糟蹋这本书，书中说的很多道理和曾经学习过的思想重复，但有的人在生活中一直遵守着这些准则，生活中不断实践这些原则，也只有这样才能得到提高。 终身学习“活到老学到老”这句话是从小一直反复重复的道理，但又有多少人一直在实践者这句话。现在有多少大学生愿意静下来去看本书，连教科书也是在奖学金绩点的驱动下才会去看得情况下，他们都多大的可能会去实践终身学习这条准则。对于这个问题我持着消极的观点。 现在人不愿意花时间看书，去学习，去提升自我，一方面是因为想追求的东西太多，压力太大，一方面是因为回报率太低，觉得不值得这么做。可就像书中所说，睿智成功的人没有一个是不热爱读书的，读书可以让自己的大脑保持一个开放的状态，不固步自封，书中有前人的经验，从中学习的道理是一笔巨大的财富。 多元思维模式在手里拿着一把锤子的人眼里，世界就像一根钉子。在所在专业陷得越深，这种用单一思维模型思考问题的现象就越明显。 对任何一个问题的思考，要学会从不同领域去思考，洞察问题的本质。 这一点或许会是我现在或是未来最大的收获。一个问题可以正向思维，可以逆向思维，可以用物理学模型解释，也可以从社会学角度解释，甚至从心理学角度去观察。只有不断应用这种思考方式，才能看到全面真实的事物。要在今后的学习中不断联系各类学科，建立不同学科的思维模型。这种多元化的思维要不断通过看书学习来丰富，也要不断用于与现实才加固。 【更新】最近（2019.1.17）在写总结，本想针对一个主题，结合不同书本，去串通其自己做学的东西，但是就像只会递归，却不知道怎么回去，不同的查阅书籍，最后就会迷失方向，忘记一开始我为什么要开始写这篇文章，而且还会不停地递归，不停地开不同的文章，最后就是栈的深度不断变深，也就是意味着未做的事情越来越多，最后陷入崩溃。觉得自己是一个向前的方向感不错的人，但是往回的方向感特别差，在前进的路途中，总会被各种各样的事物吸引，最后就是找不到回去的路。要怎么解决这个问题？我想就是要不断和自己强调我的目的是什么，时刻铭记出发时的动机！！之前的思维模式很像是广度优先算法，现在还需要自己培养类似于深度优先算法的思维模式，脑子里始终要有一个栈，做完就出栈，时刻铭记栈底元素 诚实正直诚实和正直不能带领着走向成功的山峰，当它能让我们在成功的山峰上待的久一点。以前流行的一句话长大以后变得越来越像自己讨厌的样子，我不希望自己以这种方式成长，我希望自己能一直保持现在这种单纯的心态。 误判心理学列举几个常见的心理学偏见 受简单联想影响的倾向：一次成功的案例，会让你误以为下次也会成功，却没有去审视造成成功的案例的真正原因和偶然原因，为下次行动做准备，防止出现一些没有注意到的危险因素。不要带着有色眼镜来看待事物，要认识到趋势未必能够正确预测终点，未必能够根据群体的平均水平来判断个体的特性 自视过高倾向：就像父母看不清自己孩子的性格，人们对自己的私人物品也会过度高估，也会对和自己相似的人或事物产生偏爱，因而形成不同的派别 对比错误反应倾向：小小纰漏，能沉大船。永远不要忽略小小变化的力量，人们往往无法从前后对比很细微的变化看到最终趋势，而恰恰是这细微的变化，既能够煮死一只青蛙，也能水滴穿石。相信“每天进步一点点”的力量 错误衡量易得性倾向：别因为一件事实或者一种观念容易获得，就认为它更为重要，即不要被先入为主的观念所吸引，为了避免这样的思维出现，有以下几种方式可以尝试：按程序办事，使用检查清单；重视反面证据，特别关注不那么容易被量化的因素 重视理由倾向：当人们把自己的直接和间接经验悬挂在一个解释为什么的理论框架上，那对知识的吸收和使用将会变得很容易。不管是老师传授知识，还是上级发布命令，都应该把原因讲出来 未完查理就是在世的孔子，这是本需要自己反复研读的书]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《如何阅读一本书》]]></title>
    <url>%2F2018%2F09%2F25%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[早点看到这本书，或许在阅读技巧上就可以少走一些弯路吧 看完一本书必须回答的四个问题： 这本书整体框架是什么，到底讲了点什么？ 作者想阐述的观点或论点有哪些，都引用了哪些论据？ 是否符合自己的经验，有无道理？ 对自身的帮助有多大？ 每看完一本书，总是纠结该怎么写书评，我想这四个基本问题就是一个很好的出发点。况且这几个基本问题应该是阅读过程中，每时每刻都应该不断问自己的问题，还要精确的回答。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《插入排序vs选择排序》]]></title>
    <url>%2F2018%2F09%2F11%2F%E3%80%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Fvs%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天复习才发现两种算法这么相似 书上提供了分析不同算法性能的手段 实现+调试 理论分析 对相对性能做猜想 实验验证 选择排序不断选择待排序元素的最小值，外循环就是遍历这个数组，内循环就是找出剩余数组元素中的最小值，并和当前元素交换，算法很简单并且具有以下两个特征： 运行时间和输入模型无关：不管输入是排序好的数组或是值全部相同的数组，还是随机乱序的数组，运行时间都是相同的 数据移动次数少：每次排序只会交换一次，总共只会移动N次，和数据大小成线性关系 插入排序]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《三个数之和》]]></title>
    <url>%2F2018%2F09%2F11%2F%E3%80%8A%E4%B8%89%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[设计算法，从一堆数字，找出任意三个数和为零的个数]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《数据结构与算法分析》]]></title>
    <url>%2F2018%2F09%2F11%2F%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[头铁买了英文版 代码 学习算法第一步就是学习怎么评估一个算法在大数据下的性能，并且学会从理论上评估不同算法的运行时间 算法分析的数学基础其实很简单，分别是对数的基本运算、级数和模运算 C ADT List，DoubleList，Stack，ArrayStack，Queue Trees Tree，B_Tree，AvlTree，SplayTree Hashing Heaps Sorting Graph]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人类简史》]]></title>
    <url>%2F2018%2F09%2F11%2F%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E3%80%8B%2F</url>
    <content type="text"><![CDATA[才看了几页，就被作者的角度给深深吸引 人类其实都是早产儿，因为智人的脑容量在不断表达，直立行走的变化让骨盆变小，所以物竞天择的原因，生下来的一定是还没有完全发育好的婴儿，真的深深的被这个观点吸引。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《算法（第四版）》]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%8A%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B%2F</url>
    <content type="text"><![CDATA[极好的数据结构和算法的入门书 代码 就如书序中所说，学习算法，不能照本宣科，只知道算法本身的一二三四，而应该是不断试错的过程。 所有算法都是先有API，再有实现，之后是证明，最后是数据。这可以说也是自己数据结构和算法的学习方法。 写这篇文章的时候，已经是在复习这本书的阶段，现在的困惑是怎么让复习高效？现在的自己翻开书觉得书里的东西自己都懂，合上书，又说不出个所以然来，这个时候，就要多多回想，多多总结，把知识都装进脑子里，避开学会的错觉。 Sorting这一节就可以扩展出很多的内容，面试的时候也很喜欢问，根据不同特性的输入模型，要选择合适的排序算法。这就需要我们去了解算法的特性，才有可能选对合适的排序算法。 Java ADT Bag，Stack，ArrayStack Sorting Select， Insert，Shell，堆排序，快速排序，2-3查找树，红黑树，散列表 Graph 最小生成树，最短路径 《三个数之和》 《插入排序vs选择排序》]]></content>
  </entry>
  <entry>
    <title><![CDATA[符号数的表示]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[学了一年才整明白一个负数的表示，惭愧惭愧 一直没有整明白有符号数的表示原理，这次又一次遇到了这个问题，就下定决心一定要搞明白，而且涉及到得到数学知识刚好是自己学过的，这次就一并整理归纳一下。 计算机中的符号数有三种表示方法，即原码、反码和补码，最常见的就是补码表示]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《乌合之众》]]></title>
    <url>%2F2018%2F09%2F06%2F%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E3%80%8B%2F</url>
    <content type="text"><![CDATA[书很薄，内容很厚；群体都是无意识集合；群体和个人，原始和智慧； 最近学校发生了不好的事情，学生对领导层很不满意，也算是群体表现的一种，刚好写下了这篇文章。 人都是群居动物，群体这个概念永远不会过时，尤其在现在沟通如此方便的情况下，群体的形成更容易，规模更大， 群体的概念更为明显，现在是群体的时代。 其实自己也能感觉到群体的力量，当你置身于群体中时，真的会不自觉的朝着群体所想的方法去思考，自己独立的思考很容易断线，所以有些时候，将自己置身于群体之外，不要太参合群体事件，对自己清楚认知有帮助。 人们总说众人拾柴火焰高，但在群体中并不是人越多，力量越大，群体是低智商，无理性的。 当看到群体的逻辑和推理能力这章的时候，深深的感到慌张，甚至害怕。书中说，群体的逻辑能力即使有，也是低级逻辑能力。它们只能通过伪相似性来进行联想，没有真真的逻辑推挤。例如书中的例子， 因纽特人根据生活经验，觉得透明的冰放入嘴巴中会融化，那透明的玻璃放进嘴巴应该也会融化。这就是低级的推理能力，没有抓住事物本质的相似性。而让我感到慌张的也就是这一点，我的思维也没有逻辑性，想称述的观点，都是从脑子里一条一条蹦出来的，没有条理性；理解事物的本事的能力也是极其差，很难抓住事物的特点和核心；我看事物就和因纽特人一样，只能看到事物表面的练习，这样可真愚蠢。 我要怎么样去改变呢？ 看这本书的时候，很有带入感，总想着把身边的事情带入书中的理论，但就像开头说的内容很厚，看完之后，还是感觉没有真正参透书中的内容。]]></content>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《富爸爸穷爸爸》]]></title>
    <url>%2F2018%2F09%2F02%2F%E3%80%8A%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本来想说这是本理财入门的好书，看到后面，我觉得这还是一本对树立事业观有帮助的好书。 看这种投资理财的书，首先要树立良好的心态，别想着看完一本书后，就知道如何赚大钱，如何实现白手起家，如何财富自由。书里给出的不是如何赚大钱的答案，而是实现的成功路上的路标。 本书一个核心观点就是“富人让钱为他工作，穷人为钱工作” 富爸爸上的第一课，我觉得也是最重要的一课，就是人的恐惧和欲望。大部分人都想赚大钱，以为赚大钱就能生活幸福，可人们都忘了欲望这种东西是会膨胀的，没钱的时候，节约支出，过着没钱的生活，有钱的时候，随便花钱，过着有钱的生活，但是不管是哪个阶段，总觉得缺钱，因为欲望在膨胀，收入和支出总是你追我赶，就如老鼠赛跑。所以不管是穷人还是富人，如果不能好好的正视自己内心的恐惧和欲望，树立正确的消费观，只会一辈子都觉得自己缺钱。 如果不能控制好自己的恐惧和欲望，即使获得高薪，也只是金钱的奴隶。 大部分人努力工作的动机，就是对钱的恐惧和欲望。害怕没钱买不了想买的东西，害怕没钱还不了债，所以每天僵尸般的努力工作，生活推着每个人去努力工作，人们以为努力工作就能过上好的生活。 程序员总戏称自己是码农，我想不仅仅是因为工作辛苦，我想还有就是程序员太过于投入自己的技术，而没有关注除编程外的技能培养。 富爸爸的另一个观点就是不断学习，要掌握不同的技能点，而且年轻人找工作很大一部分目的不是为了钱，而是为了掌握技能，技能掌握的越多，成功的几率就越大。 书中反复强调的一个观点就是购买资产，而不是负债。资产是可以24小时不断给自己带来现金流的东西，而负债只会不断掏空自己的财富，例如贷款买车，在买的那一刻就意味着贬值，他只能成为自己的负债。 书的前半部分说了很多个人思想的观点，很多人禁锢在自己的思想里，眼界很狭隘，没有动力和兴趣去接触和自己的思想相悖的东西，他们宁愿活在很难受但是熟悉的环境中，也不愿意尝试其他新鲜事物。这类人在面对未知的时候，很容易表现出恐惧来。所以他们对待钱时，面对钱的恐惧，只知道努力工作，这样就能赚到钱，恐惧也许就消失了，正是这种思想阻碍他们去寻求新的挣钱之道，去做出改变。这就得出了书中说到的一个观点终身学习，只有不断学习，使自身最大的财富–大脑变得灵活和开放，才不至于变得无知，才能平静接受变化的到来，才能习惯变化，而不是沉溺在熟悉的环境。 书中还提到了自知这个点，说日本人认为自知是最强大的力量，自知能帮助自己认清自己的智慧，发现真相，而不是盲目随大众。很多人包括自己，喜欢把自己埋在大众中，不愿意成为大众中特别的人，就是因为害怕被排斥，害怕受到批评。如果让我去表达自己的观点，我第一个浮现的想法竟然是别人是不是把自己当傻子看，总觉得自己的想法是很愚蠢的，我想这是自己长久以来的自卑导致的。 真正成功的人都是在创造机遇和金钱，弱者才去等待机会，让机会的浪潮将自己推向高点。 复利：复利是指一笔资金除本金产生利息外，在下一个计息周期内，以前各计息周期内产生的利息也计算利息的计息方法，俗称利滚利。初入投资界的时候，总提到年化率多少多少，觉得10%，20%看上去好像特别少，但是如果真的去算一笔账的话，觉得发现复利的恐怖之处。但要想获得复利的威力，就要保证不出现负增长，否则复利的效果就会大打折扣。普通投资者大概能做到15%的年化率，这15%其实是经济增长带来的红利，不一定是投资手段带来的收益，想投资大神巴菲特能做到20%，这多余的5%才是由投资技巧带来的额外收益，每个投资者都在寻找超出平均水平的增长，争取跑赢平均水平 看完书之后再来评价这本书，好像也没有特别好，内容很肤浅但是简朴，还掺杂着自己的广告，但是作为一本入门理财书来说，它做到了它该做的，对于我这个小白来说，它树立了不一样的财富观，甚至道出了有用的人生观，是本带自己走向理财领域的好书。]]></content>
      <tags>
        <tag>财商</tag>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大脑喜欢这样学》]]></title>
    <url>%2F2018%2F09%2F02%2F%E3%80%8A%E5%A4%A7%E8%84%91%E5%96%9C%E6%AC%A2%E8%BF%99%E6%A0%B7%E5%AD%A6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[学习如何学习]]></content>
      <tags>
        <tag>成长</tag>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《三傻大闹宝莱坞》]]></title>
    <url>%2F2018%2F08%2F30%2F%E3%80%8A%E4%B8%89%E5%82%BB%E5%A4%A7%E9%97%B9%E5%AE%9D%E8%8E%B1%E5%9D%9E%E3%80%8B%2F</url>
    <content type="text"><![CDATA[二刷这部电影，找到了很多共同点 第二次看这部电影，发现电影中的很多观念和自己不谋而合，也可能是第一次看的时候，电影灌输的理念成就了现在的自己。 这部电影在中国能这么火热，就因为大部分中国人一定能在这部电影找到共同点，中国教育一直说要减负，要改变应试教育制度，但是从来都是说说而已，在中国连连相似题材的电影都拍不出，或者说不让拍，教育制度就很难有所改变。 说回电影本身，将近三小时时长，在二刷的前提下，我依旧充满兴趣的看完，全程槽点不断，还充斥着印度片特有的歌舞片段 说说我喜欢这部电影的原因，我在男主人公身上找到了太多共同点，我也想像男主角那样活得洒脱自由，能冲破束缚，不呆板，实用主义， 电影是理想的，而我也是理想主义的，]]></content>
  </entry>
  <entry>
    <title><![CDATA[《一出好戏》]]></title>
    <url>%2F2018%2F08%2F22%2F%E3%80%8A%E4%B8%80%E5%87%BA%E5%A5%BD%E6%88%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一部细思极恐的电影 这是我回国后看的第一部影片，又一部没有任何了解就去看的电影，没有说特别的惊喜，毕竟在开始自己还瞌睡了好几分钟，但回想起来还是有很多有意思的地方。 先谈谈黄渤这个才子，其貌不扬，但我一直都很欣赏他。如果让我回想一个最赏识的演员，第一个浮现的就是他。大概因为人家也是从草根出身，身上有着我喜欢的质朴和真实，所以会多一些好感，会拉近距离一些。黄渤这个人如果说他的天赋是喜剧，那只看到了他的一个方面。也许他习惯把自己的想法通过喜剧的方式表达，但他的思想深度、高情商绝对凌驾于他的喜剧天赋之上。 说会电影本身，看完之后第一感觉喜剧部分拍的不好，第二有些问题并没有给出答案，就是说我能很明显的体会到黄渤想在电影里表达的东西，但是没有明确他自己的答案。 故事情节大概就是一个公司组织团建坐一辆校车样子、水路两用的车子出去玩，当时正值陨石撞地球的时刻，于是掀起了一股巨浪，将众人带到了一个孤岛上，生存了一百多天所发生的故事。 不想太多评论电影本身，因为自己不专业，说不出来什么东西。我就从几个引起自己思考的点切入来谈谈自己的感受。 第一个是六千万彩票。该影片最大的一个戏剧情节就是在被困孤岛的时候得知自己中奖了。彩票的兑奖期限只有90天（90天这个天数在心理学上是可以让人把习惯养成本能的期限），马进每天掐着手指过日子。可以说能支持马进活下去的一个很大动力就是彩票，我原本以为期限过去之后，马进会做出一些不可思议的事情，因为支持一个人活下去的希望破灭之后，大部分人都会癫狂。现在的很多人都不知道为了什么而活，有些人也希望能有彩票砸到头上，有些人只是单纯的苟活下去，这类人从来没有思考过活着是为了什么。如果把这个问题：现在为什么而活着？抛向社会，很多人的答案一定是钱。我要赚大钱，买大房子，买豪车，还要养育儿女父母。这样的想法所有人都有，但是很多人只有这个想法。赚钱本身并没有错，有钱才可以换取自己想要的东西。但如果活着只是为了赚钱，只是为了买房子，那这样活着一定一定是不幸福的，一定是得不到满足的。钱应该是努力完善自己的附属产物。 第二个特点这部电影是很明显的人类发展史，从王宝强领导的原始社会，到于和伟领导的资本社会，再到黄渤领导的乌托邦。在来到孤岛之前，这群人在现代社会都有不同的角色，当他们被隔离之后，各自的角色发生了大变换，王宝强因为有一身本领，以蛮力统领着这群人，所有人也只能屈服于他，后来于和伟发现了一艘破船，毕竟是在公司当老总的人，掌握着一副管理的本事，就开始利用了船上的资源，进行原始的资本积累，还发明了货币，屈服于黄渤的那帮人，慢慢开始为于和伟服务，因为在这里，有劳动就有回报。黄渤是所有角色里最具感情的，一是追求爱情，二是追求梦想，因此也只有这类人才可以开拓出乌托邦，为其他人创造一个精神世界 用喜剧、荒诞的手法去叙述，既不是一部正经的喜剧，也不是彻底的荒诞剧，如导演所说，一部两小时的电影，想表达的东西太多了，让观众，至少是让我抓不住想表达的细节，但如果让我给这部电影打分，我可以打八分以上，一它够新颖，不是单纯的商业片，二黄渤的处女作够棒，三有血有肉，能引发思考]]></content>
      <tags>
        <tag>黄渤</tag>
        <tag>电影</tag>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Adelaide游记-景观篇》]]></title>
    <url>%2F2018%2F08%2F02%2F%E3%80%8AAdelaide%E6%B8%B8%E8%AE%B0-%E6%99%AF%E8%A7%82%E7%AF%87%E3%80%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[《Adelaide游记-学习篇》]]></title>
    <url>%2F2018%2F07%2F22%2F%E3%80%8AAdelaide%E6%B8%B8%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AF%87%E3%80%8B%2F</url>
    <content type="text"><![CDATA[谈谈收获 来Adelaide五个星期，期间不断地在手机便签上写下自己的感想，所以这篇文章的诞生为期一个月，而且是由不同的片段构成。我会从见识、阅历、学习形式等方面来阐述我在澳洲这段经历的收获。其实来这边学习，我就没有抱着学习英语知识来，我来这的目的一开开眼，体验不同的文化，二体验不同的上课风格，学习不一样的学习方式。我给自己定的目标就是学习思想层面的东西（不知道这样表达准不准确）。 公交从小到大去过的地方真的少之又少，这次大跨步跑出了国，对我的影响还是很大的。课本中说文化是各式各样的，说南半球有个叫澳大利亚的国家，可是课本上区区几行文字和身临其境比起来真的微不足道。第一次坐飞机才发现飞机真的好不舒服。下飞机和寄宿家庭的男主人整整抱了五秒钟让我深深感受到外国人的热情。这里要多说一句，外国人的热情真的是由内而外散发的。第一次坐公交，要找零钱的时候，公交司机还和我耍了个把戏，把硬币给变没了。每次上车，司机都会微笑的和每位乘客打招呼，下车时乘客也会说“thank you”。对于腿脚不方便的老人，每辆公交都会有可以倾斜的装置方便乘客上下车。车厢上每根把手都有停车的按钮，不像中国只有门口有一个。手机上有个APP能方便的查询公交的实时到站时间和公交路线。就这几个小小的细节让我觉得我每天坐公交不仅仅是让司机把我从一个地方送到另一个地方，而是有人与人交流的成分存在。中国的东西看上去规规矩矩，但都是为了整齐而设计，这边就以人为中心去设，这一点说的也许不正确，毕竟看过的东西少。每天压着点的去到公交站，上车的时候和司机打个照面，然后找个位置静静的欣赏眼前的风景，车上的人们也都安安静静的看书，听音乐，丝毫没有国内公交的嘈杂。对我来说每天二十分钟的上学路是不无聊的。 有一次坐公交，看着手上的硬币，突然脑海中呈现出一片大陆和另一片大陆，突然发现世界上有另一块地方用着不一样的东西，过着不一样的生活。就感觉以后想象的时候就不会局限在中国，不会局限在杭州，这种不一样的思考界限肯定对自己是有帮助的，我想这趟旅行得到的不仅仅是眼福，还是脑福，这才是终生受益的。 上课在这边上课真的很幸运遇到了传说中的好老师，就是那种上课巨激情，自身又是真心喜欢教育的老师Joanna。因为只是来这边进行语言学习，所以课堂体验不能以偏概全，但还是想说说这边的授课方式。小班化的班级让老师能在短时间内认识班内的同学。虽然依旧会有阶段考试，但是老师会刻意去弱化考试这个概念，而是说assignment，考试的色彩不是很浓厚。上课的形式也是多种多样，有面对面辩论，有小组讨论，有做海报，有三分钟演讲等等。课堂到现在都还没让我感到无聊过（更何况还有韩国小姐姐的加持）。而且这边的作业也不是很死板，是能驱动你去思考更多问题。这样的学习会更主动，效果自然更好。 认知自我意识的觉醒应该是高中的时候开始的。现在处于培养自我意识的阶段。之前一直都是被灌输各种思想，不管是好的坏的，合适不合适的，就被迫的吸收消化。当自己认识到这个问题的时候就会刻意的去锻炼这方面的额思维方式，面对别人的观点时，要保持自己的立场同时，又能接受别人的有意思的观点。所以为什么会有辩论的产生，就是努力试图去说服别人信服自己的观点，而自己会什么不擅长辩论，就是因为自己太容易被别人说服，这样哪还有辩论的必要呢？ 最近对世界的认知，对自己的认知也算是有些萌芽了。为什么这个阶段自己好像能把自己，把世界看得更明白一些了呢？我想就是因为这段时间看了太多不同圈子的人和事了。只有对比，自己才能看清自己的不足，自己的特点，自己的优点（好像没有） 上课的时候经常会去自己介绍，免不了要介绍自己的爱好，真的看看自己本身，好像没有什么真正喜欢的东西，没有发掘到自己的爱好，接下来的学期任务之一就是要去发掘的自己的爱好，并且一直坚持下去。 以前的自己对自己的认识是及其模糊的，要么过于高估自己，要么过于低估自己的能力。面对自己的缺点，就是很不愿意去承认，觉得低人一等，面对优点，又不想展现，觉得别人肯定也有。 对于事物的认知自己也是极其迟钝，例如对于学习方法的探索，我一直都在看别人的学习方法，却很难探索出适合自己的学习方法，就是因为不会去分析自己什么环境下效率高，什么环境下根本不适合学习，什么学习方法更能帮助自己记忆。这里列举的只是学习上很少的一部分问题。而这方面的能力就要自己不断地去锻炼。 这部分的内容写的特别零散，因为很多感想都是一瞬间被点醒的。就好像我一直都知道阅人这个词语，但当我认识了来自希腊、泰国的小哥哥，他们都去过了很多的国家。就有那么一瞬间我对阅人这个词有了不一样的理解，好像进入了不同的阶段。 课堂分享故事的时候，很明显希腊和泰国的小哥哥的气场就是不一样，不想中国学生畏畏缩缩，他们的故事也更有吸引力，因为他们经历比我们丰富太多。 逻辑作为一个理科直男，却一直认为自己的逻辑思维能力不够强，尤其是在表达方面，说话没有语序，写作想到什么就写什么。 这次在上课写作的时候，突然想到自己写作都是毫无章法的原因是因为自己对自己的想写的内容没有大概的框架，如果自己的心里有个谱，就知道自己要写什么，写到哪里，这个点就和提纲一个道理，可自己现在才明白。自己其实早就有所体会，写作之前要是能写个提纲，写作明显又快又流畅，但是因为写提纲特别费时，就不愿意去写。 记住！以后写技术性的文章一定一定要过脑子，不要抄书，自己画树状图，自己写结构！！这样效率才高！！ 专注这一点可以说是从小学习到大还没学会的技能，自己的性格就是三分钟热度，也就是说别人一次性能专注45分钟，而我就只能专注30分钟，而且我学习喜欢东看一点，细看一点，这样也不是说不好，至少能搭建完整的知识体系，但学习的时候还是要专注，之后学期的学习方法要进一步改善，要制定更专一更专业的计划！ 细节细节决定成败，这句话常被人们说道。但每当自己想到这句话的时候，就会感到瘆得慌，因为自己就是一个不注重细节的人。 自己每做一件事的时候，就觉得事无巨细真的好累啊，又看不到这样做的价值。对这个问题的回答就造就了自己是一个及其普通的人。因为一件事我把它做到百分之八十，我就觉得不值得再花力气把它做到百分之九十，百分之九九。在我的概念里，从百分之八十到百分之九十比百分之六十到百分之八十花的力气要多很多，但我力气花下去又得不到完美的结果。就是这种中庸的思想导致自己永远只能做到百分之八十，做不到更好。我这种粗线条的思维让我只能做好整体那部分的百分之八十，而那百分之二十就要通过细节去打磨再打磨。所以明白了这个道理，就要开始改变自己的做事风格，做事不仅要利落，要准确，还要追求极致。 自信我想自信的另一种形容就是底气。上台演讲前，要是你本就有很好的口才，本就准备的很充分，就不应该感到紧张，可为什么我每次上台讲稿子也还是哆哆嗦嗦，讲的特别快就想赶快下台，就是因为这种场面见得少了，缺少经验，缺少技巧。能在众人面前几乎完美的讲话，背后是无数的积累。自己还是要多努力啊！！ 思考我一直认为人就是要不断思考，缺乏思考的人一定就是空虚的。可以思考个人成长，思考社会发展，思考国家大事，但就是一定要不断思考。对于这一点自己做得及其不好。昨天和寄宿家庭的朋友聊天，他问我为什么中文难学？这是一个自己遇到过很多遍的问题，可自己心中一直都没有一个完整的答案。这样的结果就是让话题终结在我这儿，也侧面衬托自己话少的原因就是因为缺乏思考。 平衡上个学期把身体给学坏了，颈椎出现了问题。现在回想上个学期的学习方式自己能不出现问题吗？每天七点起床，去图书馆坐上一天，晚上十点才回寝室，还要背着一个大书包。每周也没有双休日，就是不断的逼着自己学习，觉得脑子疼以为是学习的长进，殊不知这是自己的累的信号。所以之后不管是学习还是工作一定要注意平衡，一定要给自己留时间，去放松，去培养点自己的爱好。 自律自律这点可以说是最最最重要的。这点可以重新写一篇文章，讲讲自己怎么做到自律，有哪些方法能让自己维持自律。 这两天写出了这篇文章，还算是有不少收获，文中的几个标签也应该作为自己以后成功的几个信条吧，要时刻牢记！ 以后这样的文章可能很难见到，因为这样悠闲下来去思考的时间真的很宝贵，这次来澳洲能得到这样的时光，去沉淀总结自己，真的很棒！ 希望自己每天都能有一点思考，每天进步一点点，积少成多。]]></content>
      <tags>
        <tag>Adelaide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有限状态机]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[之前在编译原理、计算机网络中都碰到了有限状态机（FSM）这个知识点，但一直都说不上来具体的概念是什么，总结一下 就如自己在学习的过程中遇到的一样，有限状态机常用在数据网络、拼写检查、语法检查中 带输出的有限状态机的形式定义： 有限状态机M=(S,I,O,f,g,$s_0$)由以下部分组成：一个有限状态集合S，有限的输入字母表I，有限输出字母表O，转移函数f，输出函数g，初始函数$s_0$]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌云SSR免费搭建]]></title>
    <url>%2F2018%2F07%2F12%2F%E8%B0%B7%E6%AD%8C%E4%BA%91SSR%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[翻墙教程 前期准备：信用卡 购买服务器可以选择谷歌云等国外服务器 安装SSR1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh 然后设置密码和端口，其他设置直接选择默认就好 客户端连接 成功！]]></content>
      <tags>
        <tag>翻墙</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础教程]]></title>
    <url>%2F2018%2F07%2F09%2FHTML%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[HTML基础教程 标题 段落 链接This is a link 图片 表格]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java编程思想》]]></title>
    <url>%2F2018%2F07%2F02%2F%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[如果有耐心还是和我一样直接拿它入门吧，其中有些思想初学时不能理解，但就像滋养品对自身总是好的 Github 花了一个学期啃完了大部分内容，绝对说不上看懂，但至少他让我对Java有了正确的认识和较深的影响，这就是作者在叙述中透露出的思想，不着急一定要完全看懂它，一是确实现在的经验不够，二是我知道我一定会再读这本经典 我说说我为什么拿这本书入门，因为我目前的计划是熟练掌握Java和C，熟悉Python，所以对于Java的学习，我直接拿这本书来给自己一个高起点，事实证明确实还是有一定效果的，从这本书不仅能学到基础的Java知识点，而且它所呈现的出的Java是真实的，是不完美的，是有思想在其中的，而不是简单教会我们实现一个功能，而是教会我们如何优美的实现 第14章 类型信息 第15章 泛型 第17章 容器深入 第18章 Java I/O流 第20章 注解 第21章 并发]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《程序员修炼之道》]]></title>
    <url>%2F2018%2F07%2F02%2F%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[有些书初接触，觉得讲的都是什么啊，只有真正碰到，才能回想起书中讲的道理 大学还教面向对象，确实很落后了。好的大学应该培养学生的科学思维，而不像二三流学校培养程序员，解决就业问题 就像书中说的，每年学习一门新语言，一开始不以为然，现在学习了lisp、Python，发现对编程世界的看法都不一样了 第一次翻阅这本书的时候，也太泛泛而谈了，现在（处在困难晋升期）再来重新翻阅，突然体会到了一些书中所讲的含义。每一条原则都是为了提高程序员的工作效率。 又一次出现了原则一词，能不能让正确的原则指导正确的行动本身，其实是区分是否是高手的一个显著标志]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《程序员的自我修养》]]></title>
    <url>%2F2018%2F07%2F02%2F%E4%BF%AE%E5%85%BB-%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一本让我意外的书，从一个简单的helloworld开始，讲出了整本书。相对来说较薄的一本书，但仅仅看了第一章就让我理顺了线程和进程的由来。本以为这本书和CSAPP应该差不多，但很意外，研究生写的书也能这么棒，让我也有了写书的冲动 本书所讲的技术，大多成型在十年前，乃至二十年前，他们是整个计算机行业技术的根本，也几乎是现在所有计算机应用的基础。在当今计算机技术发生根本性变革之前，这些技术还将继续存在并保持活力 操作系统操作系统的一个功能就是提供抽象的接口，另一个功能就是管理硬件资源 开发工具和应用程序使用一个接口，即操作系统应用程序编程接口（Application Programming Interface），该接口的提供者是运行库（如Linux下的CLibc库提供POSIX的API） 运行库使用操作系统提供的系统调用接口（System Call Interface），该接口的实现往往以软件中断的方式提供 操作系统的内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者 CPU分配对于CPU的使用机制经历了以下几个历史阶段 多道程序：编写一个监控程序，当程序暂时无需使用CPU时，就把另外正在等待CPU资源的程序启动。这种机制的问题就在于调度机制过于粗糙，各种程序之间没有轻重缓急 分时系统：每个程序运行一段时间后都会主动让出CPU给其他程序，但这种系统遇到某个死循环程序，也只能等待，就导致系统整个看上去都死机了 多任务系统：操作系统接管了所有的硬件资源，本身运行在一个手硬件保护的级别。所有应用程序以进程的方式运行在比操作系统权限更低的级别上，每个进程都有自己的独立地址空间，使得进程之间地址空间相互隔离。CPU由操作系统统一分配，每个进程根据进程优先级获得CPU。当某个程序运行时间超过了一定时间，操作系统就会暂停该进程，把资源分配给其他程序，这种分配方式叫做抢占式 设备驱动对于操作系统上面的运行库和应用程序来说，它们希望看到的是一个统一的硬件访问模式。在操作系统成熟之前，应用程序的程序员就要直接和硬件打交道，之后硬件就被抽象成了一系列的概念。如在Unix中，所有硬件设备都被抽象为文件；在Windows中图形硬件被抽象为GDI，磁盘被抽象成为了普通文件系统。这些繁琐的硬件细节都交给了操作系统中的硬件驱动程序完成。驱动程序和内核一起运行在特权级上 虚拟内存早期计算机的程序是直接运行在物理内存上的，可以理解为编译好的程序直接写入了内存条，但是思考一个问题，运行在计算机中的程序肯定不止一个吧，每个程序占用一部分内存，自然就会产生内存不足的现象 这样直接使用物理内存的第一个问题就是内存使用效率不高，例如假设总共有50MB的内存，程序A使用10MB,这里需要明确一点的是程序内存的使用都是连续的，程序B使用30MB，程序C需要20M，显然要把程序A和B的数据都存入磁盘才可以去运行程序C，但是其实将程序A移除后，内存中就已经有20M空闲的内存，但却得不到利用，而且大量的数据在内存和磁盘中移动显然是低效率的 第二个问题就是安全问题，程序内存地址是不隔离的，程序之间可以很容易的访问相互之间的数据，这对于恶意程序显然是个好机会，通过轻易访问其他程序的内存，修改内存内容，执行破坏计算机的程序，想想都有点激动 第三个问题是地址空间的不确定性，每次运行程序对应的物理地址都是不确定的，这次可能是0x0000-0x1111,下次就可能是0x2222-0x3333，这种不确定性会给程序编写造成麻烦，例如如果了解汇编的话，程序跳转都是跳转到特定的地址，也就是说编译之后就会给出特定的内存地址 解决上述问题的方法就是增加中间层，也就是虚拟地址，并通过某些映射的方法（分段和分页），将这个虚拟地址转换成物理地址，这就是虚拟地址带来的好处，但是如果是物理地址就不能带来这种便利 分段即把一个程序所需要内存空间大小的虚拟空间映射到某个地址空间这种方法只解决上述问题中的地址隔离和地址不确定问题，但没有解决效率问题。 当程序访问虚拟地址超过了一定范围，硬件就会判断这是一个非法访问，拒绝这个请求，并将这个请求报告给操作系统，由它来决定如何处理 但是分段对于内存映射依旧是按照程序为单位，被换入换出的是整个程序，这就导致了大量的磁盘访问操作，影响效率。事实上根据程序的局部性原理，程序运行时，只会频繁使用一小部分数据，大部分数据并不会被用到，因此就采取了更小粒度的内存分隔和映射方法，也就是分页 分页把地址空间人为地等分成固定大小的页，每一页的大小由硬件决定或者硬件支持多种大小的页，由操作系统决定页的大小可以看到进程1某部分虚拟地址被映射到物理地址，一部分被映射到磁盘中。不同的进程可以映射到同一个物理页中，实现内存共享 当进程需要的页不在内存中时，硬件就会捕捉到这个信息，也就是页错误，然后操作系统就会接管进程，将对应的页从磁盘中读出来并装载到内存中，并建立物理页和虚拟页的映射关系 虚拟地址的实现需要硬件的支持，即MMU（Memory Management Unit）来进行页映射，页映射模式下，CPU发出的是Virtual Address，经过MMU转化后变成Physical Address，MMU一般都集成在CPU内部 线程一直在思考一个问题，既然有了进程的概念，为什么还要有线程的概念？现给出自己的答案 进程的缺点进程是为了CPU和硬件资源等方面提供的抽象，能够有效提高CPU的利用率。 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。 线程是什么线程是在进程这个层次上提供的一层并发的抽象，也被成为轻量级进程，是程序执行流的最小单位 一个标准的线程具有线程ID、当前指令指针、寄存器集合和堆栈等组成。C语言中的全局变量被映射到读写区域，任何线程都可以引用；本地自动变量（定义咋函数内部但是没有static属性的变量）被映射到每个线程的栈中；本地静态变量（定义在函数内部并有static属性的变量）映射到读写区域，每个对等线程都能读写该变量 可以有效地利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高 能够使系统在同一时间能够做多件事情，当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行，例如多线程可以让一个线程负责交互，另一个线程负责计算 多线程在数据共享方面效率更高 进程和线程区别进程和线程的并发层次不同：进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。 如果我们进入计算机体系结构里，就会发现，流水线提供的也是一种并发，不过是指令级的并发。这样，流水线、线程、进程就从低到高在三个层次上提供我们所迫切需要的并发！ 从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位 进程有独立的地址空间，线程没有单独的地址空间 启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右 线程间方便的通信机制 从函数调用上来说，进程创建使用fork()操作；线程创建使用clone()操作 访问权限从上图可以产看出，线程具有一些私有存储空间，如栈、线程局部存储（某些操作系统为线程单独提供的私有空间）和寄存器，线程之间共享的则有全局变量、堆上的数据、静态变量、程序代码和打开文件 线程调用与优先级当线程数量小于处理器数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上，彼此互不相干。但是当线程数量大于处理器数量的情况下，就会出现一个处理器运行多个线程的情况。 对于在单处理器上运行多线程情况下，并发是模拟出来的概念，操作系统会让程序轮流执行，每次执行几十到几百毫秒，这样就看起来在同时执行（联想数电仿真的波形图就能理解），这样不断切换不同线程的行为就称为线程调度 线程通常有三种状态 运行（Running） 就绪（Ready）：如CPU被占用 等待（Waiting）：线程正在等待某一事件（如IO）而无法执行 主流的线程调度都带有优先级调度和轮转法，Linux可以通过pthread库来进行相关设置，如设置线程优先级，这是第一种用户指定优先级改变 操作系统也会根据线程的表现自动调整优先级，IO密集型线程（即因为IO输出输出而频繁等待）比CPU密集型（经常要使用完时间片）更容易得到优先级提升 为了避免低优先级的线程始终无法得到执行，调度系统对逐步提升这种“饿死”线程的优先级，使其肯定会被执行 Linux多线程linux内核并不存在真正意义上的线程概念，所有执行实体（无论是线程还是进程）都称为Task。每个Task都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。linux中允许Task之间选择共享内存空间，因此共享了内存空间的Task构成了一个进程，而这些Tasks也就是线程 fork系统调用：复制当前进程，本任务的fork返回新任务的pid，而新任务的fork返回0，fork并不复制原任务的内存空间，而是和原任务一起共享一个写时复制（Copy on Write，COW）的内存空间，可以理解为延迟复制，只当任意一个任务试图修改内存时，才会复制内存空间给任务单独使用。fork是最简单的调用，不需要任何参数，仅仅是在创建一个子进程并为其创建一个独立于父进程的空间，即产生本任务的镜像，要exec配合才能够启动别的新任务，这两个配合通常用于产生新任务 线程安全自增在多线程环境下会出现错误是因为这个操作被编译为汇编代码之后不止一条指令，因此可能在执行到一半就被调度系统打断，去执行别的代码。 锁单指令的操作成为原子操作，但原子操作只适用于简单场合，复杂场合就会显得力不从心，因此使用更加通用的锁 每个线程在访问数据之前先试图获取锁，并在访问结束之后释放锁，在锁被占用的时候试图获得锁时，线程就会等到，直到锁重新可用 二元信号量：最简单的一种锁，只有占用和非占用两种状态 信号量：即多元信号量，用在允许多个线程并发访问的资源上，初始值为N的信号量允许N个线程并发访问 互斥量：类似于二元信号量，但是信号量可以被系统任意线程获取并释放，互斥量要求哪个线程获取，哪个线程释放，更加严格 临界区：临界区比互斥量更加严格，临界区的作用范围仅限于本进程，其他进程无法获取该锁，而对于互斥量和信号量，系统任何进程都是可见的、可获取的 读写锁：虽然对于读写同步来说，信号量、互斥量和临界区都能实现目的，但是对于读取频繁，仅仅偶尔写入的情况，会显得很低效，读写锁则可以避免这个问题，读写锁分为读锁和写锁，且有两种获取方式：共享的和独占的 条件变量：类似于栅栏，使用条件变量可以是许多线程一起等待某个事件的发生，当事件发生时（条件变量被唤醒），所有线程一起恢复执行 可重入函数重入：重复进入，即该函数被调度系统中断后，再一次进入该函数，不会产生不良后果，就称这个函数是可重入函数 可重入函数的一些特点： 不使用任何（局部）静态或全局的非const变量 不返回任何（局部）静态或全局的非const变量指针 仅依赖于调用方提供的参数 不依赖任何单个资源的锁 不调用任何不可重入函数 一个可重入函数可以在多线程环境下放心使用 过度优化落后的编译器技术无法满足日益增长的并发需求，编译器可能会为了提高变量的访问速度，而把变量放到某个寄存器中，而不是放在内存中，但不同的线程的寄存器是各自独立的，因此就会出现以下问题1234567891011x = 0;//Thread 1lock();x++;unlock();//Thread 2lock();x++;unlock(); 编译器这个程序看起来并没有问题，但是问题出在了自作聪明的编译器中，它可能会把x放在寄存器中，这样就可能出现x=1的情况，为此可以使用volatile关键字阻止这种不同步类型的过度优化，这个关键字可以做到以下两件事 阻止编译器为了提高速度将一个变量缓存到寄存器而不写回内存 阻止编译器调整操作volatile变量的指令顺序 CPU另一种问题则是因为CPU的动态调度或者说是乱序执行，在执行程序的时候为了提高效率有可能交换指令的顺序123456789x = y = 0;//Thread 1x = 1;r1 = y;//Thread 2y = 1;r2 = x; CPU对于这种不相干的指令，就可能出现下面顺序，这样完全可能出现r1=r2=0的情况，而这种情况volatile是不能解决的123456789x = y = 0;//Thread 1r1 = y;x = 1;//Thread 2y = 1;r2 = x; 为了阻止CPU换序，可以调用CPU提供的一条指令barrier，该指令会阻止CPU将barrier指令之前的指令交换到barrier之后，类似于一个拦水坝 线程模型用户实际使用的线程并不是内核线程，而是存在于用户态的用户线程，用户态线程并不一定在操作系统内核上对应同等数量的内核线程 一对一模型一个用户态线程就唯一对应于内核线程，但内核线程不一定对于一个用户态线程，一般使用API或系统调用产生的线程都是一对一线程，如linux的clone 一对一模型的缺点： 许多操作系统限制了内核线程的数量，因此一对一线程也会让用户线程的数量受影响 内核线程调度时，上下文切换的开销大，导致用户线程的执行效率下降 多对一模型多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，上下文切换成本低，无限制的线程数量 缺点： 一个用户线程阻塞，就会导致所有线程阻塞，因为内核线程也随之阻塞 多处理器对该模型没有明显帮助 多对多模型该模型则是结合了上述两种模型的特点 章节目录 《目标文件》 《装载与共享库》：正在整理 《静态链接》：待整理 《动态链接》：待整理 《库与运行库》：待整理]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》]]></title>
    <url>%2F2018%2F06%2F30%2F%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[我想只有真正热爱的人才会把Hacker和画家联系在一起。编程是一种艺术创作，而黑客是艺术家，他和画家作画、建筑师设计房子没有本质不同。而任何一种艺术，不管是否重要，如果想要在该领域出类拔萃，就必须全身心投入 今天（2019.1.15）重新翻阅这本书，想把这本书的书评完善。随手一翻，发现译者竟然是阮一峰，好熟悉的名字啊，就去上网搜索，于是乎就发现了新大陆，发现了一群像他一样，诗人一般的程序员。每个突出的程序员都不只是一个技术宅男，而是有思考、充满情怀的天才 看书之前应该好好了解这个作者Paul Graham，了解他的投资、创业哲学0 想要把握这个时代，就要理解计算机，而理解计算机的关键就在于理解计算机背后的人。正是这群人决定了我们所能看见的软件界面的审美 hacker一词从一开始就不是如今媒体和大众眼里只会侵入计算机的人，而是从事hacking，也就是以一种高度革新、独树一帜的风格和方式来解决一个计算机难题的人。hacker不仅是一流能力的象征，还包含了解决问题过程中产生的精神愉悦或享受。黑客行为必须包含好玩、高智商、探索精神，黑客追求的是这三种价值，而不是金钱或者权利。黑客不服从管教，具有叛逆精神，行为怪异和愤世嫉俗，但不是反社会，搞破坏的人 初高中心思都不在读书上，因为传统的教育体制让自己反感，以至于错过了一些自己本应该学习的东西，现在在大学，自己成了父母口中的“书呆子”，我觉得这样挺好的，让我意识到学校并非全部的人生，只是一个认为设计出来的让成年人能腾出手去做其他事的地方，我的心思绝不在这区区校园之内 大公司为了避免设计上的灾难，选择了减少设计结果的标准差，但是当排斥差异的时候，不仅将失败的可能性派出排除在外，也将获得高利润的可能性排除在外。真正竞争软件设计的战场是新兴领域的市场，这里没有大公司建立防御工事，只要大胆的设计，就有可能战胜大公司。这条准则让我想起了最近头条、快手等同时发布新的聊天软件想要进攻微信，这不就是犯了这条错误，选择和已经建立了巩固的市场、技术壁垒的大公司硬碰硬，结果肯定是头破血流 黑客为了让自己能做自己喜欢的事情，可以选择一份养家糊口的“白天工作”，然后在其余时间开发优美的软件。这种工作方式也是如今很多开源界的黑客所做的 黑客和很多创作者一样，靠动手实践来学习。但是黑客不同的是，他从一开始就是原创性工作，没有他人的成果可以依靠。第二种方法就是通过范例，就像富兰克林通过模仿让他人的文章，学会了写作，黑客应该通过观看优秀的程序（看源码）学会编程 不要期望着动手前有一个完美的规格设计，而是要在编程的过程中，不断修改设计，这样最终会有一个更好的设计。优秀的黑客应该对代码的美有狂热的追求，软件要比它使用的感觉更加优秀，就像乔布斯设计电脑，不仅对外观有极致的追求，对于内部的电路板也是极其严苛 普通黑客和优秀黑客的所有区别之中，最重要的因素可能是“换位思考”，能否从用户的角度思考问题，是否知道向没有技术背景的人解释技术问题 历史的常态就是，任何一个年代的人们，都会对一些荒谬的东西深信不疑，他们的信念还很坚定，只要有人稍微表示一点怀疑，就会惹来大麻烦。包括自己现在所坚持的一些原则和信念，对于未来的人来说，可能就是荒诞不经 大庭广众之下，你有没有什么观点不愿说出口？如果没有，可能说明自己是个随大流的人，没有自己的独立思考。不能说出口的话一定是正确的或者说正确与否会引起人们的思考，而这种话或思考会激怒一部人 永远质疑。几乎所有人都会说自己“心态开放，愿意接受新思想”，但是如果你是思想保守的人，你自己不会知道，也会认为自己思想开放。流行的本质就是自己看不见自己的样子。时间和空间是产生距离去观察流行和人们观念变化的唯二法则。当你想要清晰地思考，就必须远离人群，但这样受到的阻力会越来越大，因为你成长为了一个怀疑和地址社会错误潮流的人。当自己是潮流的一部分时，怎能看清潮流的方向呢？ 黑客的本性是不服从管教和自负的。他们很关注公民自由，公民自由不仅仅是社会制度的装饰品，也是国家富强的原因。一个拥有言论自由和行动自由的社会，往往能采纳最优方案。政府对公民自由限制不断上升，政府的力量会先增加后减少。这提醒我们，正是那些不服从管教的人，才是力量的源泉，这种不服从管教的精神应该始终保持活跃 未来互联网软件将不断迁移到服务器上，用户界面就是网页，用户不需要知道软件版本，只需要键盘、屏幕和浏览器就够了，只有用户密集互动的软件才把数据处理的部分放在桌面上。这和当前“大前端”和云的趋势不谋而合。未来数据都会保存在云端服务器上，所有用户使用相同版本的云端软件，这种软件和当今的桌面软件不同在于：前者是不同种类程序的集合，后者就是一个巨大的二进制文件，前者是一座城，后者是一栋楼。对于互联网软件的开发，可以同时使用多种编程语言，没有谁可以限制自己，因为整个硬件、整个服务器都掌握在自己手里。除此之外，这种互联网软件的发布也是随心所欲，连续性渐变的，没有版本的概念。软件BUG的排查也交给用户去完成，修复快，不容易产生复合型代码。函数性编程非常适合这种小幅的修改和测试，因为他不包含状态 如何制作用户喜欢的产品 从制造简洁的产品着手，保证自己愿意使用 密切听取用户的反馈，但要自己判断，不要盲从 比较软件的标准应该是看对手的软件将来会有什么功能，而不是现在有什么功能 不要害怕大公司，不要害怕竞争，大公司能做到黑客做不到的，黑客也能做到大公司做不到的 Hacker Ethic Access to computers-and anything that might teach you something about the way the world works-should be unlimited and total.Always yield to the Hands-On Imperative! All information should be free. Mistrust Authority-Promote Decentralization. Hackers should be judged by their hacking,not bogus criteria such as degrees,age,race,or position. You can create and beauty on a computer. Computers can change your life for the better.]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章：网络编程]]></title>
    <url>%2F2018%2F06%2F09%2FCSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[网络应用中，进程、信号、字节顺序、内存映射以及动态内存分配都扮演重要角色。我们要理解基本的客户端-服务器编程模型，编写使用因特网提供的服务的客户端-服务器程序，最后将所有概念结合，开发一个虽小但功能齐全的Web服务器，为真实的Web浏览器提供静态和动态的文本和图形内容 网络模型所有网络应用都基于相同的基本编程模型：客户端-服务器模型，有着相似的整体逻辑结构，并且依赖相同的编程接口 在这个模型中，一个应用是由一个服务器进程和多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源为客户端提供某种服务。例如Web服务器管理一组磁盘文件，它代表客户端进程检索和执行；FTP服务器管理一组磁盘文件，它替客户端进行存储和检索；电子邮件服务器管理一些文件，它替客户端进行读和更新 认识到客户端和服务器是进程，而不是主机。一台主机可以同时运行不同的客户端和服务器。无论客户端和服务器怎么映射到主机上，该网络模型都是不变的 网络网络是很复杂的系统，这里只学习皮毛 对主机而言，网络只是有一种I/O设备。从网络上接受到的数据从适配器经过I/O和内存总线复制到内存 以太网从物理上将，网络是一个按照地理远近组成的层次系统。最低层是局域网（Local Area Network，LAN），最流行的局域网技术是以太网 一个以太网段包括一些电缆和一个集线器，常跨越小的区域，如一个楼层、一栋建筑等。电缆的一端连接主机的适配器，另一端连接集线器的端口。集线器不加分别的将一个端口上收到的每个位复制到所有端口，因此每个主机都能看到每个位 每个以太网适配器都有一个全球唯一的48位地址。主机发送帧到这个网段的任何主机，每个帧包含一些头部位，标志帧的源和目的地址以及帧的长度，随后就是数据位的有效载荷，每个主机适配器都能看到这个帧，但只有目的主机实际读取 利用电缆和网桥，多个以太网段可以组成更大的局域网，称为桥接以太网 互联网络在层次更高级别中，多个不兼容的局域网可以通过路由器的特殊计算机连接起来，组成internet。由此连接起来的成为广域网（WAN） 互联网络至关重要的特性是，他能由采取不同和不兼容技术的各种局域网和广域网组成。每台主机和其他主机都是物理相连，如何能够让某台源主机跨过所有不兼容的网络发送数据到目的主机呢？ 解决办法就是一层运行在主机和路由器上的协议软件。这种软件实现一种协议，这种协议控制主机和路由器如何协同工作来实现数据传输，这种协议必须提供两种基本能力： 命名机制：不同的局域网采取不同和不兼容的方式来为主机分配地址，互联网络通过定义一致的主机地址格式来消除差异。每台主机分配至少一个互联网络地址来标记自己 传送机制：互联网络通过定义一种把数据位捆扎成不连续的包的方式，消除差异，一个包由包头和有效载荷组成，其中包头包含包的大小和源主机以及目的主机的地址 具体流程参考《计算机网络》，互联网思想的精髓就是封装 IP因特网每个因特网主机都运行实现TCP/IP协议的软件。因特网的客户端和服务器混合使用套接字接口函数和Unix I/O函数来进行通信，通常套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的TCP/IP函数 TCP/IP实际是一个协议族。IP协议提供基本的命名方式和递送机制，这种递送机制能够从一台因特网主机往其他主机发送数据报，但不是可靠地。UDP则稍微扩展了IP协议，这样数据报可以在进程间而不是主机间传送。TCP则是构建在IP之上的复杂协议，提供了进程间可靠地全双工连接 IP地址IP地址就是一个32位无符号整数，但却放在一个结构中，因为这是套接字接口早期实现的不幸产物 主机可以有不同的主机字节顺序，TCP/IP为任意整数数据项定义了统一的网络字节顺序（大端字节顺序），即使主机字节顺序是小端法。Unix提供了载网络和主机字节顺序间转换的函数 IP地址使用一种点分十进制的表示法来表示，Unix提供了IP地址和点分十进制之间转换的函数 域名因特网提供一组人性化的域名，以及一种将域名映射到IP的机制。这个映射是通过分布世界范围内的数据库（DNS）维护的，可以使用NSLOOKUP来查看，具体参见《计算机网络》 因特网连接一个套接字是连接的断点，每个套接字都有相应的套接字地址，由一个因特网地址和一个16位的整数端口组成 当客户端发起一个连接请求，客户端套接字地址中的端口是由内核自动分配的，然后服务器的端口通常是某个知名端口，是和这个服务相对应的，例如web服务器通常的端口是80。/etc/services包含了一张这台机器提供的知名服务和端口之间的映射 一个连接由两端的套接字地址唯一确定，称为套接字对 套接字接口套接字接口是一组函数，与Unix I/O函数结合起来，用于创建网络应用 下图是典型的客户端-服务器事务的上下文中的套接字接口概述 从Linux内核的角度来看，一个套接字就是通信的一个端点，从Linux程序的角度来看，套接字就是由相应描述符的打开文件 socket服务器和客户端使用该函数创建一个套接字描述符，如下1clientfd = socket(AF_INEF,SOCK_STREAM,0); AF_INEF表示使用的是32位地址，SOCK_STREAM表示这个套接字是连接的一个端点。socket返回的clientfd描述符是部分打开的，不能用于读写，如果完成打开套接字的工作，取决于是客户端还是服务器 connect客户端通过调用connect函数来建立和服务器的连接12int connect(int clientfd,const struct sockaddr *addr, socklen_t addrlen); 该函数会阻塞，一直到连接成功建立或者发生错误，如果成功，clientfd描述符就准备好读写了 bind剩下的套接字函数（bind、listen、accept），都是服务器用来和客户端建立连接12int bind(int sockfd,const struct sockaddr *addr, socklen_t addrlen); 该函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来 listen默认情况下，内核认为socket函数创建的描述符对应于主动套接字，它存在于一个连接的客户端，服务器调用listen函数告诉内核，描述符是被服务器而不是客户端使用1int listen(int sockfd,int backlog); 该函数将sockfd从一个主动套接字转化为一个监听套接字，该套接字接受来自客户端的连接请求。backlog参数暗示内核开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量 accept服务器调用该函数来等待来自客户端的连接请求 12int accept(int listenfd,struct sockaddr *addr, int *addrlen); 该函数等待来自客户端的连接请求到达侦听描述符listenfd，然后在addr中填写客户端的套接字地址，并返回一个已连接描述符，该描述符可以利用Unix I/O函数与客户端通信 监听描述符和已连接描述符的区别： 监听描述符是作为客户端连接请求的一个端点，被创建一次，存在于服务器的整个生命周期 已连接描述符是客户端和服务器之间已经建立起来的连接的一个端点 区别这两种描述符是为了建立并发服务器，能够同时处理多个客户端连接 getaddrinfo该函数将主机名、主机地址、服务名和端口号的字符串转化为套接字地址结构 123int getaddrinfo(const char *host,const char *service, const struct addrinfo *hints, struct addrinfo **result); 规定host和service，该函数返回result，result是指向addrinfo结构的链表 客户端调用该函数之后，会遍历这个列表，依次尝试每个套接字地址，直到调用socket和connect成功，建立起连接。类似的，服务器也会尝试遍历列表的每个套接字地址，知道socket和bind成功，描述符会被绑定到一个合法的套接字地址 具体参数解释和链接结构参见书本P657-658 getnameinfo该函数作用和getaddrinfo相反，将一个套接字地址结构转换成相应的主机和服务名字符串123int getnameinfo(const struct sockaddr *sa,socklen_t salen, char *host,size_t hostlen, char *service,size_t servlen,int flags); 下面的函数都是对上面的函数的封装 open_clientfd客户端调用该函数建立与服务器的连接，服务器运行在主机hostname上，并在port端口号上监听连接请求，他返回一个打开的套接字描述符1int open_clientfd(char *hostname,char *port); open_listenfd服务器调用该函数，创建一个监听描述符，准备好接受连接请求 Web服务器HTTP是基于在因特网连接上传送的文本行的，可以使用linux上的TELNET程序来和因特网上的任何web服务器执行事务 具体细节参考其他文章 服务动态内容这一需求引申出了很多问题： 客户端如何将程序参数传递给服务器？ 服务器如何将这些参数传递给它所创建的子进程？ 服务器如何将子进程生成内容所需要的其他信息传递给子进程？ 子进程将输出结果发送到哪里？ 上述问题都可以通过CGI（Common Gateway Interface，通用网关接口）的标准来解决 服务器在接收到一个请求后，如GET /cgi-bin/adder?15000&amp;213 HTTP/1.1，它调用fork来创建子进程，并调用execve在子进程的上下文中执行/cgi-bin/adder程序，像这样的程序，常常被称为CGI程序，因为它遵守CGI标准的规则 在调用execve之前，子进程将CGI环境变量QUERY_STRING设置为”15000&amp;213”，adder程序在运行时可以用linux getenv函数来引用它 CGI定义了大量的环境变量，一个CGI程序可以在运行时设置或使用这些变量 SERVER_PORT：父进程侦听的端口 REQUEST_METHOD：GET或POST REMOTE_HOST：客户端的域名 … 一个CGI程序将它的动态内容发送到标准输出，在子进程加载并运行CGI程序之前，它使用dup函数将标准输出重定向到和客户端相关联的已连接描述符，因此CGI写入标准输出的东西就会直接到达客户端 因为父进程不知道子进程生成的内容和类型或者大小，所有进程要负责生成Content-type和Content-length响应报头，以及终止报头的空行 综合接下来要开发称为TINY的服务器，在短短250行代码中，它结合了例如进程控制、Unix I/O、套接字接口和HTTP，虽然缺乏实际服务器具备的功能性、健壮性和安全性，但是当使用实际浏览器指向自己的服务器，依旧足够令人兴奋！！！ mainTINY是一个迭代服务器，监听在命令行传递来的端口上的连接请求 在调用open_listenfd函数打开一个监听套接字之后，就执行无限服务器循环，不断接受连接请求 doit该函数处理HTTP事务 TINY只支持GET方法，如果客户请求其他方法，将发送错误信息，并返回到主程序，主程序随后关闭连接并等待下一个连接请求 然后我们将URI解析为一个文件名和一个可能为空的CGI参数字符串，并设置一个标志，表明请求时静态内容还是动态内容，如果文件在磁盘不存在，立即发送一个错误信息给客户端并返回 最后，如果请求的是静态内容，就验证该文件是普通文件，而我们有读权限，如果是这样就向客户端提供静态内容，如果请求的是动态内容，就验证文件是可执行文件，如果是这样就提供动态内容 clienterrorTiny会检查一些明显的错误，并报告给客户端 该函数会发送一个HTTP响应给客户端，在响应行中包含相应的状态码和状态信息，相应主题包含一个HTML文件，向浏览器的用户解释这个信息。HTML响应中还应该指明主体内容的大小和类型 read_requesthdrsTINY不使用请求报头的任何信息，仅仅调用该函数来读取并忽略这些报头 parse_uriTINY假设静态内容的主目录就是当前目录，而可执行文件的目录是./cgi-bin，任何包含字符串cgi-bin的URI都被认为表示的是对动态内容的请求，默认的文件名是./home.html serve_staticTINY提供五种常见类型的静态内容：HTML、无格式文本文件、GIF、PNG和JPG 该函数发送一个HTTP相应，其主体包含一个本地文件的内容。首先通过检查文件的后缀来判断文件类型，并且发送响应行和响应报头给客户端 接着，我们将被请求文件的内容复制到已连接描述符来发送响应主题。这里，需要仔细研究。首先open函数以只读方式打开文件，并获得描述符，再使用mmap函数将被请求文件映射到一个虚拟内存空间（该函数在第九章讲解） 一旦文件映射到内存，就不再需要他的描述符，而是需要文件开始的地址。最后调用函数从该地址开始复制filesize个字节到客户端的已连接描述符，最后释放映射的虚拟内存区域，避免潜在的致命的内存泄漏 serve_dynamicTINY通过派生一子进程上的上下文来运行CGI程序 子进程重定向它的标准输出到已连接文件描述符，并加载运行CGI程序。因为CGI运行在子进程的上下文中，它能够访问所有在调用execve函数之前就存在的打开文件和环境变量，因此CGI写到标准输出的东西都将直接送到客户端进程，不会受到任何来自父进程的干涉。期间，父进程阻塞，等待子进程终止，回收子进程的资源 运行网上的教程连编译命令都是错的，害人！ 将tiny.c csapp.h csapp.c放在同一个文件夹下面，并创建home.html 编译xzy@ubuntu:gcc tiny.c -lpthread，然后运行xzy@ubuntu:./a.out 1024 如上所示，默认界面就是home.html 命令行中输出HTTP请求报文头访问不存在的资源使用telnet获取数据使用不支持的HTTP请求获取数据 源代码]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F06%2F01%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树是一种自平衡的二叉查找树，是一种高效的查找树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。因此红黑树在业界应用很广泛，比如Java中的TreeMap，JDK 1.8中的HashMap、C++ STL中的map均是基于红黑树结构实现的 红黑树的定义 节点是红色或黑色 根是黑色 所有叶子都是黑色（叶子是NIL节点） 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 红链接均为左链接 没有任何一个结点同时和两条红链接相连 完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机程序的构造和解释》]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%E3%80%8B%2F</url>
    <content type="text"><![CDATA[在每个钟匠眼里，钟都是有灵魂的。跟随这本书，我们可以找到寄住在计算机中的灵魂代码 本书讨论三类对象：人脑，计算机程序集合和计算机本身，每个计算机程序都是人脑中模型的一个化身，是由人脑孵化出来的。人们通过程序去模拟现实中事物，但却很难模拟到一个令人满意的程序，存在各种BUG。因此需要不断修改程序，来适应模型。然而随着程序的不断增大，其可靠性和正确性就很难通过形式化的方法去证明，因此需要正确的组织方法来确保搭建大程序的每一步都是正确的，这一项技术就是本书前两章讨论的重点 一定要抓住这本书要讲的重点：计算机程序的构造与解释，不要小看这几个单词，自己看到一半的时候才意识到自己一直从底层的思维去看这本书，就理解的很困难，这本书是关于计算机程序的构造与解释的，要转变自己的思维 其次，也许是这本书太有名，以至于我忽略了书名本身体现的信息，构造与解释，前两章讲述怎么构造程序，后三章将怎么解释一个程序，这不就是编译原理要讲解的东西嘛！之前看后几章都是一知半解的感觉，现在至少知道要讲些什么了，趁着学习编译原理，在好好看看后三章 第一章 过程抽象 第二章 数据抽象 第三章 模块化、对象和状态 第四章 元语言抽象 第五章 寄存器机器里的计算]]></content>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章：虚拟内存]]></title>
    <url>%2F2018%2F05%2F28%2FCSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[看完这章但是直到现在才去总结，确实是因为对虚拟内存的理解不够，可当我看了《程序员的自我修养》，有种豁然开朗的感觉，至少对虚拟内存的由来有了了解 概述早期计算机的程序是直接运行在物理内存上的，可以理解为编译好的程序直接写入了内存条，但是思考一个问题，运行在计算机中的程序肯定不止一个吧，每个程序占用一部分内存，自然就会产生内存不足的现象，这样直接使用物理内存的第一个问题就是内存使用效率不高，例如假设总共有50MB的内存，程序A使用10MB,这里需要明确一点的是程序内存的使用都是连续的，程序B使用30MB，程序C需要20M，显然要把程序A和B的数据都存入磁盘才可以去运行程序C，但是其实将程序A移除后，内存中就已经有20M空闲的内存，但却得不到利用，而且大量的数据在内存和磁盘中移动显然是低效率的 第二个问题就是安全问题，程序内存地址是不隔离的，程序之间可以很容易的访问相互之间的数据，这对于恶意程序显然是个好机会，通过轻易访问其他程序的内存，修改内存内容，执行破坏计算机的程序，想想都有点激动 第三个问题时地址空间的不确定性，每次运行程序对应的物理地址都是不确定的，这次可能是0x0000-0x1111,下次就可能是0x2222-0x3333，这种不确定性会给程序编写造成麻烦，例如如果了解汇编的话，程序跳转都是跳转到特定的地址，也就是说编译之后就会给出特定的内存地址，这就是虚拟地址带来的好处，但是如果是物理地址就不能带来这种便利 为了解决上述三个问题，就是在物理内存和程序之间引入一个抽象层，也就是虚拟内存，这就引出了这章要讲解的内容。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互 虚拟内存是核心，遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程都是重要核心 虚拟内存可以创建和销毁内存片（chunk），将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存 经常遇到Segment fault，理解虚拟内存和例如malloc之类管理虚拟内存的分配程序，可以避免这些错误 这章先讲解虚拟内存的实现原理，之后结合Linux讲解，然后还会有一个有一个malloc实验，号称是CSAPP Lab中最难的一个，当然我还没有完成 虚拟内存物理地址：计算机的主存被组成一个由M个连续字节大小的单元组成的数组，每个字节都有唯一的物理地址。CPU使用这种地址就叫做物理寻址 现代操作系统使用虚拟寻址，CPU生成的是虚拟地址（Virtual Address，VM），由MMU翻译成物理地址。地址翻译需要硬件和操作系统紧密合作。CPU上有内存管理单元（MMU）利用存放在主存上的查询表来动态翻译虚拟地址，该表的内容有操作系统内核管理 地址空间在一个带虚拟地址的系统中，CPU在一个$N=2^n$个地址的地址空间生成虚拟地址，每个地址空间称为虚拟地址空间。这里的$n$就是地址空间大小，也就是常说的系统是32位还是64位 地址空间的概念成功区分了数据对象（字节）和它们的属性（地址）。虚拟内存的基本思想就是允许每个数据对象有多个独立的地址，每个地址都选自不同的地址空间。因此对于主存中的字节都有一个来自虚拟地址空间的虚拟地址和一个来自物理地址空间的物理地址 缓存逻辑上讲，虚拟内存被组成一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。磁盘上的数据被缓存到主存中。因为磁盘和主存的传输单元为块，VM系统通过将虚拟内存分为虚拟页（VP）大小的固定块来做统一，同样物理页（PP）也分割为同样大小的块，称为页帧 为了讨论清晰，用SRAM缓存表示位于CPU和主存之间的L1、L2和L3高速缓存，用DRAM表示虚拟内存系统的缓存，它在主存中缓存虚拟页 页表虚拟内存系统需要判断虚拟页是否缓存在DRAM中，并确定是在哪个物理页上，如果没有缓存，系统要判断存放在磁盘的位置，并将其复制到DRAM中 这些功能需要操作系统软件、MMU中的地址翻译软件和一个存放在物理内存中的叫做页表（Page table）的数据结构联合提供。下图展示了页表的组织结构 CPU输出一个VA到MMU的地址翻译硬件，其将VM作为一个索引来定位在页表中的位置（如定位到了PTE 2），由于PTE 2的有效位为1，地址翻译硬件就知道要找的数据就存放在DRAM中，也就是命中，之后就会使用有效位接下来的物理内存地址，构造数据的物理地址 如果没有命中，也就是虚拟地址索引的PTE有效位为0，就发生缺页异常，这会调用内核中的缺页异常调用程序。程序会在DRAM中选择一个牺牲页，将其复制回磁盘，并修改页表。接下来就是根据磁盘地址从磁盘中把缺页复制到内存中。当异常处理程序返回时，就会重启导致缺页的指令。这种直到不命中时，才将页从DRAM换入或换出磁盘的策略就叫按需页面调度 虽然页面调度的处罚代价非常高，但是虚拟内存工作的非常好，因为局部性。因此只要程序有良好的时间局部性，虚拟内存系统就能工作的相当好 内存管理虚拟内存不仅仅是提供比DRAM更大的页面，而是能简化内存管理，提供内存保护 实际上，操作系统为每个进程都提供了一个独立的页表，也就是独立的虚拟地址空间。如下图 按需调度和独立的虚拟地址空间简化了很多方面，如 简化链接：独立的地址空间使得每个进程的内存映象都有相同的基本格式。这简化了链接器的设计与实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存的最终位置的 简化加载：要把目标文件中的.text等节加载到新创建的进程中，Linux加载器为代码和数据段分配虚拟页，即在页表中添加一个PTE，并标记为无效，将页表条目指向目标文件位置 简化共享：操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而实现代码共享 简化内存分配：当调用例如malloc时，操作系统分配适当大小的虚拟内存页面，并映射到物理内存中相同大小的任意位置上的物理页面 现代计算机系统不允许用户进程修改只读代码段，不允许修改内核代码，不允许读写其他进程的私有内存，不允许修改与其他进程共享的页面，除非通过调用显式的进程间通信系统调用 在一条PTE中，除了有效位外，还有许多标志位，控制读写许可。如果指令违反了这些许可条件，CPU就会触发一个一般保护故障，将控制传给内核中的异常处理程序，Linux shell将这种异常报告为Segmentation fault 地址翻译地址翻译是一个$N$元素的虚拟地址空间（Virtual Area Space，VAS）中的元素和一个$M$元素的物理地址空间（PAS）中元素的映射 如下图，CPU中有一个页表寄存器（PTBR），指向当前页表，虚拟页号根据当前页表找到PTE，MMU根据得到的PPN和PPO组合出新的物理地址 如下图，当页表命中时，完全是由硬件在处理。MMU根据虚拟地址和当前页表寄存器值得出PTE的地址，并送给Cache/主存，返回PTE之后，如上图所示组合得到物理地址，再一次向主存/Cache请求，得到数据 当发生缺页时，就要硬件和操作系统内核协作完成。MMU首先检测到得到的PTE的有效位为0，就会触发异常，CPU检测到这个异常，就会根据异常表，跳转到内核的缺页异常处理程序，由内核来将缺页读入主存，最后处理程序返回，CPU重新发送缺页指令 为了消除MMU每次都要向内存查询PTE，通常在MMU中设置一个关于PTE的小缓冲（Translation Lookaside Buffer，TLB），这样读取PTE的周期从几百个降到了几个 多级页表这种方式减少了内存要求，第一如果第一级页表中的PTE为空，相应的二级页表就不会存在，第二只有一级页表总是存在主存中，二级页表只在需要时创建，并缓存在主存中 内存映射Linux通过一个虚拟内存区域与一个磁盘对象关联起来，以初始化这个虚拟内存区域的内容 进程使用该mmap函数创建新的虚拟内存区域，并将对象映射到这些区域中12void *mmap(void *start,size_t length,int prot,int flags, int fd,off_t offset); 动态内存分配使用动态内存分配器具有更好的移植性。显式分配器就是类似于C中的malloc，隐式分配器就类似于Java中的垃圾回收9 动态内存分配器维护着一个进程的虚拟内存区域，称为堆 垃圾回收也是一种动态内存分配器，它自动释放程序不再需要的已分配块 内存错误内存出错总是让人恐惧的，因为它在时间和空间上，都距离错误出现的源头有一段距离]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>虚拟内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章：异常控制流]]></title>
    <url>%2F2018%2F05%2F26%2FCSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[《CSAPP》第八章：异常控制流 理解ECF的作用 异常 Linux的异常 进程 系统调用错误处理 进程控制 Linux信号 非本地跳转 控制流的定义：程序计数器中保存有一个关于指令地址的序列，从序列中的第k项转移到第k+1项称为控制转移，这样的序列就叫做控制流 程序内部的语句会对指令造成变化，与此同时，系统在必要的时候也要对系统状态做出反应，也会对指令做出变化，这些变化的改变和所写程序并不一定相关，造成突变的控制流我们成为异常控制流（ECF，Exceptional Control Flow），这个概念发生在计算机系统的各个层次当中 硬件层：当硬件检测的事件发生变化时，会触发异常处理程序 操作系统层：内核通过上下文切换，将控制从一个用户转移到另一个用户上 应用层：一个进程可以发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序 软件异常：一个程序可以回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来应对错误 理解ECF的作用 对理解虚拟内存、I/O、进程等有帮助 理解应用程序和操作系统的交互 编写Unix Shell和Web服务器等应用 理解并发 理解C++和Java中异常机制的实现 异常异常是ECF的一种形式，指控制流的突变，用来响应处理器状态中的某些变化 首先处理器中会保存有状态的编码，当状态变化（即事件）时，如发生虚拟内存缺页，算术溢出时，都会导致编码的变化（即状态），处理器会通过一张叫异常表的跳转表，进行间接过程调用（异常），到一个专门设计用来处理状态变化的程序中，程序执行完后，根据事件的类型决定接下来做什么 异常处理程序将控制返回给事件发生时执行的指令 将控制返回给事件发生时执行的指令的下一条指令 直接中断程序 异常表系统对每种可能出现的异常都分配了一个唯一的非负整数异常号，前一部分由处理器设计师分配，如零除，缺页，内存访问违例，其他号码由操作系统内核设计师分配，如系统调用和外部I/O信号异常表中的表目k就对应着异常k的处理程序代码的地址，异常表的起始地址放在一个叫做异常表基址寄存器的特殊寄存器中当处理器检测到事件的发生，并确定事件发生对应的异常号后，处理器通过执行间接过程调用，触发异常，并通过异常表上的对应程序进行处理 异常和过程调用的区别 异常处理程序运行在内核模式下，因此对系统资源有完全的访问权限 处理程序如果从用户程序转移到内核，则处理程序将被压入内核栈中，而不是用户栈中 处理器会把一些额外的处理器状态压入栈中，当重新执行程序时需要这些状态 过程调用在跳转到处理程序之前，将返回地址压入栈中，异常处理则根据类型，返回地址要么是当前指令，要么是下一条指令 分类异步异常是指是来自处理器外部的I/O设备的信号的结果，不是由任意一条专门的指令造成的，同步异常是执行一条指令的直接产物 中断该异常是异步的，例如网络适配器、磁盘控制器等向处理器芯片的一个引脚发送信号，并将异常号放在系统总线上，当当前指令完成执行后，处理器注意到引脚电压升高，就从系统总线读取异常号，并调用适当的中断处理程序，完成后，将控制返回给下一条指令，继续执行。 陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用，用户经常需要向内核请求服务，如读一个文件（read）， 创建新的进程（fork），终止当前进程（exit）。为了允许用户对内核服务的受控访问，处理器提供一条syscall n指令，执行该指令会导致一个到异常处理程序的陷阱，该处理程序能解析参数n，并调用内核程序。写程序的时候，系统调用和普通的函数调用并没有什么不一样，但实际上的实现却大不一样，主要区别在于一个运行在用户模式，一个是在内核模式 故障最常见的故障就是缺页异常，当指令引用一个虚拟地址时，如果该地址对应的物理页面不在内存中，就会引发异常，并尝试从磁盘中读入内存，如果加载顺利，就将控制返回引发故障的当前指令，该指令再次执行的时候，虚拟地址对应的物理也页就存在于内存中了，但是如果加载失败，异常处理程序返回到内核中的abort例程，并终止该程序 终止通常是一些致命的错误导致的，如DRAM损坏等，处理程序直接将控制返回个一个abort例程，并终止该程序 Linux的异常常见故障和终止 除法错误（异常号0）：除以零，或者目标操作数太大时都会发生，显然该故障不能由机器自动修复，只能选择终止程序，Linux shell报告为”Floating exception” 一般保护程序（异常号13）：如引用未定义的虚拟内存等都为导致该故障，Linux shell报告为”Segmentation fault” 缺页（异常号14）：将在虚拟内存章节详细讲解 机器检查（异常号18）：检测到硬件导致的致命错误 系统调用（陷阱）Linux提供上百种系统调用供应用程序请求内核服务时调用。标准C库提供一系列的包装函数，来调用系统调用。包装函数将参数和系统调用打包，并根据系统调用陷入内核程序，并将系统调用的返回状态转递给调用程序。常见系统调用实例如下图所示 进程异常是允许操作系统内核提供进程概念的基本构造块 进程的定义就是一个执行中的程序实例，通过进程能给我们提供一个假象，好像当前程序是系统中唯一运行的程序一样，好像该程序能独占处理器和内存。但其实每个程序都运行在某个进程的上下文中（上下文包括程序代码和数据，栈、通用目的寄存器的内容，程序计数器，环境变量等） 例如当在shell中输入./hello时，shell就会创建一个新的进程，并在该进程的上下文中执行它 进程为应用程序提供了关键两点抽象 独立的逻辑控制流：程序独占处理器的假象 私有的地址空间：程序独占内存系统的假象 逻辑控制流又称逻辑流（注意其和控制流的区别），当我们单步调试程序时，看到的一系列程序计数器的值，对应程序中的指令，这个值的序列就叫做逻辑控制流 处理器的一个物理控制流（也就是文章开头提到的控制流），被分成多个逻辑流，每个进程对应一个逻辑流，进程轮流使用处理器，然后被暂时挂起，换做其他进程使用处理器 逻辑流之所以叫逻辑流，因为它并不是实际上的流，它是间断的，而是逻辑抽象上的流，但是处理器的物理控制流是持续不断地，这个流会不停的被不同的逻辑流填充 异常处理流、进程、信号处理程序、线程和Java进程都是逻辑流的例子 并发流一个逻辑流的执行时间与另一个流重叠，成为并发流，这两个流被称为并发地运行，准确说两个流的执行时间有交集时，成为并发 多个流并发执行的一般现象称为并发，多个进程轮流运行称为多任务 进程执行它的控制流的一部分的时间段叫做时间片，多任务也叫做时间分片 另一个概念叫并行流，它是出现在多个处理器时，它是并发流的真子集，如果两个流并发运行在不同处理器上，称为并行流，其实也是并发流，因为执行时间重叠，就称为并发 私有地址空间前面提到进程为程序提供独占系统内存的假象，下图是Linux进程的地址空间的组织结构地址空间底部是保留给用户程序的，包括通常的代码、数据、堆、栈段，顶部是保留给内核，包含了内核在代表进程执行指令时使用的代码数据等 用户模式和内核模式处理器用一个控制寄存器的一个模式位来限制应用可以执行的指令及其可以访问的地址空间范围，当设置了模式位，进程就处在内核模式中，并且可以执行指令集的任何指令，访问任何的内存位置 处在用户模式的进程不允许执行特权指令，例如停止处理器、改变模式位、或者发起一个人I/O操作，也不允许访问地址空间中内核区的数据，反之用户需要通过系统调用接口来间接的访问内核代码和数据 用户模式进入内核模式的唯一方法就是通过异常，当异常发生时，进入异常处理程序，就从用户模式进入了内核模式，处理程序返回时，又切换回用户模式 上下文切换如前所示，上下文包括通用目的寄存器、浮点寄存器、程序计数器、用户栈等信息，它是内核重新启动一个被强占的进程所必须的信息 操作系统内核使用上下文切换的较高层次的异常控制流来实现多任务 由内核来决定抢占当前进程，并重新执行之前被抢占的进程的这一决策过程称之为调度，由内核中称之为调度器的代码执行，当调度发生时，将采取上下文切换机制来将控制转移到新的进程中 上下文切换包含三个步骤 保存当前进程的上下文 恢复即将执行进程的上下文 将控制转移给新的进程 实例一：用户程序进行系统调用，想要read磁盘文件，这时候系统调用可能会发生阻塞（因为读取磁盘文件需要时间），内核就会进行上下文切换，让当前进程休眠，运行其他程序，而不是等待磁盘数据，运行一段时间之后，磁盘发出一个中断信号，表示数据传输完成，内核就又切换回之前的进程，并继续运行 实例二：程序显示进行sleep系统调用，让进程休眠，内核自然会切换进程 系统调用错误处理Unix系统级函数遇到错误时，都会返回-1，并设置全局整数变量errno来表示对应错误类型，并且通过错误包装函数可以简化代码 进程控制给出了一些重要函数来进行进程控制 获取进程ID每个进程都对应了唯一的正数进程ID（PID），通过getpid和getppid函数可以分别返回调用进程的ID和父进程的ID，返回值类型为pid_t，在Linux中该类型被定义为int 创建和终止进程进程的三种状态 运行：在处理器中执行，或者等待被执行被最终会被内核调度 停止：进程被挂起，且不会被调度，说明他已经脱离流的执行队伍当中，知道收到信号才又会被执行 终止：收到信号，且默认行为就是终止进程；从主程序返回；调用exit函数，以上三种行为都会导师进程终止 父进程通过fork函数创建新的子进程，新创建的子进程拥有父进程用户级虚拟地址空间的副本和父进程打开文件描述符相同的副本（即子进程可以读取任何父进程打开的文件），两者最大的区别在于两者的PID不同 fork函数的特性 调用一次，返回两次，一次返回到父进程，一次返回到新创建的子进程 并发执行，父进程和子进程是并发执行的独立程序，内核以任意方式来交替执行父子进程中的指令 相同但是独立的地址空间 共享文件，父子进程都能讲结果输出到屏幕，因为父进程中，stdout文件是打开的，并指向屏幕，子进程自然继承这个文件，将结果输出到stdout 对于有多个fork实例的程序就需要仔细推敲 回收子进程进程终止时，不会立即被内核从系统中清除，将保持在一种已经终止的状态，这种终止但是没有被回收的进程称为僵死进程，这种进程虽然终止，但是依旧会消耗内存资源 当父进程回收僵死进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程 系统驱动时就会启动一个由内核创建的init进程，它是无敌进程，不会终止，而且是所有进程的祖先，其PID为1 如果父进程终止，内核将安排init进程成为被父进程抛弃的孤儿进程的养父，如果父进程的底下存在僵死的子进程没有被回收，内核就安排init进程去回收他们，承担起爸爸的责任 waitpid函数函数原型：pid_t waitpid(pid_t pid,int *statusp,int options); 通过调用waitpid函数来等待它的子进程终止或者停止，默认情况下（options=0），该函数挂起调用进程的执行，直到进程的等待集合中的一各子进程终止，并且函数返回导致其返回的子进程的PID，子进程则被内核回收 等待集合：该函数的第一个参数pid决定了等待集合的成员 pid&gt;0,等待集合就是一个单独的子进程， pid=-1，等待集合就是由父进程所有子进程组成的 函数第三个参数可以修改默认行为，下面的常量都定义在wait.h头文件中，对应不同的值 WNOHANG：等待集合中没有子进程终止，就立即返回值0。如果不想等待子进程终止，而是想要做其他事情，这个选项有用 WUNTRACED：该参数和默认行为的唯一区别在于，默认行为是返回终止的子进程的PID，而这个参数是返回终止或者被停止的进程的PID WCONTINUED：挂起调用进程的执行，直到等待集合中的进程终止或者集合中的一个被停止的进程收到SIGCONT信号重新开始执行 WNOHANG|WUNTRACED：立即返回，如果等待集合中的子进程没有终止或者停止，返回值为0；如果有一个终止或者停止，返回该进程的PID Linux信号更高层次的软件形式的异常，它允许进程和内核中断其他进程。底层的硬件异常由内核异常处理程序处理，一般对用户进程不可见，信号提供一种机制，能够通知用户进程发生了这些异常 发送信号内核通过更新目的进程上下文中的某个状态，来发送一个信号给目的进程 进程组：每个进程都只属于一个进程组，进程组由一个正整数ID标识PID kill：kill程序可以向另外的进程发送任意的信号，如果指定的PID为负则会导致信号被发送给进程组PID中的每个进程，PID等于零时，发送信号给调用进程所在进程组的每个进程，包括调用进程自己键盘：在键盘中输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程，结果是终止前台作业；同理如果输入Ctrl+Z会发送一个SIGSTP信号到前台进程组的每个进程，结果是停止（挂起）前台作业alarm：该函数安排内核在参数secs秒后发送一个SIGALRM信号给调用进程 接受信号当目的进程被内核强迫以某种方式对信号的发生做出反应时，就接受了信号。进程可以忽略、终止、执行一个信号处理程序的用户层函数来对信号做出反应 当内核把进程p从内核模式切换成用户模式时，会检查进程p的未被阻塞的待处理信号的集合，集合非空时，内核会选择集合中的某个信号并强制进程p接受信号，每个信号类型都有一个默认行为 进程终止 进程终止并转储内存 进程挂起知道被SIGCONT信号重启 忽略该信号 进程也可以通过signal函数修改和信号相关联的默认行为（除了SIGSTOP和SIGKILL，这两个信号的默认行为不能修改） signal函数原型：sighander_t signal(int signum,sighandler_t handler); handler是用户自定义的函数，称为信号处理程序，当进程接收到一个类型为signum的信号，就会调用这个处理程序。通过把处理程序的地址传给signal函数从而改变默认行为，这叫做设置信号处理程序，调用信号处理程序叫做捕获信号，执行信号处理程序叫做处理信号 阻塞信号进程可以选择阻塞某种信号，则这种信号可以被发送但不会被接受。一个发送但没有被接受的信号叫Pending Signal（待处理信号）。一种类型至多只有一个Pending Signal。也就是说如果存在一个未处理的信号就表明至少有一个信号达到了，其他到达的信号都会丢失 内核为每个进程在Pending位向量中维护Pending Signal的集合，而Blocked位向量维护被阻塞的信号集合，当某K类信号被阻塞，内核就将设置Blocked位向量的第K位，当取消K类信号的阻塞时，内核就取消这种信号 Linux提供阻塞信号的隐式和显示机制 隐式阻塞进制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号 显式阻塞机制：使用sigprocmask函数和它的辅助函数，明确阻塞和解除阻塞信号 sigprocmask函数原型：int sigprocmask(int how,const sigset_t *set,sigset_t *oldset);，how参数决定了该函数的行为 处理信号信号处理程序麻烦是因为它和主程序以及其他信号处理程序并发运行，下面的信号处理程序编写原则要遵守，否则由于并发出现的错误将会不可预测和不可重复，给调试带来困难 尽可能简单 只调用异步信号安全的函数：这种函数要么是可重入的，要么不能被信号处理程序中断，许多常见函数（如printf、malloc）都不在此列 保存和恢复errno： 阻塞所有信号，保护对共享全局数据结构的访问 用volatile申明全局变量 用sig_atomic_t申明标志 非本地跳转C语言提供一种用户级异常控制流形式，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回程序非本地调转一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是检测到某个错误情况引起的，而不是费力地解开调用栈 strace：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹 ps：列出当前系统中的进程（包括僵死进程） top：打印关于当前进程资源使用的信息 pmap：显示进程的内存映射]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web proxy]]></title>
    <url>%2F2018%2F05%2F23%2Flab-webproxy%2F</url>
    <content type="text"><![CDATA[实现一个多线程带缓存的代理服务器！ 简介Web代理是在Web浏览器和终端服务器之间充当中间人的程序。浏览器不会直接联系最终服务器以获取网页，而是与代理联系，代理将请求转发到最终服务器。当终端服务器答复代理时，代理会将答复发送到浏览器 代理的作用： 在防火墙中使用代理，因此防火墙后面的浏览器只能通过代理与防火墙以外的服务器联系。 充当匿名者，通过剥离对所有标识信息的请求，代理可以使浏览器匿名到Web服务器 可以用于缓存web对象，方法是存储服务器中对象的本地副本，然后通过从缓存中读取对象 (而不是与远程服务器再次通信) 来响应将来的请求 这次的作业主要分三个部分 Sequential Proxy: 接收客户端发送的HTTP请求，解析之后向目标服务器转发，获得响应之后再转发回客户端 Concurrent Proxy: 在第一步的基础上，支持多线程 Cache Web Objects: 使用LRU缓存单独的对象，而不是整个页面 先复习一下HTTP报文的格式应用层 Part I请求的header一定要有的内容是： Host: 如Host: www.cmu.edu User-Agent: 如 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3 Connection: 如 Connection: close Proxy-Connection: 如 Proxy-Connection: close 代码倒是很快写好，问题出在了如何去调试上面，发现指针部分还是不熟练啊！12int conn_server(char *hostname,int *port,char *query_path);int parse_url(char *url, char *hostname,char *query_path,int *port); 主要就是完成上面两个函数 这个实验倒是提升了自己的GDB的调试能力和对套接字接口的理解 Part II在第十二章：并发编程提到了三种方式实现并发服务器，作为参考 采取生产者-消费者模型，并使用信号量，前面的章节掌握的好，在Part I的基础上修改成并发服务器并不难可以发现实现并发之后，打开速度明显提快 Part IIIHTTP实际上定义了一个相当复杂的模型，通过该模型，web服务器可以指示如何缓存它们所服务的对象，客户端可以指定如何代表它们使用缓存，而我们只需要实现简化版 此可能会出现一个巨型对象将消耗整个缓存的情况，从而防止缓存其他对象。为了避免这些问题，要设置maximum cache size maximum cache object size 对缓存的访问必须是线程安全的，确保缓存访问没有竞争条件可能是这个Lab更有趣的方面。事实上，有一个特殊的要求，即多个线程必须能够同时从缓存中读取。当然，一次只允许一个线程写入缓存，但读者必须不存在这种限制。因此，使用一个大型独占锁保护对缓存的访问不是一个可接受的解决方案。您可能需要探索一些选项，例如对缓存进行分区、使用Pthreads readers-writers locks或使用信号量来实现您自己的readers-writers解决方案。无论哪种情况，您不必实施严格的LRU eviction policy这一事实都会使您在支持多个读取器方面有一定的灵活性 写代码花了半天，调BUG花了一天，兜兜转转终于写出个能跑的代理服务器，虽然还是有很多BUG存在。调试BUG期间也是相当痛苦，尤其是在多线程的环境下，总感觉有股不自信在，或许是因为第一次接触，虽然整个循环已经建立，也就说能写入缓存，也能从缓存获取，但是依旧有一些BUG存在，之后会不断完善 完成这个实验，其实不要对多线程感到恐惧，并没有那么神秘，心态放端正 附录源代码]]></content>
      <tags>
        <tag>CSAPP，LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa839]]></title>
    <url>%2F2018%2F05%2F23%2FUVa839%2F</url>
    <content type="text"><![CDATA[UVa839代码 题意：]]></content>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buflab]]></title>
    <url>%2F2018%2F05%2F16%2Flab-buffer%2F</url>
    <content type="text"><![CDATA[I am a hacker!! 简述原文指南 该任务帮助详细了解IA-32调用方式和栈组织，其涉及对可执行文件bufbomb实行一系列的缓冲区溢出攻击（buffer overflow attacks） 在本实验中，将获得有关通用的寻找操作系统和网络服务器中的安全弱点的方法的第一手经验。我们的目的是帮助您了解程序的运行时操作，并了解这种形式的安全弱点的性质，以便您在编写系统代码时避免它。我们不容忍使用这种或任何其他形式的攻击来获得对任何系统资源的未经授权的访问 在实验材料中有三个可执行文件 bufbomb：将要攻击的程序 makecookie：基于userid创建cookie，因此每个人的解决方案都会不一样 hex2raw：在字符串格式间转换 cookie是由八个十六进制数字组成的字符串，它（概率很高）是userid所独有的，如： bufbomb程序使用下面的函数读入一个字符串 123456789/* Buffer size for getbuf */ #define NORMAL_BUFFER_SIZE 32int getbuf() &#123; char buf[NORMAL_BUFFER_SIZE]; Gets(buf); return 1; &#125; Gets函数将读入的字符串写入目标地址，但是无法判断缓冲区对于输入字符串是否够大 我们的任务就是编写特殊的输入字符串，使得程序作出不一样的事情，这就叫exploit string bufbomb函数有一些有用的参数 -u &lt;userid&gt;：该函数的一些特征会根据userid作出调整 -h：一些可能的命令行参数 -n：使用Nitro模式，将在Level 4中使用 -s：提交 Candle12345678910111213141516171819void test() &#123; int val; /* Put canary on stack to detect possible corruption */ volatile int local = uniqueval(); val = getbuf(); /* Check for corrupted stack */ if (local != uniqueval()) &#123; printf("Sabotaged!: the stack has been corrupted\n"); &#125; else if (val == cookie) &#123; printf("Boom!: getbuf returned 0x%x\n"，val); validate(3); &#125;else&#123; printf("Dud: getbuf returned 0x%x\n"，val); &#125; &#125; 当getbuf执行返回语句时，程序会返回上面的test函数执行，任务就是改变这种行为，使得进入下面的函数123456void smoke() &#123; printf("Smoke!: You called smoke()\n"); validate(0); exit(0); &#125; 反汇编查看bufbomb代码，并形成如下状态的运行栈也就说缓冲区起始位置距离返回地址的位置为0x28，也就是40个字节，因此填充40个字节符号后，将smoke函数的起始地址填入即可，注意地址要按小端法表示 Sparkler12345678void fizz(int val) &#123; if (val == cookie) &#123; printf("Fizz!: You called fizz(0x%x)\n"，val); validate(1); &#125; else printf("Misfire: You called fizz(0x%x)\n"，val); exit(0);&#125; level 1实验的要求和level 0相似，但它需要程序从getbuf()返回后执行fizz(int val)函数，并且为fizz(int val)函数传递你自己独有的cookie参数。 调用者负责将参数压入到栈上，参数位置是（%esp），即栈顶所指的位置。从fizz的反汇编代码中也看出参数应该是在%eax，也就是在0x8(%ebp)， 要传入的参数就是userID对应到的cookie，如下所示 得到的攻击字符串自然如下所示 Sparkler GET！ Firecracker12345678910int global_value = 0;void bang(int val) &#123; if (global_value == cookie) &#123; printf("Bang!: You set global_value to 0x%x\n"，global_value); validate(2); &#125; else printf("Misfire: global_value = 0x%x\n"，global_value); exit(0); &#125; 更复杂的缓冲区攻击形式包括提供一个字符串，对实际的机器指令进行编码。然后，攻击字符串将用堆栈上这些指令的起始地址覆盖返回指针。当调用函数（在本例中为getbuf）执行其ret指令时，程序将开始执行堆栈上的指令，而不是返回。有了这种形式的攻击，你可以让程序做几乎任何事情。您放置在堆栈上的代码称为利用代码。不过，这种攻击方式很棘手，因为你必须把机器代码放到堆栈上，并将返回指针设置为此代码的开头。 global_value是一个全局变量，它没有储存在栈里面。所以在程序执行过程中，只能通过赋值语句来改变global_value的值。即这次我们不仅要让函数跳到bang中，而且要模拟一个函数调用来先进行赋值。 因此思路就是先覆盖返回地址，使其跳转到缓冲区中的攻击指令（也就是我们编写的函数），在这个函数之后，再跳转到bang函数中 新的函数如下所示，先获取已有的cookie，再将其复制到global_value上，最后将bang的地址推入栈中，以返回该函数 我们选择将该攻击函数代码放在缓冲区的起始位置，因此要寻找buf的起始位置是多少，如下所示 和上面题目不太一样的一点就是现在我们要返回到我们编写的这个函数位置，最后完整的指令如下所示 Firecracker GET！ Dynamite这次要求getbuf调用后，返回到test当中，但是不能破坏为test函数维护的堆栈状态（test函数加了堆栈状态检测），同时要让test函数调用getbuf后的返回值（val）为自己的cookie。 由于缓冲区溢出时破坏了%ebp的值，需要写入代码修复%ebp，因此先获得原来的%ebp的值，如下所示 和之前的做法一样，在攻击字符串中写入一下代码，首先将cookie作为返回值传给test，然后修复%ebp，在将test调用getbuf的下一条指令推入栈，最后返回 得到对应的完整攻击代码 Dynamite GET！ Nitroglycerin如书中所说，每次运行时，给定过程使用的确切堆栈位置会有所不同。攻击方法就是在实际攻击代码前插入很长一段nop操作（no operation），执行这种指令除了PC加一外，使其指向下一条指令，没有任何效果。只要攻击者能够猜中这段序列的某个地址，就能达到攻击代码。这个序列就叫空操作雪橇（nop sled） 当您使用命令行标志”-n”运行时，它将在”Nitro”模式下运行。程序不是调用函数getbuf，而是调用稍有不同的函数getbufn。此函数类似于getbuf，只是它具有512个字符的缓冲区。调用getbufn的代码首先在堆栈上分配随机数量的存储。每次执行时，会发现%ebp（%ebp-0x208则是buf的首地址）的值都是不一样的，如下所示 由于不能确定buf首地址的位置，就不知道修改的跳转地址应该是什么，也就不知道攻击代码应该放在哪里。对于这种栈随机化，使用的就是nop sled方法。要做的依旧是提供一个利用字符串，该字符串将导致getbufn将您的cookie返回test，而不是值1。您可以在测试代码中看到，这将导致程序转到”KABOOM!”。其他功能则和Dynamite一样。 先通过上图来确定buf首地址可能的位置，设置跳转地址为该值，如下图最后一行所示，不管buf首地址是什么，只要能跳转到509个nop操作（也就是90）中的其中一个，PC就能执行到存放在buf中的攻击代码 攻击代码和上面的题目类似，首先将cookie作为返回值，然后修复%ebp，然后将调用getbufn的下一条语句推入栈中 Nitroglycerin GET！]]></content>
      <tags>
        <tag>CSAPP，AB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Malloc]]></title>
    <url>%2F2018%2F05%2F16%2Flab-malloc%2F</url>
    <content type="text"><![CDATA[编写动态存储分配器 简介本实验只需要修改mm.c，mdriver.c是评估所写程序性能的驱动程序 要实现的动态存储分配器将由以下四个函数组成，它们均在mm.h中申明，在mm.c中实现了上述函数的最简单版本，在此基础上修改改进， int mm_init(void);：应用程序调用该函数去初始化，如分配初始堆区域（heap area） void *mm_malloc(size_t size);：返回一个指向指定大小块的指针，分配的块应位于堆区域内（heap region），且不能和其他块重叠 void mm_free(void *ptr);：释放指针所指的区域 void *mm_realloc(void *ptr, size_t size);：如果ptr为NULL，相当于mm_malloc；如果size为零，相当于mm_free；ptr不为NULL，则修改指向块的大小，并返回块的位置 动态内存分配器很难正确编程, 因为它们涉及大量的非类型化指针操作。您会发现编写一个堆检查器来扫描堆并检查它的一致性是非常有帮助的。堆检查器可能检查的一些示例如下: Is every block in the free list marked as free? Are there any contiguous free blocks that somehow escaped coalescing? Is every free block actually in the free list? Do the pointers in the free list point to valid free blocks? Do any allocated blocks overlap? Do the pointers in a heap block point to valid heap addresses? 在memlib.c中模拟动态内存分配器的内存系统。可以调用以下函数: void *memsbrk(int incr): Expands the heap by incr bytes, where incr is a positive non-zero integer and returns a generic pointer to the first byte of the newly allocated heap area. The semantics are identical to the Unix sbrk function, except that memsbrk accepts only a positive non-zero integer argument. void *memheaplo(void): Returns a generic pointer to the first byte in the heap. void *memheaphi(void): Returns a generic pointer to the last byte in the heap. sizet memheapsize(void): Returns the current size of the heap in bytes. sizet mempagesize(void)：Returns the system’s page. mdriver.c将测试编写程序的正确性、空间利用率和吞吐量。其中有一组trace file，包含了一系列分配、重新分配和释放操作，该驱动程序具有以下参数 -t &lt;tracedir&gt;:Look for the default trace files in directory tracedir instead of the default directory defined in config.h. -f &lt;tracefile&gt;: Use one particular tracefile for testing instead of the default set of tracefiles. -h: Print a summary of the command line arguments. -l: Run and measure libc malloc in addition to the student’s malloc package. -v: Verbose output. Print a performance breakdown for each tracefile in a compact table. -V: More verbose output. Prints additional diagnostic information as each trace file is processed. Useful during debugging for determining which trace file is causing your malloc package to fail. 使用书上的隐式链表+第一次适配连及格分都拿不到]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[QuickSort 特点：虽然最坏情况下时间复杂度为$\Theta(n^2)$，但在实际应用中效果却很好（这一点后面会解释），它的期望时间复杂度是$\Theta(nlgn)$，而且隐含的常数因子非常小，另外就是原址排序 算法形式快速排序依旧采取分治思想 分解：数组A[p..r]被分成A[p..q-1]和A[q+1..r]，使得A[p..r-1]中的元素都小于等于A[q],A[q+1..r]中的元素都大于A[q]， 解决：递归调用，分别对A[p..q-1]和A[q+1..r]进行快速排序 合并：原址排序，不需要合并 快速排序伪代码12345QuickSort(A,p,r)if q &lt; r p = Partition(A,p,r) QuickSort(A,p,q-1) QuickSort(A,p+1,r) Partition对子数组A[p..r]实现原址排序123456789Partition(A,p,r)pivot = A[r] //选取A[r作为主元i = p - 1 //区域分界线for j = p to r-1 if A[j] &lt; pivot i = i+1 exchange A[i] with A[j]exchange A[i+1] with A[r]return i+1 该过程将数组原地划分为四部分 A[p..i]小于pivot的部分 A[i+1..j]大于pivot的部分 A[j+1..r-1]未排序部分 A[r]作为pivot 算法证明通过Partition过程的特性构造一个循环不变式 算法分析源代码]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章：程序的机器级表示（3）]]></title>
    <url>%2F2018%2F04%2F17%2FCSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[《CSAPP》第三章小结（续） 《深入理解计算机系统》 数组分配和访问对于数组A，A就是指向数组开头的指针，值为$x_A$，数组元素i存放在地址为$x_A+L·i$的地方，对应汇编代码movl (%rdx,%rcx,4),%eax。常量4，我们称为伸缩因子，值1、2、4、8覆盖了所有基本简单数据类型的大小。 数据结构struct的所有组成部分都存放在内存中一段连续的区域内，指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移，以这些偏移作为内存引用指令中的偏移，从而产生对结构元素的引用。 结构的各个字段的选取完全是在编译时处理的，机器代码不包含关于字段申明或字段名字的信息。 unio则是使用不同的字段来引用相同的内存块。总的大小等于最大字段的大小。当知道一种数据结构中的两种不同字段的使用是互斥的，将这两个字段声明为unio的一部分，就能减少分配空间的总量。 控制与数据存在一些指针映射到机器代码的关键原则？？？ 每个指针都对应一个类型。指针类型不是机器代码的一部分，而是C语言提供的抽象，避免程序员出现寻址错误 每个指针都有一个值。这个值是某个指定类型的对象的地址 指针使用&amp;运算符创建，其所对应的机器代码常使用leap计算表达式的值，leap就是设计用来计算内存引用的地址 *用于间接引用指针，结果是一个值，类型和指针类型一致，间接引用是用内存引用来实现的，要门存储到一个指定的地址，要么从指定的地址读取 数组和指针紧密联系 将指针从一种类型强制转换为另一种类型，只改变它的类型，不改变它的值。它的效果就是改变指针运算的伸缩 指针也可以指向函数。函数指针的值是该函数机器代码表示中的第一条指令的地址 越界与溢出C对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。对越界数组的写操作就会破坏栈中的状态信息。 一种常见的状态破坏就是缓冲区溢出，当调用gets、strcpy、sprintf等函数，不需要告诉目标缓冲区的大小，当写入的数据大于缓冲区大小时，就会破坏栈中的数据。这一点在C源码上看不出来的，只有在研究机器代码级别的程序时才能理解内存越界写的影响。 另一种缓冲区溢出就是让程序执行它本来不愿意执行的函数，这是网络攻击的常见方法。通过给程序输入一个字符串，这个字符串包含一些可执行代码的字节编码，即为攻击代码，另一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，指向ret指令的效果就是跳转到攻击代码。 为了对抗这种攻击，linux上最新的GCC版本提供了一些新的机制 栈随机化攻击者既要插入代码，也要插入指向攻击代码的指针，要产生这个指针，就要知道攻击代码字符串的栈地址。 在以往的操作系统中，栈的位置是相当固定的。因此攻击者确定一个常见Web服务器使用的栈空间，就能设计在多台机器上攻击的代码。 栈随机化的思想就是在栈的位置在每次运行时都有变化。实现方式就是在程序开始时，在栈上分配一段随机大小的空间，如下所示 栈破坏检测C语言中，没有可靠地方法防止对数组的越界写，但是能够在发生越界写的时候，在造成有害结果之前，尝试检测到他 这种机制称为栈保护着，其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值，也称为哨兵值，这个值是在每次运行时随机产生的，攻击者没有办法知道值是什么 限制可执行代码区域这种方法是限制攻击者向系统中插入可执行代码的能力。只有保存编译器产生的代码的那部分内存需要是可执行的 变长栈帧对于类似于alloc这类函数，局部存储是变长的 为了管理变长栈帧，x86使用寄存器%rbp作为栈指针（frame point/base point）。代码一开始将%rbp之前的值保存到栈中，因为他是一个被调用者保存寄存器，然后在函数的整个执行过程中，都使得%rbp指向那个时刻栈的位置。 在函数结尾处，leave指令将栈指针恢复到之前的值，其等价于下面命令，即将栈指针设置为保存%rbp值的位置，然后将该值从栈中弹出%rbp，这个效果就是释放整个栈帧的效果12movq %rbp,%rsppopq %rbp]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大学之路》]]></title>
    <url>%2F2018%2F04%2F16%2F%E3%80%8A%E5%A4%A7%E5%AD%A6%E4%B9%8B%E8%B7%AF%E3%80%8B%2F</url>
    <content type="text"><![CDATA[大学之思考 不想去讨论关于个人出身的问题，因为每个人命运不同，如果去抱怨自己为什么没有一个总统爸爸或教授妈妈，那简直是在浪费时间，残害生命，看完这本书，需要去思考身在中国，出身底层的自己和抛去背景后的名校学子之间有哪些差距，自己现在能做些什么去改变这种境地。 本书一开始就强调了终身学习的重要性，这一点我也早早意识到，相比身边为了学习而学习的同学，我想我是幸运的。 大学之路不仅是文中各所学校的历史发展之路，从中也应该去寻找合适自己的大学之路]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[HeapSort 算法形式堆排序集合了较好的时间复杂度（$O(nlgn)$）和空间原址性，并引入堆数据结构，该结构有两种形式 最大堆用在堆排序中，指除根节点以外的所有节点都满足$A[PARENT(i)]&gt;=A[i]$ 最小堆用在构造优先队列中，指$A[PARENT(i)]&lt;=A[i]$ 堆其实是一个数组，但可以抽象成是一个完全二叉树，利用数组下标$i$很容易计算出它的父节点$i/2$和孩子节点下标$2i,2i+1$,并且计算父和孩子节点时，可以采用算术右移或算术左移实现 通常规定$A.length$表示数组元素个数，而$A.heap-size$表示堆元素的个数,含$n$个元素的堆的高度为$\Theta(lgn)$ 含$n$个元素的堆，叶节点的下标分别为$\lfloor{n/2}\rfloor+1,\lfloor{n/2}\rfloor+2,…,n$ 维护堆的性质定义函数MAX-HEAPIFY能使A[i]的值在最大堆中逐级下降，从而找到合适的位置，维护最大堆的性质 建堆你 堆排序算法分析源代码]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵乘法及求解递归式]]></title>
    <url>%2F2018%2F04%2F15%2FCLRS-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%8F%8A%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Matrix multiply 算法形式矩阵乘法规则:$c_{ij}=\sum\limits_{k=1}^na_{ik}b_{kj}$最简单算法的伪代码:1234567Matrix-Multiply(A,B)n = A.lowsfor i = 1 to n for j = 1 to n c_ij=0 for k = 1 to n c_ij = c_ij + a_ik*b_kj 第一个for循环计算每一行的元素，第二个for循环计算每一列中的每一个元素，第三个for循环迭代计算求和，三重for循环都要执行n步，因此需要$\Theta(n^3)$时间如果采用分治策略，即使用分块矩阵做乘法1234567891011121314Matrix-Multiply-Recursive(A,B)n = A.lowsif n == 1 c11=a11*b11else partition A,B c11 = Matrix-Multiply-Recursive(A11,B11) + Matrix-Multiply-Recursive(A12,B21) c12 = Matrix-Multiply-Recursive(A11,B12) + Matrix-Multiply-Recursive(A12,B22) c21 = Matrix-Multiply-Recursive(A21,B11) + Matrix-Multiply-Recursive(A22,B21) c22 = Matrix-Multiply-Recursive(A21,B12) + Matrix-Multiply-Recursive(A22,B22)return c 虽然该算法要分解矩阵，但我们可以利用下标在$\Theta(1)$时间内完成，对总时间无影响，而每次加法时间为$\Theta(n^2)$,最终的递归式为$T(n)=8T(n/2)+\Theta(n^2)$,得到的结果依然为$T(n)=\Theta(n^3)$，没有改进Strassen算法的核心思想是令递归树稍微不那么茂盛，即只递归7次，而不是8次 算法分析（求解递归式） 代入法求解 递归树求解 主方法求解 源代码习题解答算法改进]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-第八章]]></title>
    <url>%2F2018%2F04%2F15%2FLinux-%E7%AC%AC%E5%85%AB%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[这章涉及到操作系统中的文件系统概念，第一次看的时候还没怎么看懂，现在重新来写总结 磁盘先从磁盘这个硬件开始讲起，如果看过机械硬盘构造，应该知道磁盘一般是圆的，但为了方便，我们可以将其想象成能被切割的长条形，最开始的分区表很重要，它记录了接下来分区起始的柱面号码，每个分区都是相互独立的，可以以不同的文件系统定义存放文件数据 文件UNIX文件系统将文件分成普通文件、目录文件、设备文件（特殊文件）和符号连接文件(Symbolic link)等几类，UNIX把所有I/O设备作为特殊文件，对I/O设备操作模仿为对普通文件的存取，这样将文件与设备的I/O尽可能统一起来，文件挂载就是把磁盘对应的文件挂载到特定的目录中，这个目录就成为挂载点 文件不仅仅包含实际的数据块，还包含很多额外数据，来对应操作系统需求，例如文件权限、修改日期和所有者等 文件系统文件系统是操作系统的一部分，承担起管理系统和应用程序资源管理的责任 从系统角度来看，文件系统是对文件存储器的存储空间进行组织、分配和回收，负责文件的存储、检索、共享和保护脑子中一直有个疑惑：文件怎么映射到磁盘上的？文件系统能和设备驱动程序通信，也就是文件系统判断要写入的文件的权限等信息后，通知设备驱动程序写入到某指定扇区的磁盘上，设备驱动程序又会真正通知硬件层的磁盘设备控制器，去控制磁头写入电信号，这样子就算打通了从文件系统到硬件层的通路 经常听说的格式化，就是指对于磁盘要格式化，以适应操作系统对应的文件系统格式，linux正规的文件系统是Ext2，Windows是FAT，以前常说一个分区对应一个文件系统，但现在由于新技术的变化，一个分区可以格式化为多个文件系统，多个分区也可以格式化为单个文件系统 前面我们讲到文件具有很多原数据，文件系统通常将权限与属性放置在inode中，将实际数据放在data block中，另外还有一个superblock记录整个文件系统的整体信息，包括inode和data block的总量、使用量、剩余量等，这些块对应到磁盘上就是不同的扇区 索引式文件系统，如Ext2，这种文件系统的好处在于在一开始磁盘就知道要读取那几个扇区，只要转一圈就必定能读取完整，链式文件系统，如U盘使用的FAT格式，这种格式的文件系统就经常需要进行碎片整理，因为如果Data Block分散的过开，并且磁盘并不知道要读取的所有扇区，只能一个个读取Block号码， 这样就可能要转好几圈，才能读取完整，所有要通过碎片整理，将同一个文件的Data Block合并在一起 Ext2文件系统几百G的磁盘意味着很多很多的inode和block，这样显然不含管理，就像几百万的军队只有一个司令管理，没有其他层次的管理机构，是很不合理的，因此Ext2在格式化的时候也会区分多个组块（block group）。每个group都有自己的super block、inode和data block，就像军队中的连和营的概念。相应的我们来讲解一下每个功能块的具体功能 Boot Sector：安装引导装载程序，在每个文件系统的最前面安装不同的引导装载程序，而不是去覆盖硬盘中惟一的MBR，就能实现多重文件系统 Super Block：未使用的和使用的inode/block数量（注意和Bitmap的区别）、总量和大小，挂载时间，写入时间等等信息 File System Description（文件系统描述）：记录该Block Group开始和结束的Block号码，以及每个区段的开始和结束Block代码 Block Bitmap（块对照表）：记录闲置的块，同理Inode Bitmap记录使用和未使用的inode号码 Data Block：每个Block的大小和数量在格式化之后一般就不会变化，Block是作为文件存放的最小单位，如果文件小于一个Block的大小，则该Block剩余空间就会浪费，如果文件远大于一个Block，就会产生大量的inode，也会造成不良的索引时间，因此block大小的设定要根据实际情况 与目录树的关系文件和目录的创建基本相同，都是分配一个inode和一个以上的block，对于文件来说，block存放实际数据，对于目录来说，block则存放文件名和该文件占用的inode号码 系统通过挂载信息找到挂载点的inode号码，此时就能够一层层往下读到正确的文件名 未整理完]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编码：隐匿在计算机软硬件背后的语言》]]></title>
    <url>%2F2018%2F04%2F11%2F%E3%80%8A%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B%2F</url>
    <content type="text"><![CDATA[即使后面的路是100，它依旧是一本带你从零到一的经典。虽然讲得很简单，可我却一遍遍回头翻阅 通信 编码 数字电路 字符转换 操作系统 高级语言 “为学日益，为道日损，损之又损，以至于无为，无为而无不为。”这是译者序中的一句话，还是百度后才明白的它的意思。学习知识和技术要不断丰满完善，精益求精，在实战中，要逐步丢掉课堂中学到的概念，把握客观规律，根据现状因地制宜做出反应，并对现实规律、概念予以加深，脑子中的记会的概念越来越少，刻在脑子中的知识越来越多，即为“道日损” 站在如今的角度，去看这本书，不免会说这是一本古董书，他带您追溯到了计算机从无到有的过程，也许过程有些不切实际，但是不得不说这本书抓住了计算机发展的本质，它通过每一章节的叙述，慢慢的构建出一台计算机，丝毫没有突兀感，让您有种自己也造出一台的感觉。 透过这本书，能看到一个最最原始的计算机是这么产生的，让外人看了，觉得计算机也没有那么神秘，它是美的，它是具有明确的层次结构的，它是笨拙的也是智慧的 通信编码编码的产生或许是出于军事保密，亦或是出于交流方便。通过不同种类的编码，不同的人就可以互相交流，只要他们明白对方采取的编码格式。所以电脑中0和1的组合就能产生无数信息，当然我们可以自己发明一种编码格式，但是这样别人就看不懂，也就没有了存在的意义，编码的出现不就是为了使交流更方便吗？在现实中，普遍就采取了ASCII编码格式。在更高一级去观察网络信息之间的传送，一份网络中传播的信息，不仅要包括信息本身，还要包括目的地址，发送地址，就像邮件一样。对于计算机这种死板的机器来说，你不能随意书写这些不同类的信息，一定要按照一定的格式，所以就又产生了HTTP，TCP/IP等协议 现在有了编码，能将文字等信息转换成0和1表示了，那我该怎么传送这些信息呢，对于这个问题的思考就引出了熟悉的电报机。例如我在山的这头按了一下开关，电路连通，就会将电信号通过电线传到另一头，那我要在另一头怎么读取传送的信号呢，用电磁感应现象啊，在电路上接一个感应线圈，一个磁铁，一个电信号传过来时，磁铁就会动一下，表明信息传送过来了。当然这只是最基础的模型，现实中肯定会有不同问题需要处理 解决了信息传输的能力，懒惰的人类又在想怎么能自动计算呢？这就引出了数字电路的知识，通过构造与门、或门就能构造一台能简单计算的机器，想想还是很神奇。如何去组织逻辑门，就会涉及到数字电路和离散数学的知识，就不深入展开了 当原始的计算机器被设计出来时，人们要去计算一个简单的加减法，还要去人工设置每一位数字，还要设置操作符，相当麻烦。对于这个问题的引出就产生了编程，之后又出现了高级的编程语言、操作系统等 数字电路字符转换操作系统高级语言]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆桌派]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%9C%86%E6%A1%8C%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[一部强烈推荐的谈话类节目，每集一个话题，四个人针对话题讲出自己的理解，形式很平淡，却值得我细细体会，对我我这个缺乏思考的人来说，这是一部能引起我好好反思的节目。在这个泛娱乐化的时代，这个节目就是一股清流。 印象很深刻的一个见解，所谓文化指将文化之，意思指将自己结果的文章知识要化成自己的，也就是要能灵活运用它，才算是文化。一个人一定是在看过大量知识并能将其化为自身所用才算是真正有文化的人。反观自身，虽然看的书也不算少数，但进行的思考却是少之又少。自己也确实意识到了这个问题，所以选择写博客，记录自己的思考，也算是强迫自己多思考。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法导论》]]></title>
    <url>%2F2018%2F04%2F07%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%2F</url>
    <content type="text"><![CDATA[之前已经大概了解了不同的算法，这次做的是专题总结，针对每个算法从理论到实践都过一遍，理论上有《算法导论》这本书，每种算法最好用python/c/java实现一遍，这次看书重在精，因此不求快，并且求每篇文章都是精品，代码放在Github 掌握一种算法的过程应该是：理解算法怎么工作-&gt;算法原理-&gt;实现算法-&gt;改进算法-&gt;做算法题实践 CLRS-B树 归并排序 插入排序 矩阵乘法及求解递归式]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子数组]]></title>
    <url>%2F2018%2F04%2F07%2FCLRS-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Maximum subarray 算法形式例如对于不对变化的股票，要怎么买入买出才能是效益最大化，将问题从寻找数据的最大值最小值变成考察数据相对于前一个点的变化大小，这样问题就变为了寻找最大的非空连续子数组，即最大子数组依旧采取分治策略来求解，假设我们要寻找子数组A[low..high]的最大子数组，根据分治思想将该数组分为两个规模相等的子数组，设切分点为mid，则最大子数组必然出现在以下三种情况中 完全位于A[low..mid]中 完全位于A[mid..high]中 介于中间 递归求解前两种情况的子问题和母问题相同，问题在于介于中间这种情况，假设该数组为A[i..mid..j]，因为必须过mid这个点，所以分别向左和向右寻找最大子数组，然后合并即可，该过程可以在线性时间内完成12345678910111213141516FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)left-sum=0sum=0for i = mid downto low sum = sum+A[i] if sum &gt; left-sum left-sum=sum max-left=iright-sum=0sum=0for i = mid+1 upto high sum=sum+A[i] if sum&gt;right-sum right-sum=sum max-right=jreturn(max-left,max-right,left-sum+right-sum) 第一个for循环找左半部的最大子数组，第二个for循环在找右半部的最大子数组，最后返回最大子数组的边界和最大子数组的值123456789101112FIND-MAXIMUM-SUBARRAY(A,low,high)if high==low return(low,high,A[low])else mid=(low+high)/2 (left-low,left-high,left-sum)=FIND-MAXIMUM-SUBARRAY(A,low，mid) (right-low,right-high,right-sum)=FIND-MAXIMUM-SUBARRAY(A,mid，high) (cross-low,cross-high,cross-sum)=FIND-MAX-CROSSING-SUBARRAY(A,low，mid,high)if left-sum&gt;=right-sum and left-sum&gt;=cross-sum return(left-low,left-high,left-sum)elseif right-sum&gt;=left-sum and right-sum&gt;=cross-sum return(right-low,right-high,right-sum)else return(cross-low,cross-high,cross-sum) 7-12行为合并工作，因为第七行求子数组并非原问题的子问题，所以看作是合并部分 算法分析$n=1$时，$T(1)=\Theta(1)$$n&gt;1$时，求解子问题需要$2T(n/2)$的时间，而求解cross问题则需要$\Theta(n)$时间，因此总的递归式为$T(n)=2T(n/2)+\Theta(n)$,根据主方法求解得$T(n)=\Theta(nlgn)$ 源代码 C++ 习题解答Ex4.1-3指出规模为$n_0$是暴利算法和递归算法的性能交叉点 算法改进最大子数组其实存在一个线性时间的算法，但不是使用分治策略]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-第七章]]></title>
    <url>%2F2018%2F04%2F06%2FLinux-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[《鸟哥的Linux私房菜》第七章小结 目录的相关操作 绝对路径：一定有根目录/写起 相对路径：指相对当前工作目录的路径 .此层目录 ..上一层目录 -前一个工作目录 ~目前用户所在的主文件夹 ~account用户account的主文件夹 cd：切换目录 cd [路径] cd ~xzy进入xzy的主文件夹，即/home/xzy cd ~或cd回到自己的主文件夹 cd ..到目前的上层目录 cd -回到刚才的目录 cd ../mqueue相对路径 pwd：显示当前目录 -p参数显示当前目录，而不是显示链接路径 pwd显示出当前的工作目录 mkdir：新建目录 -m参数设置新建目录的权限，而不是使用默认权限 -p递归创建目录，不需要目录每层目录都存在 rmdir：删除空目录 -p参数，连同上层的空的目录一起删除 执行文件路径的变量为什么在任何地方都可以执行一个特定的命令，而不会出现找不到该命令呢，这都是因为环境变量PATH的作用 当需要执行一个命令时，系统会依照$PATH的设置值去查询命令的可执行文件，若出现同名的命令，先找到先执行 不同身份的用户默认的PATH不同，能执行的命令也不同 PATH可修改，如PATH=&quot;$PATH&quot;:/root 如果知道命令执行文件的绝对路径，当然也可以执行 文件操作ls：查看 -a全部文件，包括隐藏文件 -l列出文件属性和权限 -d列出目录本身，不包括目录内的文件数据 -A全部文件，不包括.和..这两个目录 -f不排序的列出 -F根据数据属性列出，例如bomb是可执行文件。则以bomb*列出；Desktop是目录，则以Desktop/列出 -h将文件容量以GB，KB列出 -i列出inode号码 -n列出UID和GID -r按排序反向输出 -R连同子目录一起输出，等价于将该目录下所有文件都显示 -S按文件容量大小排序 -t按时间排序 --color=never不根据文件属性显示颜色 --color=always显示颜色 --color=auto自动判断 --full-time以完整时间格式显示 --time=atime输出访问时间 --time=ctime输出修改权限时的时间 cp：复制 -a相当于-pdr -i如果目标文件已经存在，在覆盖前先询问 -r递归连续复制，常用于目录的复制 -d源文件如果是链接文件，复制连接属性，而不是文件本身 -f强制执行的意思 -p连通文件的属性一起复制，而不是使用默认属性 -s复制成为符号链接文件，即Windows下的快捷方式 -u如果目的文件比源文件就才更新目的文件 rm：移除文件或目录 -f强制执行 -i删除前询问用户以确认 -r递归删除，不建议使用 mv：移动文件或者更名 -f强制执行 -i如果目标文件已经存在，询问是否覆盖 -u只有源文件更加新的时候，才更新 mv除了移动文件之外，也可用于更改文件名称 还可以通过basename来获取一个路径中的文件名，dirname则获取路径中的目录名 文件内容查询cat：查看文件与目录的默认权限与隐藏权限命令与文件查询文件压缩与打包gzipbziptar -c：新建打包文件 -t：查看压缩文件内容 -x：解压 -j：使用bzip2压缩或解压，文件名后缀为.tar.bz2 -z：使用gzip压缩或解压，文件名后缀为.tar.gz -v：在解压/压缩过程中，显示处理过程 -f：后接被处理的文件名 -c：在特点目录下解压]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《学习日志》]]></title>
    <url>%2F2018%2F04%2F06%2F%E3%80%8A%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一份关于自己生活学习心得的记录 0929 0917 0916 0915 0909 0903 0827 0702 0628 0613 0530 0527 0523 0517 0503 0406 0416 0421 4022 0929突然就很糟心，就不开心。感觉现在所努力的东西一文不值，没有任何用处。看着别人保研，评奖学金，自己什么都没有，只能在书里找点寄托。找不到什么能让自己真正快乐的事情，每天看书看书，就是个书呆子，好无趣。自己就是一个只敢想不敢做的人，很没用。但没关系，觉得困难也挺好，只要别放弃就好，没有什么事情是简单的。 接下来要写自己的技术日志，不用很详细，只要记录每天学到了点什么，解决了什么问题就好。 0917看了麻省的电路电子公开的第一课，就深深的被老师吸引，他首先介绍了从物理世界一步步抽象到计算机世界，逻辑的清晰和大局观真的让我折服，让我更明白了现在每门课所处的位置和作用。 0916看了《十三邀》中对王小川的演讲又有了一番体会。从他的话语中感觉到他对这个世界的清楚认知，他思维模式的完整性和复杂性。他读别人的书是建立在自己的理解之上，而自己去看书，就像木偶一样是被他人支配的。 看完他的采访，才明白差距所在，思维深度和广度的差距所在。而且在他的身上看到了《穷查理宝典》中说过的多种思维模型的样子，隐约明白了为什么自己写不出读书笔记的原因。 他总是不断去给自己的困惑寻找一个合理的解释，形成自己的一套理论体系，对自己有着很清楚的认知，而自己应该还处在形成体系的初初期。 0915每次看到成绩的时候，都会陷入一阵反思，或者说是自我否定，虽然自己明知道以现在的学习方法来说，一般是不会取得太好的分数的。当看到硬生生的绩点摆在自己面前的时候，我会问自己取得高绩点难道不是一件很爽的事情嘛，这时候就会问自己现在做的到底是不是在自己骗自己，自己现在到底有没有学到什么东西，有没有取得进步，这些问题都会打上个大大的问号？自己朝自己的目标是不是近了一点？ 第二个思考是如何快速学习的问题，虽然知道好的学习方法，但说真的，学习习惯真的也挺脑改变的，即使有好的方法摆在自己面前，自己还是很难去执行，这个问题只能慢慢去修改吧 突然感觉自己过了那个疯狂阅读的阶段，以前自己只知道不停的读书，很少有总结。现在回过头来，谈谈自己最近的阅读感受，真的变了，变得开始懂得真正去理解一本书，去汲取一本书中的知识。囫囵吞枣的阶段应该过去了。我一直思考为什么自己就不愿意去重新了解自己了解过的事物，不管是看过的书，游玩过的景点，就一股脑的想去了解新奇的东西，可自己为什么不回头，换个角度，带着新颖的问题和思考去重新阅读一本书，或者体会曾经去过的经典，每次重新阅读难道不都是一次全新的认知吗？大概因为内心一直都有个骄傲的小鬼在作怪，每当自己想重新认识的时候，都会默默的说一句，接下来的东西你都知道的啦，导致自己就不愿意去复习，去产生新的思考和想法。 0909很庆幸自己这么多年的苦读依旧没有磨灭对知识的兴趣，也很庆幸自己对未知的东西能保持一份好奇心，而不是厌恶或是恐惧，我想我应该会做到终身学习吧。 慢慢开始回忆自己上学期学习的东西，很多都已经忘记，说明上一个学期使用的方法很不正确。第一只顾着学，没有做到复习、思考和总结，第二学习的东西很杂，有些知识甚至不适合现阶段的自己去学习，这个学期开始要制定良好科学的学习计划，提高学习的效率。 0903看《大脑喜欢这样学》忍不住想要写点什么，因为书中讲的东西对我的学习真的帮助很大，有些知识是第一次接触，有些则是接触过，但从来不会实际使用。今后的学习中要多加练习书中学到的学习技巧。 0827依旧还是效率的问题，今后学习、做事情的时候，一定要养成集中45分钟精力干一件事，做完再休息的好习惯。不能做一会就玩手机，这是一个效率低下的坏习惯。其次每天的计划还是要科学制定，不要太多也不要太少，更要均衡。前几天和同学讲解计算机入门的知识，自己也是凭借记忆讲述，后来翻开自己写的博客，竟然和自己曾经写过的文字如出一辙。所以说过过脑子的东西，怎么也不会忘记。这也算是看到了自己学习的一点点成就吧！这个学习日记被我写成了阿谢的坏习惯改正日记。 0702今日思考问题：学习效率与方法论从小到大都被灌输着各种各样的知识，却从来没有去探究过知识的来源和根基，老师教授的永远是怎么使用，而不是怎么产生，可在我的脑海里这样的知识总是那样的摇摇欲坠和浮于表面，所以当我慢慢开始有了自己的思维，我就开始探索属于自己的学习方法，适合自己的方法论，很明显能感觉到的一点就是在面对一个知识点的时候，如果不能理顺这个点的来由，我总是很难记住它，更别说灵活使用它，很多时候看完书觉得自己懂得很多了，最后发现自己什么也不会，这说明自己还是没有真正搞懂，面对这样的问题应该怎么样解决，是需要自己去思考的，心里要有一杆秤，去衡量什么时候自己真的弄懂了，什么时候自己没有搞懂，现在自己的学习方法就是不停的看书，不停地思考，但是这样依旧有弊端，如果想一个陌生人讲述一个所以然，自己肯定不行，所以我去写博客，但是我写博客的方式，就是通过抄袭书上的知识点，这样做显然又陷入了效率低，浪费时间的境地。我一直想摆脱书上的东西就是标准这样一个根深蒂固的思维，但是也许是因为自己的自我思维还不够强大，当书上讲述的东西进入自己脑海中时，自己就是一个任人摆布的弱者，自我思维就被淹没，不能在旁提醒自己，看书的时候确实应该顺着作者的思路去思考，但是主线应该还是自己的思维才是。知识永远是成体系的，是可以触类旁通的，这一点自己已经有所体会，怎样让知识内化成自己心中的体系，让自己能举一反三，是需要自己一直思考的目前有效的学习方法一是写学习日记，二是写博客，但是绝不能成为知识的搬运工，而应该是知识的生产者对于知识一定要具有全局观念，一定要善于抓住主线，然后发展分支 0628现在的自己可以预见如果这样发展，到了三十岁，定会发生中年危机，因为即使坚持学习，我想也是跟不上技术更新的速度，所以十年后，Java也许不再流行，可这是自己现在苦心钻研，想以此为生的饭碗。所以作为程序员，要懂得些什么才可以不在潮流中被淘汰，这是今后自己需要一直思考的问题。我想最重要的一点就是保持开放的心态，接受新鲜事物，不故步自封。其次技术一定是有其本质的，我们学习重点一定是在这方面，这样不管技术如何变革，自己都能很快赶上脚步，甚至做出创新。计算机中有些课程为什么经久不衰，如数据结构与算法等，这些课程很大程度和数学挂钩，和生活挂钩，他们都是不脱离实际的知识，是经得起时间考验的知识。始终坚信一点知识永远是性感的，是可以用简洁通俗的话讲述出来的。学习永远都是”Tell me and I forgrt.Show me and I remember.Involve me and I understand.”，从实践中学习，一直都是我的学习方法，是我认为较有效的方法。作为程序员，时刻保持思考，时刻保持警惕，是一个良好的习惯，但放大了看，人生不都应该保持思考吗，不然意义何在。程序员除了要有对专业技术的热爱，还要学会将技术这个杠杆加长，这样才可以去撬动很伟大的目标，这个目标可以是创造一个改变世界的公司，创造无数的财富，总之善于利用自己手头的资源。有时跳出技术的圈子，去看看外面的世界 ，对自己会有莫大的帮助。多去拓展自己的眼界，多去外面的世界走走，多看看书，学点经济，学点心理，我想都是好的。 0613今天听了林菲院长的讲话，确有一种醍醐灌顶之感，很多想法不谋而合，一些常见的观点，如自主学习、眼界等，自然不必说，其他例如创新能力，确实是现在的自己没有意识到的今天做了一个说小不小，说大不大的决定，将导师换成了林菲老师，主要还是因为今天老师的一番话，让我觉得领导层的眼界确实不一样，之前上了一个月的课，不能说没有收获，但是不想现在就把研究领域限定在计算机视觉，想多涉猎涉猎，而且我想跟着院长，能获取的资源应该会更多一些，当然最根本的原因还是我觉得林菲老师应该不只是一个“授人以鱼”的老师，希望能找到一个好一点的人生导师吧 0530关于记笔记的一些小心得，对于数学方面，记笔记是更应该手写，并记录下推理过程，强化记忆并且复习，对于计算机方面，知识体系更为重要，写在电脑上，逻辑清楚，方便查看 0527最近一直在和学习过不去，离散数学没有找到学习方法，计算机的书啃完了，就没了，突然发觉现在到了要把书读薄的阶段了，就像面对一个新手，要怎么样把知识给叙述出来，即使是抽象较难的知识也能很好的阐述。这应该是接来下自己需要去做的事情。 0523最近的学习过程很难受，好像又失去了方向，《CSAPP》大部分都已经看完了，但仅限于看完了，《TIJ》也看的差不多了，《算法4》看了前四章，手头还有好多书想去看，但之前看的书还没复习、啃透，很矛盾的心理。现阶段有需要改变学习方针，加上马上也要开始了，新知识就先停下来，主要复习之前学过的知识，不仅是巩固更是深入，多整理，多反思。 0517博客已经有段时间没有更新了，总结一些最近两个星期的学习 CSAPP已经看得差不多了，对于这本书来说，精髓不在书，而在那九个lab上，接下来要做的就是配套实验，好好完成这些实验，才算是真正掌握这本书内的知识。 java学习方面还是遇到了一些苦难，主要是书上的一些知识点对于现阶段来说太深了，所以有些章节选择了跳过，linux学习有条不紊，继续努力 数学方面最近投入时间还是比较多的，主要是选择了英文版的教材，但真的受益匪浅，虽然说讲述的知识乍一看都是差不多的，但是当逐句阅读时，就是给人恍然大悟的感觉，比起国内教材就是要好很多。而且阅读过程也能学到不少英语单词，虽然耗时但是一举多得吧。 其实对于数学的学习，自己一直有个疑惑，怎样去界定是否学好了数学，是刷题得高分了，但不一定要求理解透彻？还是说理解透彻但是不一定能考高分？在大神身上也许这是可以兼顾的，但在我身上却不是，要么不停的刷题，要么多啃书，求理解内涵。我个人当然是倾向于去理解透而不是采取题海战术，但是当看到考试成绩时，明知道只要把习题集做一遍，就能拿高分，还是会有一丝不爽。 最近对数学的各个领域有所涉猎之后，我其实越发喜欢上数学了，找到了学习数学的乐趣，甚至有想转数学系的想法，当然这只是句戏言。数学中很多领域都是从实际问题出发，寻求一个令人信服的解决方法，并通过数理逻辑加以证明，最后还能从该方法出发，演绎发散出其他定理来，这就是我现阶段所体会到的数学的魅力。 最近申报暑假阿大访学，我就在问自己，为什么这么大个的便宜，却只有少部分人会去捡，后来想想，或许就是眼界的问题。一个很好的机会去认识外面的世界，结交不同的人。期待能在这次活动收获许多。 0503依旧是学习算法上的问题，单单是啃算法书，效率实在是太低了，对于算法的学习应该从题目出发，而不是一味的看书，最近啃《算法导论》，已经明显感觉到效率低下，所以今后的学习应该以题目为导向，具体如下：对于一个特定的算法或者数据结构，先看一遍知识点，对其有具体的了解，然后做题，总结。这几个步骤分别对应《算法》，《算竞》，《算导》 0422这个学期总也找不回来上个学期做题的感觉了，我也不知道为什么，总有一种抵触的情绪在那里，虽然意识到算法数据结构的重要性，但就是不愿意花时间在上面，上个学期做题虽然艰难，但能感觉到提升之大，虽然很多题目都是直接看的题解，但毕竟是初学者。不想再给自己找什么理由了，就是干，这学期的任务要把《算法竞赛入门经典》也加入进出，起到练习的作用 0421博客上的笔记越记越多，随着量的积累，开始思考，记笔记的意思所在，我现在记笔记单纯是在照着书上的知识点一个个抄一遍，或许可以理顺一遍知识点，但除此之外好像没什么意义。停下来思考一下，觉得除了理顺知识点之外，还要多加自己的思考，哪怕是一点点，所以今后的文章，多一些自己的思考，多一些自己的感悟，多一些即使是错误的但至少是属于自己的理解。多一些自己的思考，多一些自己的灵感，是现在的自己最欠缺的。 0406最近看的书有点多，所以要学会总结每本书都有不同的阅读方法，有些书带给你的是更深层次的抽象思考，有些书则是告诉你这件事是怎么回事，所以针对不同的书要快速找到适当的阅读方法每个学期前都会给自己定下目标，但好像都不能%100的完成，之前还怀疑是自己不够专一，现在想想是自己的境界思想时时刻刻在变，每个阶段想要的得到的东西都是在变化的，最重要的就是专注于自己当下在做的东西，切勿心急，同时兼顾自己所走的方向在《编码》这本书中看到这么一句话为学日益，为道日损，损之又损，以至于无为，无为而无不为，学习知识与就是要不断丰满完善，精益求精，当进入一线工作，逐步丢掉课堂中学习的概念、主义，把握现实规律，根据现状因地制宜做出反应并对现实规律概念的加深，脑海中的概念越来越少，即为道日损 0416对于批判性思维的思考：是一种对既有结论有进一步思考的能力，对问题的深度和广度以及逻辑性有自己的见解，但不等同于标新立异，为了质疑而质疑一直以来的学习习惯造就了自己如今的思维模式，很明显的一点就是面对课本中给出的定理，Ok这就是定理，我会用就可以了，而不会去思考他出现的原因，而且最近学习中发现自己一个很明显的缺点，就是对习题给出的证明都无从下手，就感觉自己只会做一些有固定套路的计算题，对这类很少接触的题目毫无招架之力]]></content>
  </entry>
  <entry>
    <title><![CDATA[《头号玩家》]]></title>
    <url>%2F2018%2F04%2F03%2F%E3%80%8A%E5%A4%B4%E5%8F%B7%E7%8E%A9%E5%AE%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一部充满彩蛋、动漫、游戏的电影，简直让人眼花缭乱，但这不电影除了满片的彩蛋外，还剩什么对于我这非游戏爱好者来说，电影中无数彩蛋对我来说不够有吸引力，但我看到了以下几点： 要注意这部电影的作者–斯皮尔伯格，《辛德勒的的名单》，《拯救大兵瑞恩》，《侏罗纪公园》，一步步经典之作，他就像电影中的哈利迪，一个是用自己的才华创造了一个“绿洲”，一个是电影艺术上的造梦者，创造一部又一部值的尊敬的电影，当电影结尾哈利迪说出那句”感谢你玩我的游戏“，这句话难道不是斯皮尔伯格想说的吗“感谢你看我的电影”。他们都是真诚而又极致的追求。 还有一点就是“现实很重要”]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa]]></title>
    <url>%2F2018%2F04%2F01%2FUVa%2F</url>
    <content type="text"><![CDATA[《算法竞赛入门经典》例题及习题解题总结 每篇都有题目链接和完整代码，并有题目分析和总结 UVa514 UVa572 UVa227 UVa455 UVa12657（附对拍教程）：链表 UVa122（附sscanf函数） UVa548 UVa839：二叉树递归遍历]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ]]></title>
    <url>%2F2018%2F04%2F01%2FHDOJ%2F</url>
    <content type="text"><![CDATA[HDOJ水题解题报告 HDOJ2899 HDOJ1233 HDOJ1176 HDOJ1421 HDOJ1215 HDOJ1297 HDOJ1232 HDOJ1325 HDOJ1010]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-第六章]]></title>
    <url>%2F2018%2F03%2F31%2FLinux-%E7%AC%AC%E5%85%AD%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[《鸟哥的Linux私房菜》第六章小结 用户和用户组Linux的多用户、多任务环境使得每个用户对文件的权限管理变得很重要，如果权限设定不当，其他用户就可能随意修改自己的文件。一个很重要的概念：任何设备在Linux下面都是文件，包括数据通信的接口都由专门的文件负责 文件可存取访问的身份有owner、group、others，每种身份各有read、write、excute权限 用户组：处在不同用户组的用户，不能互相阅览文件，处在相同用户组的用户可以互相查看修改文件，当然自己修改成连自己用户组成员也看不到的私密文件，就像日记本一样。 一个用户组的用户相对于另一个用户组的用户来说是others，others可以通过“结识”其他用户组的用户，来进入该用户组查看文件内容 对于不同用户组，可以设置一个“上帝”，“上帝”可以同时查看不同用户组的文件内容。 文件权限通过命令ls -al ~查看所有文件的权限和属性接下来一列一列解释其中的含义 第一列有每行都有十个字符，第一个字符表示改文件是目录、文件还是链接文件，[d]-目录，[-]-文件，[l]-连接文件,[b]-设备文件里面的可供存储的接口设备，[c]-串行端口设备，例如键盘、鼠标；接下来九个字符，三个一组为rwx参数的组合，[r]-可读，[w]-可写，[x]-可执行，三组分别对应文件所有者、同用户组和其他非本用户组的权限 第二列表示有多少文件连接到此节点，这个知识点不怎么明白 表示文件所有者 表示文件的所属用户组 文件大小，单位为B 文件的创建日期或者最近修改日期 文件名 修改文件属性和权限 修改所属的用户组：chgrp（change group），从图中看到.bashrc文件的用户组从root变为了xzy 修改文件的所有者：chown（change owner） 数字类型改变权限：chmod，权限设置有数字和符号两种来表示，符号r对应数字4，w对应2，x对应1，例如权限rwxrwx---对应数字就是770，如下图所示.bashrc权限从rw-rw-r--变为了rwxrwxrwx 符号类型修改文件权限：u，g，o分别对应三种身份，a代表全部身份，如下图所示 权限对文件的意义 r：可以读取文件的实际内容 w：可以编辑、修改文件内容，但不能删除文件 x：具有可执行的权限 权限对目录的意义 r：可以读取该目录下的文件名数据 w：可以新建文件和目录；删除已存在的文件和目录（不论该文件的权限如何）；重命名已有的文件；转移文件、目录的位置 x：代表用户能否进入该目录成为工作目录12345678[root@localhost xzy]# cd /tmp //切换工作目录到/tmp[root@localhost tmp]# mkdir test //新建新目录[root@localhost tmp]# chmod 744 test //修改权限[root@localhost tmp]# touch test/test //创建新的文件[root@localhost tmp]# chmod 600 test/test //修改权限[root@localhost tmp]# ls -ald test test/test //查看drwxr--r--. 2 root root 18 Mar 31 20:07 test-rw-------. 1 root root 0 Mar 31 20:07 test/test 刚创建的文件、目录均属于root，那对一般用户具有什么权限呢？从图中可以看到虽有具有r权限，但仍然无法查看，又因为不具有x权限，自然没有进入的权限当我们修改文件的归属，就可以进入该文件，并进行删除，x和能否进入该目录有关，而w则能对文件进行操作 文件种类和扩展名常见文件种类，如普通文件，纯文本文件，二进制文件再比如数据格式文件，目录，连接文件，设备与设备文件（块设备文件如硬盘，字符设备文件如鼠标），套接字，管道 在Windows下，能被执行的文件扩展名有.com,.exe,.bat，但在linux下文件能否被执行取决于文件是否有x权限，但执行是否成功则取决于文件本身，因此扩展名能反映在能执行的条件下，文件能否执行成功，常见扩展名如*.sh,*.Z,*.tar,.html等 目录配置（FHS）对于不同的distributions目录配置为什么都极其相似，因为他们都遵循FHS标准 目录有四种交互形态： 可分享的：能供网络上其他主机挂载使用的目录，如/var/mail（用户邮件） 不可分享的：和自己的机器或者程序相关的设备文件，如/boot 不变的：如函数库 可变动的：如登录文件 FHS仅定义出三层目录下应该放置什么东西 /：根目录，与开机系统相关，所有目录都由根目录衍生出来，根目录还和开机、还原、系统修复相关，由于其重要性，将根目录所在分区尽量最小化，不要和其他文件混合在一起，防止出错 /usr：UNIX software resource,与软件安装执行相关 /var：与系统运作过程相关 重要子目录 /bin：放置在其下的命令在单用户模式下，被root和一般用户使用，如cat,chmod /boot：放置开机会使用到的文件，如Linux内核文件及其开机菜单 /dev：只有通过访问该目录下的文件，才可以访问对应的设备和接口设备 /etc：系统的配置文件 /home：用户的主文件夹，子目录中包含各用户的文件夹 /lib：放置开机时用到的函数库 /sbin：放置开机时需要的命令，用来设置系统，如fdisk,fsck /usr：注意usr不是用户数据的意思，而是UNIX操作系统软件资源]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F03%2F31%2FCLRS-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[MergeSort 算法形式分治法：对于每次递归的调用自身去解决相关问题的子问题的算法，均遵循了分治法的思想：将原问题分解为规模较小的子问题（子问题的形式应该类似于原问题），递归求解子问题，然后合并子问题的解，形成原问题的解 分治模式在每层递归是有三个步骤： 分解 解决 合并 对于归并排序算法,当序列被分解为长度1时，递归开始回升，算法的关键在于合并两个已经排列好的序列，调用MERGE(A,p,q,r)来完成这个操作，其中A[p..q]和A[q+1..r]都分别排序好，合并两个数组得到A[p,r],该合并操作最多执行$r-p+1$次操作，因此需要$\Theta(n)$的时间伪代码：123456789101112131415MERGE(A,p,q,r)n1 = q-p+1n2 = r-qlet L[1..n1+1] and R[1..n2+1] be new arrayscopy A[p..q],A[q+1..r] to L[1..n1],R[1..n2]L[n1+1] = MaxR[n2+1] = Maxi = 1j = 1for k = p to r if L[i]&lt;=R[j] A[k] = L[i] i++ else A[k] = R[j] j++ 这里有个小技巧，就是将每堆底部放一张哨兵牌，并将其设置为$\infty$,因此当一堆出现$\infty$牌时，不可能出现比它大的牌，于是形式上相当于将另一堆直接放置到输出堆 算法证明循环不变式:$A[p..k-1]$按从小到大的顺序包含$L[1..n1+1]$和$R[1..n2+1]$中的k-p个最小元素，$L[i]$和$R[j]$是各自数组中未被复制回A数组的最小元素 初始化：A数组为空，$L[1]$和$R[1]$都是各自数组的最小元素 保持：假设$L[i] \le R[j]$,这时$A[p..k-1]$包含$k-p个$最小元素，将$L[i]$复制到$A[k],A[p..k]$包含$k-p+1个$元素，更新$k$和$i$，可见循环不变式依旧成立 终止：$k=r+1$,$A[p..r]$即按从小到大排列，数组$L$和$R$只剩下哨兵没有被赋值会数组A 算法分析 解决子问题需要$2T(n/2)$的运行时间 合并一个n大小的数组需要$\Theta(n)$ 因此归并排序的最坏运行时间$T(n)=2T(n/2)+\Theta(n)(n&gt;1)$ 通过画递归树，每层的代价都是$cn$,总层数为$lgn+1$,总代价即为$cn(lgn+1)=cnlgn+cn$,忽略低阶项和常量$c$便得出$T(n)=\Theta(nlgn)$ 源代码 C++ 习题解答Ex2.3-3当n刚好是2的幂时，用数学归纳法证明下列递归式的解是$T(n)=nlgn$，$T(n)=2T(n/2)+n(n=2^k,k&gt;1)$设$n=2^k$当$n=2$时，$k=1$,$T(2)=2lg2=2$成立当$n&gt;2$时，假设$T(2^k)=2^klg2^k$成立则$T(2^{k+1})=2T(2^{k+1}/2)+2^{k+1}=2^{k+1}lg2^{k+1}$得证 Ex2.3-4为插入排序的递归版本的最坏情况写一个递归式$T(n)=T(n-1)+n-1(n&gt;1)$ Ex2.3-5为二分查找写递归的伪代码，并判断最坏情况的运行时间为$\Theta(lgn)$12345678binary_search(A,low,high,key)mid=(low+high)/2if(A[mid]=key)return midelse if(A[mid]&lt;key) binary_search(A,mid,high,key)else if(A[mid]&gt;key) binary_search(A,low,mid,key)return null 利用与Ex2.3-3类似的数学归纳法可证明结论成立 算法改进在归并算法中对小数组采用插入排序，当子问题足够小时，采用插入排序来使递归的叶变粗 使用插入排序来排序长度为k的n/k个子表，然后使用标准合并机制来合并这些子表，最坏的情况是在$n/k\Theta(k^2)=\Theta(nk)$的时间内完成排序 最坏的情况下能在$\Theta(nlg(n/k))$的时间内合并子表 修改后的归并排序算法最坏运行时间为$\Theta(nk+nlg(n/k))$,并且$k&lt;\Theta(lgn)$,否则增长率将超过原来的算法 对于k的取值，因为我们选取插入算法是为了改善，所以原本应该使用归并算法的部分应有$c_1k^2&lt;c_2klgk$,得到k的取值范围]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2018%2F03%2F30%2FCLRS-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[InsertionSort 算法形式插入排序类似于摸牌的时候人们整理牌的过程，摸牌结束时，手中的牌就是排序好的伪代码：123456789IMSERTION_SORT(A)//对数组A进行插入升序排序for j = 2 to A.length key = A[j] //将A[j]插入已排序好的A[1..j-1] i = j - 1 while i &gt; 0 and A[i] &gt; key A[i+1] = A[i] i = i - 1 A[i+1] = key//将正在排序的元素插入适当的位置 算法证明A[1..j-1]就是原来1到j-1的元素，且已经按序排好，把这种形式地表示为一个循环不变式，它能证明算法的正确性 初始化：首先在循环迭代开始前（j=2），子数组A[1..j-1]就是由单个数字组成，显然循环不变式成立 保持：for循环将A[j-1]、A[j-2]、A[j-3]向右移动一个位置，直到A[j]找到合适的位置，最后将其插入 终止：循环终止条件：j&gt;A.length,显然此时j=A.length+1,带入循环不变式得，A[1..A.length]以按序排列，该不变式即表示整个数组，验证了算法的正确性 算法分析每行语句的运行成本是由该语句运行一次的成本和运行次数决定的设n=A.length,单次运行成本为$C_i$,$t_j$表示对j执行while循环的次数，因为该值和输入数据的形式相关，所以他是不确定的 例如第二行for循环的单次运行成本为c$_1$,次数为n-1,则该行的的运行成本为c$_1$*(n-1)，对于while循环为:$c_4$($\sum_{j=2}^n t_j$) 当我们考虑输入数据已经排好序了，即最佳情况时，while循环只进行一次，而内部操作则为零次最终总时间为$T(n)=(c_1+c_2+c_3+c_4+C_7)n-(c_2+c_3+c_4+c_7)$,将语句代价$c_i$抽象为常量a,b等，则运行时间可表示为$T(n)=an+b$,它是n的线性函数 如果数组是反向排序，即遇到了最坏的情况，此时上文设置的$t_j=j$,所有最终结果为$T(n)=an^2+bn+c$,是n的二次函数 源代码 python C++]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章：程序的机器级表示（2）]]></title>
    <url>%2F2018%2F03%2F29%2FCSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[《CSAPP》第三章小结（续） 《深入理解计算机系统》 算术和逻辑操作下图是常见的指令 加载有效地址leaq该指令实际是movq的变形，但它实际上根本没有引用内存，并不是从第一个操作数指定的位置读入数据，而是将有效地址写入目的操作数,例如%rax的值为x，那么指令leaq 7(%rdx,%rdx,4),%rax将设置寄存器%rax的值为5*x+712345long scale(long x,long y,long z)&#123; long t = x+4*y+12*z; return t;&#125; 123456789scale:.LFB0: .cfi_startproc leaq (%rdi,%rsi,4), %rcx //x+4*y leaq (%rdx,%rdx,2), %rax //z+2*z salq $2, %rax //3*z左移两位为12*z addq %rcx, %rax //x+4*y+12*z ret .cfi_endproc 一元和二元操作一元操作的操作数既是源又是目的，可以是内存也可以是寄存器。例如incp(%rsp)将是栈顶的八字节加一，类似于c语言中的++和–运算符二元操作的第二个操作数既是源又是目的，类似于x-=y。不过源操作数是第一个，目的操作数第二个，例如指令subq %rax,%rdx是从%rdx中减去%rax，第二个操作数不能是立即数，并且如果是内存地址时，必须先读出值，执行操作，再写入内存 移位操作先是移位量，再是要移位的数，移位量可以是立即数，或者放在%cl寄存器中，特别规定只能以该寄存器作为操作数。移位操作对w位长的数据值进行操作，移位量是由寄存器的低m位决定的，并且$2^m=w$,高位自动忽略。例如%cl的值为OxFF时，指令salb左移7位，salw左移15位，sall左移31位，salq左移63位，这块地方依旧有些不明白。左移指令有SAL和SHL，效果相同，都是右边补0右移指令有SAP和SHR，SAR执行算术移位（填上符号位），SHR执行逻辑移位（填上0）123456long shift(long x,long n)&#123; x&lt;&lt;=4; x&gt;&gt;=n; return x;&#125; 123456789shift:.LFB0: .cfi_startproc movq %rdi, %rax salq $4, %rax movl %esi, %ecx sarq %cl, %rax ret .cfi_endproc 另一个例子,寄存器%rax分别存储了不同的程序值，并在寄存器之间传送程序值12345678long arith(long x,long y,long z)&#123; long t1 = x^y; long t2 = z*48; long t3 = t1 &amp; 252645135; long t4 = t2 -t3; return t4;&#125; 1234567891011//x,y,z分别放在%rdi，%rsi，%rdxarith:.LFB0: .cfi_startproc xorq %rsi, %rdi //x^y异或 leaq (%rdx,%rdx,2), %rax //3*z salq $4, %rax //16*(3*z) andl $252645135, %edi //t1 &amp; Ox252645135 subq %rdi, %rax //t2-t3 ret .cfi_endproc 一个小技巧1234xorq %rdx,%rdx 根据异或的特性，相同取0，不同取1，对自己异或就是清零也可以用movq $0,%rax 来实现两种操作的字节长度不同，这里有点不明白 特殊的算术操作两个64位有符号或无符号整数相乘得到的乘机需要128位来表示，下图描述的就是产生两个64位数字的全128位乘机以及整数除法的指令imulq指令有两种形式 一种是IMUL类中双操作数的一种，他将从两个64位操作数产生一个64位乘积 另一种则是单操作数指令，计算两个64位值的全128位乘机，一个是无符号乘积mulq，另一是补码乘法imulq。这两条指令都要求一个参数必须在寄存器%rax中，另一个作为指令的源操作数给出，然后将乘积放在%rdx（高64位）和%rax（低64位）中汇编器会自动分辨该使用上述那条指令 例子展示将两个无符号64位数字乘积生成128位数字,首先显式的定义两个64位数字x、y，并用typedef定义uint128_t，指明乘积放在指针dest指向的16字节处12345678#include&lt;inttypes.h&gt;typedef unsigned __int128 uint128_t;void store_uprod(uint128_t *dest,uint64_t x,uint64_t y)&#123; *dest=x*(uint128_t)y;&#125; 123456789store_uprod:.LFB4: .cfi_startproc movq %rsi, %rax //将x复制到%rax mulq %rdx //y*x movq %rax, (%rdi) //存储低8字节 movq %rdx, 8(%rdi) //存储高8字节 ret .cfi_endproc 有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出，商存储在%rax，余数存在%rdx对于64位除法来说，被除数也是64位值，这个值如上所述，存在%rax中，而%rdx的位设置为全0（无符号运算）或者%rax的符号位（有符号运算），该设置的指令将有cpto完成，具体如下所示1234567void remdiv(long x,long y,long *pq,long *rq)&#123; long q=x/y; long r=x%y; *pq=q; *rq=r;&#125; 123456789101112//x in %rdi,y in %rsi,pq in %rdx,rp in %rcxremdiv:.LFB0: .cfi_startproc movq %rdx, %r8 //因为除法操作用到%rdx，所以copy pq to %r8 movq %rdi, %rax //move x to %rax cqto //扩展高8字节 idivq %rsi //x/y movq %rax, (%r8) //存储商 movq %rdx, (%rcx)//存储余数 ret .cfi_endproc 控制条件码CPU维护着一组单个位的条件码寄存器，描述最近的算术或者逻辑操作的属性，可以通过检测这些条件码寄存器来执行条件分支指令。 CF：进位标志，检查最高位是否产生进位，用来标志无符号溢出 ZF：标志操作结果是否为0 SF：操作结果是否为负数 OF：操作是否导致补码溢出–正溢出或负溢出 如本文一幅图所示，除了leap不改变条件码寄存器，其余操作均要设置条件码，还有两类操作也会设置条件码 CMP：根据两个操作数之差设置条件码，除了不更新目的寄存器以外，和SUB指令行为一样 TEST：和AND指令行为类似，例如testq %rax，%rax来检查%rax是负数还是0或者是整数 一般有三种使用条件码的方法，第一种根据条件码的组合，将一个字节设置为0或1，这类指令成为SET指令，这类指令的后缀不代表操作数的大小，而是指明条件码的组合，如下图所示1234int cmp(int a,int b)&#123; return a &gt; b;&#125; 12345678cmp:.LFB0: .cfi_startproc cmpl %esi, %edi //比较a，b setg %al //设置低位单字节寄存器为0或1 movzbl %al, %eax //为了得到一个32位或64位结果，要进行零位扩展，将寄存器的高位清零 ret .cfi_endproc 跳转指令跳转的目的地一般用label表明，产生目标代码文件时，汇编器会确定所有带label指令的地址，并将目的指令的地址编码为跳转指令的一部分 直接跳转：以label为目标直接跳转 间接跳转：跳转目标从寄存器或者内存位置读出，一般带有*号 最常见的是PC相对编码，将目标指令的地址与紧跟在跳转指令后面那条指令的地址的差作为编码，另一种则是给出绝对地址，用四字节直接指定目标，汇编器和链接器会选择合适的跳转目的编码，所以跳转指令的地址=目标指令的地址-跳转指令后一条指令的地址，当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的的地址，而不是跳转指令本身的地址通过PC相对的跳转目标编码，将很容易将目标代码迁移至内存中该图是链接后的反汇编版本，其中有两个跳转指令jmp、jg,其中jmp目的地址等于下一条指令地址0x4004d5加上相对编码03得到0x4004d8,同理jg的目的地址等于0xd+0xf8=0xd5,因为f8对应十进制-8 条件控制实现条件分支刚学习的时候比较语句例如cmpq $-3, %rdi和jge .L2其实合起来相当于是else的条件而不是if的条件，当时理解的时候出现了偏差1234567891011long test(long x,long y,long z)&#123; long val = x+y+z; if(x&lt;-3)&#123; if(y&lt;z) val=x*y; else val = y*z; &#125;else if (x&gt;2) val = x*z; return val;&#125; 123456789101112131415161718192021222324test:.LFB0: .cfi_startproc leaq (%rdi,%rsi), %rax addq %rdx, %rax cmpq $-3, %rdi jge .L2 cmpq %rdx, %rsi jge .L3 movq %rdi, %rax imulq %rsi, %rax ret.L3: movq %rsi, %rax imulq %rdx, %rax ret.L2: cmpq $2, %rdi jle .L4 movq %rdi, %rax imulq %rdx, %rax.L4: rep ret .cfi_endproc 条件传送来实现条件分支基于条件数据传送的代码会比基于条件控制转移的代码性能更好，这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。为什么条件数据传送的代码性能好： 处理器通过该使用流水线的重叠连续指令来获得高性能 当机器遇到条件跳转时，一般是在分支条件求值完成后，决定分支往哪走，但是处理区采用非常精密的分支预测逻辑才猜测每条跳转指令是否执行 但是如果预测错误，就要丢掉处理器为该跳转指令后所有指令做的工作然后回到正确位置重新计算，这一步的代价是很高的 因此如果是采用条件控制转移猜测x&gt;y时，猜对的概率也只有%50，而分支中的操作只需要很小消耗时，分支预测错误就主导了函数的性能， 但是如果我们先计算出分支条件，就不存在预测错误的机会 条件传送使用的限制很多，比如分支操作不能有副作用、求值计算不能太多 12345#define OP /long arith(long x)&#123; return x OP 8;&#125; 该程序创建一个临时值为x+7，预计x为负。当cmovns指令在x&gt;=0成立时才把临时值修改为x，再算术右移3位123456789arith:.LFB0: .cfi_startproc leaq 7(%rdi), %rax temp=x+7 testq %rdi, %rdi Test x cmovns %rdi, %rax if x&gt;= 0 ,temp=x sarq $3, %rax return temp&gt;&gt;4=3 ret .cfi_endproc 循环汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果 do-while循环 while循环：有两种翻译方式，跳转到中间(jumo to middle)和guarded-do，当较高级优化时，GCC会采取后者这种策略 12345678//jumo to middle的goto代码模板 goto testloop: body-statementtest: t=test-expr; if(t) goto loop; 12345678910//guarded-do的goto代码模板t=test-expr;if(!t) goto done;loop: body-statement t=test-expr; if(t) goto loop;done: 这段代码使用jump to middle翻译方法产生以下汇编代码，该代码计算x的奇偶性，也就是如果x中有奇数个1，就返回1，如果有偶数个1，就返回0,这段代码还是不理解12345678long fun_a(unsigned long x)&#123; long val = 0; while(x != 0)&#123; val ^= x; x &gt;&gt;= 1; &#125; return val &amp; 0x1;&#125; 1234567891011121314fun_a:.LFB0: .cfi_startproc movl $0, %eax jmp .L2.L3: xorq %rdi, %rax shrq %rdi.L2: testq %rdi, %rdi jne .L3 andl $1, %eax ret .cfi_endproc for循环:可以转化成while循环 12345678910//jump to middle的goto模板init-expr;goto test;loop: body-statement; update-expr;test: t=test-expr; if(t) goto loop; 123456789101112//guarder-to的goto模板init=expr;t=test-expr;if(!t) goto done;loop: body-statement; update-expr; t=test-expr; if(t) goto loop;done: 这段代码是将x的位反转，产生镜像，123456789long fun_b(unsigned long x)&#123; long val = 0; int i ; for(i = 64; i != 0 ; i++)&#123; val = (val &lt;&lt; 1) | (x &amp; 0x1); x &gt;&gt;= 1; &#125; return val;&#125; 123456789101112131415161718fun_b:.LFB0: .cfi_startproc movl $64, %edx movl $0, %eax jmp .L2.L3: addq %rax, %rax movq %rdi, %rcx andl $1, %ecx orq %rcx, %rax shrq %rdi addl $1, %edx.L2: testl %edx, %edx jne .L3 rep ret .cfi_endproc switch语句通过使用跳转表，实现多重分支，这样switch即使有上百种情况，也能只用一次跳转表访问处理123456789101112131415161718192021void switch_eg(long x,long n,long *dest)&#123; long val = x; switch(n)&#123; case 100: val*=13; break; case 102: val+=10; case 103: val+=11; break; case 104: case 106: val*=val; break; default: val=0; &#125; *dest=val;&#125; 12345678910111213141516171819202122232425262728293031323334353637switch_eg:.LFB0: .cfi_startproc subq $100, %rsi cmpq $6, %rsi ja .L8 jmp *.L4(,%rsi,8) //间接跳转 .section .rodata //只读的目标代码文件的段中 .align 8 .align 4.L4: //标记分配地址的开始，作为间接跳转的基地址 .quad .L3 .quad .L8 .quad .L5 .quad .L6 .quad .L7 .quad .L8 .quad .L7 .text.L3: leaq (%rdi,%rdi,2), %rax leaq (%rdi,%rax,4), %rdi jmp .L2.L5: addq $10, %rdi.L6: addq $11, %rdi jmp .L2.L7: imulq %rdi, %rdi jmp .L2.L8: movl $0, %edi.L2: movq %rdi, (%rdx) ret .cfi_endproc 过程是一种很重要的抽象，提供一种封装代码的方式，来实现摸个特定的功能，但却隐藏行为的具体实现，又提供清晰间接的接口定义。过程调用主要有以下几个机制： 传递控制 传递数据 分配和释放内存 运行时栈该机制的关键在于使用了栈数据结构提供的先进先出的内存管理机制例如在Q执行时，先前调用Q的P调用链处在挂起的状态，Q可以在属于自己的存储空间中分配，当Q返回时，所分配的局部存储空间都可以被释放。可以通过减小栈指针来分配空间，通过增加栈指针来释放空间，如果寄存器不够拿来分配，就会在栈中分配空间，如下图所示 转移控制通过call指令来实现函数调用，该指令call Q会将PC设置为Q的起始地址，并将紧跟在call指令后面的那条指令压入栈中，成为返回地址。对应ret指令会从栈中弹出返回地址,并将会PC设置为返回地址。这种简单的机制和多数程序语言的调用/返回机制吻合。 数据传送数据传送大多通过寄存器实现，并最多传递6个整数，寄存器的使用也是有特殊顺序的，如下图所示超过6个的部分就要通过栈来传递12345678910void proc(long a1,long *a1p, int a2,int *a2p, short a3,short *a3p, char a4,char *a4p)&#123; *a1p+=a1; *a2p+=a2; *a3p+=a3; *a4p+=a4;&#125; 1234567891011proc:.LFB0: .cfi_startproc movq 16(%rsp), %rax addq %rdi, (%rsi) addl %edx, (%rcx) addw %r8w, (%r9) movl 8(%rsp), %edx addb %dl, (%rax) ret .cfi_endproc 这个实例说明第7和8个参数位于栈指针距离8和16的位置上，返回地址也被压入栈中 局部数据有些时候需要将局部数据存放在内存中,例如 寄存器不够存放本地数据 需要地址运算符&amp;，此时就必须为它产生一个地址 数组或者结构时，需要通过数组或结构引用才能访问到 运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制1234567long call_proc()&#123; long x1 =1;int x2 = 2; short x3 = 3;char x4 = 4; proc(x1,&amp;x1,x2,&amp;x2,x3,&amp;x3,x4,&amp;x4); return (x1+x2)*(x3-x4);&#125; 12345678910111213141516171819202122232425262728293031call_proc:.LFB0: .cfi_startproc subq $40, %rsp .cfi_def_cfa_offset 48 movq $1, 24(%rsp) movl $2, 20(%rsp) movw $3, 18(%rsp) movb $4, 17(%rsp) leaq 17(%rsp), %rax movq %rax, 8(%rsp) movl $4, (%rsp) leaq 18(%rsp), %r9 movl $3, %r8d leaq 20(%rsp), %rcx movl $2, %edx leaq 24(%rsp), %rsi movl $1, %edi movl $0, %eax call proc movslq 20(%rsp), %rdx addq 24(%rsp), %rdx movswl 18(%rsp), %eax movsbl 17(%rsp), %ecx subl %ecx, %eax cltq imulq %rdx, %rax addq $40, %rsp .cfi_def_cfa_offset 8 ret .cfi_endproc 大部分指令都在为调用proc做准备，其中包括为局部变量和函数参数建立栈帧，当调用其他函数时，就可以根据相对于%rsp位置来修改参数值，当程序返回调用函数时，就会取出这些局部变量，并执行最后的运算。程序结束时，将栈指针增加，释放栈帧。 由于寄存器是所有过程共享的资源，为了防止被调用者不会覆盖调用者的寄存器值，根据惯例规定，寄存器%rbx %rbp %r12~%r15都被划分为被调用者保存寄存器，当过程Q保存一个寄存器的值时，要么不去改变，要么把原始值先压入栈中，然后改变寄存器的值，然后再返回前从栈中弹出旧值，压入的值存在栈帧中“保存的寄存器”的特殊部分，这样调用者就能把值安全得保存在寄存器中 递归递归调用一个函数本身与调用其他函数是一样的，每次函数调用都有它自己的私有状态信息存储空间]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章：程序的机器级表示（1）]]></title>
    <url>%2F2018%2F03%2F29%2FCSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序的每一条指令，然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。汇编代码是机器代码的文本表示，对于严谨的程序员来说，能够阅读和理解汇编代码是一项很重要的技能 《深入理解计算机系统》 程序编码对于机器级编程，两种抽象极其重要 一种是指令集体系结构或指令集架构：定义了处理器状态、指令格式，以及每条指令对状态的影响 另一种是使用的内存地址是虚拟地址，提供的内存模型看上去是一个连续很大的字节数组 一些对程序员隐藏的处理器状态将会在机器代码中可见 程序计数器（PC，%rip）：表示将要执行的下一条指令在内存的地址 整数寄存器文件：存储地址（对应与c语言的指针）或是整数数据，有的记录重要的程序状态，有的保存临时数据，如过程参数、局部变量和函数返回值 条件码寄存器：保存算术或者逻辑指令的状态信息，实现控制或者数据流的条件变化 向量寄存器：存放整数或浮点数值 c语言中可以声明各种数据类型，但在机器代码中，这些对象只是一个很大的字节数组，机器代码不区分有符号无符号，也不区分指针和整数 假设有一个mstore.c文件，包含以下内容1234567long mult2(long,long);void multstore(long x,long y ,long *dest)&#123; long t = mult2(x,y); *dest = t;&#125; 输入以下命令，就将产生一个汇编文件mstore.s1[xzy]# gcc -Og -S mstore.c 123456789101112131415//汇编文件mstore.s，所有以&quot;.&quot;开头的都是指导汇编器和链接器工作的伪指令，阅读时可忽略multstore:.LFB0: .cfi_startproc pushq %rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movq %rdx, %rbx call mult2 movq %rax, (%rbx) popq %rbx .cfi_def_cfa_offset 8 ret .cfi_endproc 如果进一步使用以下指令，将产生目标代码文件mstore.o，对于这类二进制格式，一般是无法查看的1[xzy]# gcc -Og -c mstore.c 但我们可以通过反汇编器，根据机器代码产生类似于汇编代码的格式，例如我们可以输入以下命令，查看mstore.o1[xzy]# objdump -d mstore.o 产生如下文件1234567891011mstore.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;multstore&gt;: 0: 53 push %rbx 1: 48 89 d3 mov %rdx,%rbx 4: e8 00 00 00 00 callq 9 &lt;multstore+0x9&gt; 9: 48 89 03 mov %rax,(%rbx) c: 5b pop %rbx d: c3 retq 其中左边给出的就是二进制文件中的14个十六进制字节值，每行都对应右边的汇编语言，表示一条指令，且这些写反汇编语言具有以下特性: 指令长度从1到15个字节不等 从某一位置开始，将字节唯一地解码成机器指令，例如push %rbx就是从字节值53开头 反汇编器是根据机器代码文件中（mstore.o）的字节序列确定的汇编代码，不需要访问源代码或者汇编代码 反汇编代码和汇编代码还是有一些细微差别，如push和pushq，q表示操作数大小指示符大多数情况可以省略 要生成可执行代码还需要运行链接器去链接一组目标代码文件，并且这组目标代码文件中有且只有一个main函数123456789101112131415#include&lt;stdio.h&gt;void mulstore(long,long,long*);int main()&#123; long d; multstore(2,3,&amp;d); printf("2*3 --&gt; &amp;ld\n",d); return 0;&#125;long mult2(long a,long b)&#123; long s = a*b; return s;&#125; 通过以下命令就能生成可执行文件prog1[xzy]# gcc -Og -o prog main.c mstore.c 通过反汇编查看prog文件1[root@localhost xzy]# objdump -d prog 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748prog: file format elf64-x86-64Disassembly of section .init:00000000004003e0 &lt;_init&gt;: 4003e0: 48 83 ec 08 sub $0x8,%rsp 4003e4: 48 8b 05 0d 0c 20 00 mov 0x200c0d(%rip),%rax 4003eb: 48 85 c0 test %rax,%rax 4003ee: 74 05 je 4003f5 &lt;_init+0x15&gt; 4003f0: e8 3b 00 00 00 callq 400430 &lt;__gmon_start__@plt&gt; 4003f5: 48 83 c4 08 add $0x8,%rsp 4003f9: c3 retq Disassembly of section .plt:...000000000040052d &lt;main&gt;: 40052d: 48 83 ec 18 sub $0x18,%rsp 400531: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400536: be 03 00 00 00 mov $0x3,%esi 40053b: bf 02 00 00 00 mov $0x2,%edi 400540: b8 00 00 00 00 mov $0x0,%eax 400545: e8 26 00 00 00 callq 400570 &lt;multstore&gt; 40054a: 48 8b 74 24 08 mov 0x8(%rsp),%rsi 40054f: bf 10 06 40 00 mov $0x400610,%edi 400554: b8 00 00 00 00 mov $0x0,%eax 400559: e8 b2 fe ff ff callq 400410 &lt;printf@plt&gt; 40055e: b8 00 00 00 00 mov $0x0,%eax 400563: 48 83 c4 18 add $0x18,%rsp 400567: c3 retq 0000000000400568 &lt;mult2&gt;: 400568: 48 89 f8 mov %rdi,%rax 40056b: 48 0f af c6 imul %rsi,%rax 40056f: c3 retq 0000000000400570 &lt;multstore&gt;: 400570: 53 push %rbx 400571: 48 89 d3 mov %rdx,%rbx 400574: e8 ef ff ff ff callq 400568 &lt;mult2&gt; 400579: 48 89 03 mov %rax,(%rbx) 40057c: 5b pop %rbx 40057d: c3 retq 40057e: 66 90 xchg %ax,%ax... 这份完整代码不仅包括两个函数，还包括启动和终止程序的代码，以及用来与操作系统交互的代码，其中一段节选和之前看到的mstore.c反汇编产生的代码几乎一样123456780000000000400570 &lt;multstore&gt;: 400570: 53 push %rbx 400571: 48 89 d3 mov %rdx,%rbx 400574: e8 ef ff ff ff callq 400568 &lt;mult2&gt; 400579: 48 89 03 mov %rax,(%rbx) 40057c: 5b pop %rbx 40057d: c3 retq 40057e: 66 90 xchg %ax,%ax 但是依旧有几点很重要的区别 左边的地址不同，链接器将这段代码的地址移到了一段不同的地址范围中 链接器为callq指令调用函数mult2填写了需要的地址400568 多了最后一行代码，虽然和书中实例不同，但应该是出于存储器系统性能考虑，使函数代码变为16字节 数据格式用字（word）表示16位数据类型，32位数为双字，64位为四字。汇编代码指令都有一个字符的后缀，表明操作数的大小。如movb（传送字节），movw（传送字），movl（传送双字），movq（传送四字） 访问信息一个CPU包含一组16个存储64位值的通用目的寄存器，用来存储整数数据和指针。图中不同颜色的方框标明，指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作，字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，64位则可以访问整个寄存器。所有寄存器中最特别的是栈指针%rsp，用来标明运行时栈的结束位置 操作数一个指令往往有多于一个的操作数，操作数可分为三种类型 立即数：用来表示常数值，如$-577或者$Ox1F 寄存器：R[r]表示寄存器的值 内存引用：根据计算出来的地址访问某个内存位置，M[Addr]表示地址Addr的值，并且有多种寻址模式，如下图所示 指令我们将具有相同操作效果但操作数不同的指令划为一类最简单的数据传输指令-MOV类，把数据从源位置复制到目的位置，有movb、movw、movl、movq，分别对应操作数大小为1、2、4、8字节。源操作数指定的值是一个立即数，存储在寄存器或者内存中。目的操作数指定一个寄存器或者一个内存位置。指令最后一个一个字符必须与寄存器的大小匹配。12345movl $Ox4050,%eax 立即数-&gt;寄存器movw %bp,%sp 寄存器-&gt;寄存器movb (%rdi,%rcx),%al 内存-&gt;寄存器movb $-17,(%rsp) 立即数-&gt;内存movq %rax,-12(%rbp) 寄存器-&gt;内存 通过指令将较小的源值复制到较大的目的，这种指令分为两类：MOVZ类和MOVS类。MOVZ类将目的中的剩余字节填充为0，而MOVS类通过符号扩展来填充。 123456//注意-1的十六进制表示为FF...FFFmovabsq $Ox0011223344556677,%rax %rax = 0011223344556677 //初始化为位模式movl $-1,%al %rax = 00112233445566FF //把%rax的低位字节设置为FFmovl $-1,%ax %rax = 001122334455FFFF //把低2位字节设置为FFFFmovl $-1,%eax %rax = 00000000FFFFFFFF //movl以寄存器作为目的时，会把寄存器的高位4字节设为0movl $-1,%rax %rax = FFFFFFFFFFFFFFFF ///则把整个寄存器设为F 123456//展示了MOVS和MOVZ指令的区别movabsq $Ox0011223344556677,%rax %rax = 0011223344556677movb $OxAA,%dl %dl = AAmovb %dl,%al %rax = 0011223344556677movsbq %dl,%rax %rax = FFFFFFFFFFFFFFAAmovzbq $dl,%rax %rax = 00000000000000AA 下面是寄存器的错误使用1234567movb $OxF,(%ebx) //%ebx不能作为地址寄存器movl %rax,(%rsp) //指令后缀和寄存器ID%rax不匹配，应该是movqmovw (%rax),4(%rsp) //不能同时指向内存位置movb %al,%sl //不存在%slmovq %rax,$Ox123 //立即数不能作为目的位置movl %eax,%rdx //目的操作数大小不对movb %si,8(%rbp) //指令后缀和寄存器ID%si不匹配，应该是movw 实例123456long exchange(long *xp,long y)&#123; long x = *xp; *xp = y; return x;&#125; 汇编后产生以下节选代码，函数由三条指令构成123456789//参数xp和y分别存储在%rdi和%rsi中exchange:.LFB0: .cfi_startproc movq (%rdi), %rax //把x的值放在%rax或其低位部分，而%rax是返回值的寄存器，因此最后返回x movq %rsi, (%rdi) //将y写入到寄存器%rdi的xp指向的内存位置 ret .cfi_endproc 这段汇编代码有几点注意： 说明了从内存读值到寄存器，和从寄存器写到内存 xp指针对应的就是地址，即将该指针放在寄存器%rdi，在内存中引用给寄存器(%rdi)就是读取指针指向地址的值 x局部变量是保存在寄存器(%rax)中的,而不是内存中，因为寄存器访问快假设sp和dp被申明为以下类型1234str_t *sp;dest_t *dp;怎么选取适当的数据传送指令实现下面的操作*dp = (dest_t) *sp; 假设sp和dp的值分别存储在寄存器%rdi和%rsi中，给出下列实际类型写出对应的指令其中第一条指令从内存中读数，并做适当的转换，第二条把%rax的适当部分写到内存 重点当强制类型转换涉及大小和符号变化时，先改变大小从这张图的第五行看出，从int强制转换成char时，第一步从内存的读取到%eax,第二步却从%eax的低位寄存器%al中读取到内存，显然%eax的高位被自动舍弃了，这就是C语言强制类型转换出错的原因 压入和弹出栈数据程序栈放在内存中的某个区域，在处理过程调用中起着至关重要的作用。栈指针%rsp保存着栈顶元素的地址 pushq指令的功能将数据压入栈中，popq指令弹出数据。将一个四字值压入栈中，首先将栈指针减8，然后将值写入新的栈顶地址 一条pushq %rbq就相当于12subq %8,%rspmovq %rbq,(%rsp) 一条popq %rax相当于12movq (%rsp),%raxaddq $8,%rsp 无论如何%rsp一定指向内存中的栈顶，因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方式访问栈内的任意位置。]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-第五章]]></title>
    <url>%2F2018%2F03%2F27%2FLinux-%E7%AC%AC%E4%BA%94%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[《鸟哥的Linux私房菜》第五章小结 Linux共有七种系统运作模式，最重要的四种执行等级为： run level 0 ：关机 run level 3 ：纯命令行模式 run level 5 ：含有图形界面模式 run level 6 ：重启 通过以下命令可以进入不同模式[xzy]$ init ~例如输入init 3,将进入以下界面命令行模式登陆后取得的程序成为shell，因为这个程序负责最外层的跟用户通信工作，戏称为shell 一条执行命令有以下几点说明 一条命令组成：command [-option] parameter1 parameter2 ... 第一个输入绝对是command或是可执行文件 命令和参数和选项之间的不论几个空格都视为一格 可以用反斜杠\转义[Enter]，使命令连续到下一行 命令是区分大小写的 例如通过以下命令查看自己主文件下的所有隐藏文件和相关文件属性,效果如图[xzy]$ls -al ~ man &amp; infoman是manual（操作说明）的简写 一般在man page中都会有类似于DATA(1)的符号，前面是命令，后面代表什么含义呢？ 1：用户在shell环境下可以操作的命令 2：系统内核可以调用的函数 3：一些常用函数与函数库，大部分为C的函数库 4：设备文件的说明 5：配置文件或者某些文件格式 6：游戏 7：惯例与协议，例如网络协议、文件系统等 8：系统管理员可用的管理命令 9：跟kerel有关的文件 可以通过man 7 man来查看具体的含义 man page大致分为几个部分 NAME：名称，简介 SYNOPSIS：执行语法简介 DESCRIPTION：详细描述 OPTIONS：对SYNOPSIS列举更详细的选项说明 COMMANDS：当该程序执行时，可以在程序中执行的命令 FILES：使用、参考、链接的文件 SEE ALSO：和该命令相关的说明 EXAMPLE：参考范例 BUGS：相关错误]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-近邻算法]]></title>
    <url>%2F2018%2F03%2F25%2FK-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Github k-近邻算法（k-nearest neighbor，kNN）是基本分类与回归方法，从它的名字也能知道算法大概是怎么实现的了，简单来说就是根据不同特征值之间的距离来进行分类。算法的输入为实例的特征向量，对应于特征空间的点，输出为实例的类别。测试数据输入后，与样本集中数据对于特征进行比较，提取前k个最相似的数据，这就是k的出处。最后选取k个相似数据在中出现次数最多的分类，作为新数据的分类。 k值的选择、距离度量及分类决策规则是k-近邻算法的三个基本要素。 算法的优缺点： 精度高、对异常值不敏感、无数据输入假定 计算复杂度高、空间复杂度高 使用与数值型和标称型 输入训练数据集：$T = {(x_{1},y_{1}),(x_{2},y_{2},\cdots,x_{N},y_{N})} $]]></content>
      <tags>
        <tag>Machine leaning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《二十二》]]></title>
    <url>%2F2018%2F03%2F25%2F%E3%80%8A%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[很平静的看完这部影片，直到我盯着影片结尾众筹名单时，感情一下子就上来了。影片里的一幕幕，都似曾相识。有的是它的景色像极了自己的家乡，有的是它的那些老人们像极了自己的外公外婆爷爷奶奶。他们和自己的爷爷奶奶外公外婆一样很普通，那是因为他们将那几年甚至只是几个月所遭受的磨难，深深的埋在心里。可是就算再多的泥土都无法填满这个伤口。他们也很不普通，因为他们受尽了侮辱，因为他们是曾经无恶不作的日本人的后代。如果不是我们还记得，如果不是历史还记得，有谁能从他们身上看出对他们来说日日夜夜都不可能忘记的经历。影片最后，镜头望着那个坟头，从冬天走向春天，这些老人一个个离去，带走了属于他们的记忆，可在坟头之上的我们，不能让那份历史被一起带走。不奢望得到现在的日本政府的道歉，毕竟现在的日本政府不是当年的日本政府，但希望peace and love，也希望这段历史能一直提醒着人们战争的残酷。]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa548]]></title>
    <url>%2F2018%2F03%2F25%2FUVa548%2F</url>
    <content type="text"><![CDATA[UVa548代码 题目：给出加权二叉树的中序遍历和后序遍历，找出一枚叶子使其到根节点的总权重最小，如果总权重相同，叶子本身的权重尽量小 共有三种递归遍历，且都是深度优先遍历 前序遍历：根左右，即PreOrder(T) = T的根节点 + PreOrder(T的左子树) + PreOrder(T的右子树) 中序遍历：左根右，即InOrder(T) = InOrder(T的左子树) + T的根节点 + InOrder(T的右子树) 后序遍历：左右根，即PostOrder(T) = PostOrder(T的左子树) + PostOrder(T的右子树) + T的根节点 三者的关系：即使前序遍历和后序遍历实质是一样的，因此仅知道这两者是无法推出二叉树的结构，一定要搭配上中序遍历才能推出。]]></content>
      <tags>
        <tag>UVa</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2F2018%2F03%2F24%2FGit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Git入门使用 git init：初始化仓库 git status：此时仓库里什么都没有： git add .：注意add后面还有一个”.”指的是添加该位置的所有文件，如果要添加指定文件，在add后面加文件名称，现在就可以跟踪hello_world.py了 git commit -m &quot;Stated project：提交更改，并说明此次提交做了什么如：Stated project，在之后查找记录的时候就可以显示这句话 git log：查看记录 git checkout .：注意最后面也有“.”，这样就可以回到上次提交时候版本的文件 git remote add origin https://github.com/123xzy/ ：把本地历史添加进github服务器中，是和远程服务器建立建立的第一步 git pull origin master：把github上的文件拉下来，每次提交的时候先进行pull git push -u origin master：真正向github提交 git reset --hard fae6966548e3ae76cfa7f38a461c438cf75ba965：reset只能重置本地或者说本分支的更改 git remote rm origin：解决fatal: remote origin already exists.错误 总结：世界上目前最先进的分布式版本控制系统，虽然现在的我不知道这说的是啥，更不知道其中的原理是什么，但感觉很牛逼，也很有用。现在仅仅知道git在大项目的时候很有用，我在做c语言程序设计大作业的时候也感觉到了，分工下去，大家各写各的，最后整合就会很浪费时间，要是结合github使用，就会很方便。当然这只是最基本的操作，还有很多其他的操作比如说分支，删除，合并，等以后用到再去学]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《月亮与六便士》]]></title>
    <url>%2F2018%2F03%2F24%2F%E3%80%8A%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB%E3%80%8B%2F</url>
    <content type="text"><![CDATA[理想与现实的激烈对话]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章：链接]]></title>
    <url>%2F2018%2F03%2F23%2FCSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[链接：将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 链接的好处 帮助构建大型程序 避免危险的编程错误 理解语言的作用域规则的实现原理 理解其他的系统概念 利用共享库 编译器驱动程序12345678910//main.cint sum(int *a,int n);int array[2] = &#123;1,2&#125;;int main()&#123; int val = sum(array,2); return val;&#125; 1234567891011//sum.cint sum(int *a,int n)&#123; int i,s=0; for(i =0;i&lt;n;i++) &#123; s+=a[i]; &#125; return s;&#125; 通过GCC编译器驱动程序，可以调用语言预处理器、编译器、汇编器和链接器。在shell中输入下列命令，驱动程序会将main.c和sum.c翻译成可执行目标文件prog1[linux]$ gcc -Og -o prog main.c sum.c 下图概括了具体步骤： 运行C预处理器（cpp），将main.c翻译成中间文件main.i 运行C编译器（cc1），将main.i翻译成一个ASCII汇编语言文件main.s 运行汇编器（as），将main.s翻译成一个可重定向目标文件main.o 以相同的步骤生成sum.o 运行链接器程序ld，将main.o和sum.o以及必要的系统目标文件组合，生成一个可执行目标文件prog 输入“linux&gt; ./prog”，系统将调用加载器，将prog中的代码和数据复制到内存，并将控制移至程序开头 静态链接通过静态链接器以一组可重定位目标文件和命令行参数作为输入，生成完全链接、可加载和运行的可执行目标文件作为输出。要完成以上任务，链接器需完成以下步骤： 符号解析：将每个符号引用和符号定义关联起来 重定位：把每个符号定义和一个内存位置关联起来，然后修改所有符号引用，使它们指向这个内存位置 目标文件纯粹就是字节块的集合，这些块中，有些包含程序代码，有些包含数据，其他则包含引导链接器和加载器的数据结构。链接器将这些块重新组合，确定它们的运行位置。 可重定位目标文件：包含二进制代码和数据 可执行目标文件：可直接被复制进内存并运行 共享目标文件：特殊的可重定位目标文件，可以在加载和运行时被动态地加载进内存并链接 下图是一个典型的可执行可链接格式（ELF）可重定位目标文件格式 ELF头：以一个16字节的序列开始，描述了生成该文件的系统的字的大小和字节顺序。其次还包括ELF头的大小、目标文件的类型、机器类型（x86-64）、节头部表的文件偏移、节头部表中的条目大小和数量 节头部表：描述不同节的位置和大小 .text：以编译程序的机器代码 .rodata：只读数据 .data：已初始化的全局和静态C变量 .bss：未初始化的全局和静态变量，以及初始化为0的全局或静态变量。这个节不占据实际空间，仅仅是占位符，所以在运行时，这些变量被初始化为0 .symtab：符号表，包含在定义和引用的函数和全局变量的信息。但是不包含局部变量的条目 .rel.text：通常省略 .rel.data：被引用的或定义的所有全局变量的重定位信息 .debug：调试符号表，只有以-g调用编译器驱动程序时才会得到这种表，其条目是局部变量和类型定义，程序中定义和引用的全局变量，以及原始的c源文件 .line：原始c源程序和.text节中机器指令之间的映射，同样要以-g调用时才能得到 .strlab：字符串表，包括.symlab和.debug节中的符号表，以及节头部中的节名字 可重定位目标文件]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《鸟哥的Linux私房菜》]]></title>
    <url>%2F2018%2F03%2F23%2F%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[这本书很有名，但看完之后觉得不是给科班的人看，讲的有点啰嗦，但确实适合入门 本文所有实例均运行在Centos7.5上 Linux-第五章：登录与man page Linux-第六章：文件权限和目录配置 Linux-第七章：文件与目录管理 Linux-第八章：磁盘与文件系统 Shell script & Make]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《小鞋子》]]></title>
    <url>%2F2018%2F03%2F23%2F%E3%80%8A%E5%B0%8F%E9%9E%8B%E5%AD%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[这是第一部影片，能给我带来如此感同身受的感觉。印象最深的镜头，阿里爸爸带阿里去富人区找工作，父子俩骑着单车，一路碰壁，最后好不容易赚了一笔钱，回去的路上竟然摔倒了。看到这段画面的时候，满脑子都是以前和妈妈送报纸的回忆，一路跑，一路塞，回家的路上到路边摊去买一份油炸果子，背对着妈妈，坐在电瓶车上，那种感觉真的怎么都不会忘记。那时候和妈妈跑遍了了江山大大小小的地方，一下午的跑跑停停真的也不觉得累。突然回忆起和妈妈送报的那段时光，感觉要落泪了。还有一个画面影响也挺深刻，阿里把老师奖励的笔送给了妹妹，两人就和好了。小时候家里穷，就连一瓶小小的修正液也不会向父母开口，然后就去偷。还自以为是的和店家撒谎，现在想想大概是单纯吧。小时候特别期望和同学晚上能来我家里写作业，因为那样我就可以和她换文具，而且每次都能从她那里换到心仪的东西。影片的最后，阿里一路奔跑，只为了得一个第三名，能给妹妹换双鞋子。我虽然没有这样的经历，但也曾经这样狂奔过，就为了和老师赌气。一路跑，一路跑，老师拦也拦不下来。其实小时候家境不好，但是父母一直努力着，尽量满足于我，所以一直都留下穷的印象。现在家境稍微又些改善了，希望父母能别这么累，身体健康，多享受生活。为我他们付出了太多了。]]></content>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stanford-机器学习]]></title>
    <url>%2F2018%2F03%2F23%2FStanford-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[机器学习公开课视频的笔记 目录： 机器学习的动机和应用 监督学习应用，梯度下降 机器学习的动机和应用定义： 监督学习应用，梯度下降]]></content>
      <tags>
        <tag>Machine leaning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解计算机系统》]]></title>
    <url>%2F2018%2F03%2F23%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[CSAPP各章总结 理论 第三章：程序的机器级表示（1） 第三章：程序的机器级表示（2） 第三章：程序的机器级表示（3） 第八章：异常控制流 第十一章：网络编程 第十二章：并发编程 第十章：系统级I/O 第九章：虚拟内存：正在整理 第六章：存储器层次结构：未整理完 第七章：链接：未整理完 第四章：处理器体系结构：未整理完 Lab实验指导 Bomblab：汇编、栈帧和GDB Web proxy：实现多线程带缓存的代理服务器 Malloc：实现一个动态内存分配 Buflab：缓冲区溢出攻击 Data：位运算 Cache：实现一个缓存系统来加速计算 Shell：实现一个shell Archlab：设计流水线处理器 Performance：优化内存密集型代码]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT-线性代数]]></title>
    <url>%2F2018%2F03%2F23%2FMIT-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[UVa122（附sscanf函数）]]></title>
    <url>%2F2018%2F03%2F14%2FUVa122%2F</url>
    <content type="text"><![CDATA[UVa122 题意：根据输入构造二叉树，并根据二叉树从上到下，从左到右输出节点的值 样例输入：(11,LL) (7,LLL) (8,R)(5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) () 输出：5 4 8 11 13 4 7 2 1 Tips： 通过链表来实现二叉树* 1234567//二叉树节点的定义struct Node &#123; bool flag; //标记是否被赋值 int value; //节点值 Node* left, *right; //左右节点 Node() :flag(false), left(NULL), right(NULL) &#123;&#125;//构造函数&#125;; 解析输入的字符串12345678910111213//读取输入数据bool readin()&#123; failed = false; while (scanf("%s",s)) &#123; if (!strcmp(s, "()"))break; int v; sscanf(&amp;s[1], "%d", &amp;v);//从字符串中读取节点的数值,任意指向字符的指针看出是字符串 addnode(v, strchr(s, ',') + 1);//找到逗号所在位置，然后加一为后面的字符串 &#125; return true;&#125; 对于读取的每个节点将其加入的二叉树中12345678910111213141516171819void addnode(int v, char* s)&#123; int n = strlen(s); Node* u = root;//顺着根节点向下走 for (int i = 0; i &lt; n; i++) &#123; if (s[i] == 'L') &#123; if (u-&gt;left == NULL)u-&gt;left = newnode();//节点不存在 u = u-&gt;left;//继续向左走 &#125; else if (s[i] == 'R') &#123; if (u-&gt;right == NULL)u-&gt;right = newnode();//节点不存在 u = u-&gt;right;//继续向右走 &#125; &#125; if (u-&gt;flag)failed = true; u-&gt;value = v;//节点赋值 u-&gt;flag = true;//修改标记，表明已经赋值&#125; 对于已经生成的二叉树进行广度优先搜索12345678910111213141516bool bfs(vector&lt;int&gt;&amp; ans)&#123; queue&lt;Node*&gt;q; ans.clear(); q.push(root); while (!q.empty()) &#123; Node* u = q.front(); q.pop(); if (!u-&gt;flag)return false; ans.push_back(u-&gt;value); if (u-&gt;left != NULL)q.push(u-&gt;left); if (u-&gt;right != NULL)q.push(u-&gt;right); &#125; return true;&#125; 主函数12345678910111213141516int main()&#123; while (1) &#123; root = newnode(); if (!readin())break; vector&lt;int&gt; ans; if (!failed&amp;&amp;bfs(ans)) &#123; int len = ans.size(); for (int i = 0; i &lt; len; i++) printf("%d%c", ans[i], i == len - 1 ? '\n' : ' '); &#125; else printf("not complete\n"); &#125;&#125; sscanf函数：]]></content>
      <tags>
        <tag>UVa</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa679]]></title>
    <url>%2F2018%2F03%2F14%2FUVa679%2F</url>
    <content type="text"><![CDATA[UVa679 通过模拟每个小球的下落过程会TLE，下面是TLE代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 20int s[1&lt;&lt;MAXN];int main()&#123; int d, I,n; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; d; if (d == -1)break; cin &gt;&gt; I; memset(s, 0, sizeof(s)); int k; for (int i = 0; i &lt; I; i++) &#123; k = 1; for (;;) &#123; int flag = s[k]; s[k] = !s[k]; if (flag)k = k * 2 + 1; else k = k * 2;; if (k &gt; ((1 &lt;&lt; d) - 1))break; &#125; &#125; cout &lt;&lt; k / 2 &lt;&lt; endl; &#125; return 0;&#125; 但其实每个小球在根节点处，如果上一个小球向左，那这个小球就向左，因此对于一个根节点来说，该球是第奇数个小球到达该节点的，则一定向左，若是第偶数个小球，则向右。直接模拟第I个小球的下落轨迹，并每下落一层，I=I/2或者I=(I+1)/2,因为有一半的小球落向了另一个方向，该小球对下一个节点来说就是第I=I/2或者I=(I+1)/2个，1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int d, I,n; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; d; if (d == -1)break; cin &gt;&gt; I; int k = 1; for (int i = 0; i &lt; d-1; i++) &#123; if (I % 2) &#123; k = k * 2 ; I = (I + 1) / 2; &#125;//向左走 else &#123; k = k * 2+1; I = I / 2; &#125;//向右走 &#125; cout &lt;&lt; k &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa12657（附对拍教程）]]></title>
    <url>%2F2018%2F03%2F12%2FUVa12657%2F</url>
    <content type="text"><![CDATA[UVa12657代码用两个数组来表示双向链表 题解：数组Left[i]表示编号为i的箱子的左边箱子是几号，并编写一个辅助函数link来设置链接关系，对于模式4反转链表，因为修改数组的耗时太大，因此可以通过flag来标记，但是需要注意的是，后续的操作都要考虑这个flag的影响。 总结：这道题给了实现双向链表的新思路，也就是使用两个数组，但显然这样时间上节省，空间上消耗很多，运算量也很大。 对拍教程：很多时候，自认为正确的程序提交之后却是WA，但是给的测试数据太少，找不出错误在哪里，又嫌弃手写测试数据太慢，就可以利用操作系统的脚本功能，自动完成对比测试，当然首先你要有一个正确的程序，才能顺利的和自己的程序进行对比测试。 先写一个测试数据生成器，生成符合条件的数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*题目需要的数据格式：*/#include&lt;iostream&gt; #include&lt;stdlib.h&gt; // rand()和srand（）需要 #include&lt;time.h&gt; //time（）需要using namespace std;int random(int m)&#123; int n; return n = rand() % m;&#125;int main()&#123; srand(time(NULL)); // 初始化随机数种子 int n, m; for (int c = 1; c &lt;= 10; c++) &#123; //括号内的数字可以任意改 n = random(100) + 1; m = random(100) + 1; cout &lt;&lt; n &lt;&lt;" "&lt;&lt; m&lt;&lt;endl; for (int i = 0; i &lt; m; i++) &#123; int ch = random(4) + 1; int b1 = random(n) + 1; int b2 = random(n) + 1; if (ch == 4)cout &lt;&lt; ch &lt;&lt; endl; else &#123; //避免输出相等的x和y if (b1 != b2) &#123; cout &lt;&lt; ch &lt;&lt; " " &lt;&lt; b1 &lt;&lt; " " &lt;&lt; b2 &lt;&lt; endl; &#125; else i--; &#125; &#125; &#125; return 0;&#125;/*这是我用数据生成器生成的一组数据24 121 13 641 20 71 11 123 22 843 10 81 23 42 20 181 1 163 4 191 22 3*/ 并将数据生成器生成的数据保存在data.txt中 将正确的代码输入生成一个ans.exe，自己写的代码输入生成my.exe，所有生成的文件都放在名为对拍的文件中，就不用文件定位了。 打开记事本，输入以下脚本，并且保存为.bat格式 123456:again my &lt; data.txt &gt; my_output.txt ans &lt; data.txt &gt; ans_output.txt fc my_output.txt ans_output.txt //对比两个输出文件if not errorlevel 1 goto again pause 之后运行该脚本，就会自动生成两个输出文件ans_output.txt和my_output.txt]]></content>
      <tags>
        <tag>UVa</tag>
        <tag>链表</tag>
        <tag>对拍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa455]]></title>
    <url>%2F2018%2F03%2F12%2FUVa455%2F</url>
    <content type="text"><![CDATA[UVA455 （笨脑子很难抽象的去想问题，这道题也是，要多加练习）我的思路：从第一个元素开始，在遇到相同元素，就暂且把这个元素的序列作为最小周期，在循环判断，是否是循环数列，如果不是就退出，并找出下一个符合的最小周期，直到最后都没有退出，则输出这个最小周期。总结：我的思路总是一步一步进行，但我看到大佬的博客，说的就很简洁：枚举循环节（循环节要能被字符串长度整除），进行循环判断，找到第一组解就是最小解。 先上大佬的代码 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; char s[85]; while (t--) &#123; memset(s, 0, sizeof(s)); scanf("%s", s); int len = strlen(s); int j; for (int i = 1; i &lt;= len; ++i) if (len%i == 0) &#123; for (j = i; j &lt;= len; j++) if (s[j] != s[j%i]) break; if (j == len) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; if (t)cout &lt;&lt; endl; &#125;&#125; 再上我的代码，好吧，其实没有代码，虽然我的解释和大佬的解释看上去很不一样，但当我去一步步写自己的代码的时候，发现其实是差不多的。现在的要提升的就是把自己对题目的理解转化成代码的能力！！！]]></content>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa227]]></title>
    <url>%2F2018%2F03%2F12%2FUVa227%2F</url>
    <content type="text"><![CDATA[UVa227 一道我目前为止写过的最长代码的题，小小纪念一下，思路很简单，就是模拟，但是他的输出格式，我不是很明白，是复制网友代码然后发现的规律。代码很简单，应该可以看懂，orz 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;char s[6][6];struct blank&#123; int row;//行 int col;//列&#125;blank;int input()&#123; int flag2 = 0; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;= 5; j++) &#123; s[i][j] = getchar(); if (s[i][j] == 'Z') &#123; flag2 = 1; break; &#125; if (s[i][j] == ' ') //指向空白格 &#123; blank.col = j; blank.row = i; &#125; if (j == 5)getchar(); &#125; if (flag2 == 1)break; &#125; return flag2;&#125;int move()&#123; char move; int flag = 0; while(cin&gt;&gt;move) &#123; if (move == '0')break; switch (move) &#123; case('A'): if (blank.row != 1) &#123; s[blank.row][blank.col] = s[blank.row-1][blank.col]; s[--blank.row][blank.col] = ' '; &#125; else flag = 1; break;//上 case('B'): if (blank.row != 5) &#123; s[blank.row][blank.col] = s[blank.row+1][blank.col]; s[++blank.row][blank.col] = ' '; &#125; else flag = 1; break;//下 case('R'): if (blank.col != 5) &#123; s[blank.row][blank.col] = s[blank.row][blank.col+1]; s[blank.row][++blank.col] = ' '; &#125; else flag = 1; break;//右 case('L'): if (blank.col != 1) &#123; s[blank.row][blank.col] = s[blank.row][blank.col-1]; s[blank.row][--blank.col] = ' '; &#125; else flag = 1; break;//左 &#125; &#125; return flag;&#125;void output(int count)&#123; if (count &gt; 1)cout &lt;&lt; endl; printf("Puzzle #%d:\n", count); for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;= 5; j++) &#123; if (j == 5)cout &lt;&lt; s[i][j] &lt;&lt; endl; else cout &lt;&lt; s[i][j] &lt;&lt; " "; &#125; &#125;&#125;int main()&#123; int count = 1; for (;;) &#123; int t1,t2; t1 = input(); if (t1)break; t2=move(); if (t2==0)output(count++); else &#123; if (count &gt; 1)cout &lt;&lt; endl; printf("Puzzle #%d:\n", count++); cout &lt;&lt; "This puzzle has no final configuration." &lt;&lt; endl; &#125; getchar(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa572]]></title>
    <url>%2F2018%2F03%2F12%2FUVa572%2F</url>
    <content type="text"><![CDATA[UVa572 第一次做DFS的题目，还一次AC了，开心12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;#define MAXN 105char map[MAXN][MAXN];int m,n;int dir[8][2] = &#123; &#123; 0,-1 &#125;,&#123; 0,1 &#125;,&#123; 1,0 &#125;,&#123; -1,0 &#125;,&#123;-1,-1&#125;,&#123;-1,1&#125;,&#123;1,-1&#125;,&#123;1,1&#125; &#125;;//因为题目意思是斜着也算连通，所以定义八个方向void dfs(int si, int sj)&#123; if (si&lt;0 || si&gt;m || sj&lt;0 || sj&gt;n)return; for (int i = 0; i &lt; 8; i++) &#123; if (map[si + dir[i][0]][sj + dir[i][1]] == '@') &#123; map[si + dir[i][0]][sj + dir[i][1]] ='*';//做过的地方就标记不能走 dfs(si + dir[i][0], sj + dir[i][1]);//递归把连通的地方都走一遍 &#125; &#125; return ;&#125;int main()&#123; while (cin &gt;&gt; m &gt;&gt; n&amp;&amp;n&amp;&amp;m) &#123; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; map[i][j]; int num = 0; //记录连通分量 for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) if (map[i][j] == '@') &#123; dfs(i, j); num++; &#125; cout &lt;&lt; num &lt;&lt; endl; &#125;&#125; 这是最简单的DFS题目，我们老师和我们说DFS最精彩的地方应该是剪枝，因为DFS是要去走完整幅地图，效率还是很低的，要提高效率，就要适当剪枝，避免一些多余的步子，当然也不可过度剪枝，所以怎么剪枝还是要多想。]]></content>
      <tags>
        <tag>UVa572</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa514]]></title>
    <url>%2F2018%2F03%2F12%2FUVa514%2F</url>
    <content type="text"><![CDATA[UVa514 学完栈的知识后，第一次运用,也是第一次知道有现成的stack 这是《算法竞赛入门经典》上的题目，但是书上的代码是过不了的，主要是输入输出的格式不对，但是思路是ok的 根据题目意思描述，辅助铁轨C只能先进后出，符合栈的特性 进入的火车要么进入C，要么直接出去出去的火车要么从C出去，要么从A出去 还有火车从C栈驶出之前，要判断栈是否为空，不然是会出错的 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;stack&gt;#define MAXN 1005using namespace std;int n,tar[MAXN];int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; stack&lt;int&gt;s; //看作是辅助铁轨C,先进后出 while(cin&gt;&gt;tar[1]&amp;&amp;tar[1]) &#123; for(int i=2;i&lt;=n;i++) scanf("%d",&amp;tar[i]);//输入火车驶出的顺序 int a=1,b=1;//标记铁轨a，b的顺序 int flag=1;//标记能否成功 while(b&lt;=n) &#123; if(tar[b]==a) &#123; a++;b++;//火车从a直接驶出 &#125; else if(!s.empty()&amp;&amp;tar[b]==s.top()) &#123; s.pop();//火车从c驶出 b++; &#125; else if(a&lt;=n) &#123; s.push(a);//火车驶入c a++; &#125; else &#123; flag=0;break;//说明顺序不对 &#125; &#125; printf("%s\n",flag?"Yes":"No"); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1325]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1325%2F</url>
    <content type="text"><![CDATA[HDOJ1325 乍一看并查集啊，native，结果WA, ORZ还是太菜了啊，做了好久好久orz12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*三个条件：1.不能成环2.不能成树林3.入度小于等于1特判：空树也是树*/#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define MAXN 10005int disjoint[MAXN]; //并查集int indegree[MAXN]; //记录出度int show[MAXN]; //标记出现的点int find(int x) //找根节点&#123; int t = x; while(disjoint[t] != t) t = disjoint[t]; return t;&#125;int merge(int x, int y) //合并查集(如果在一个集合形成环，则返回0)&#123; int fx = find(x); int fy = find(y); if (fx == fy) return 0; else while(disjoint[fy]!= fx) disjoint[fy] = fx; return fx;//如果没有成环，则合并，否则返回0 &#125;int main()&#123; int x, y,count=1; while (cin &gt;&gt; x &gt;&gt; y&amp;&amp;x&gt;=0&amp;&amp;y&gt;=0) &#123; for (int i = 1; i &lt;= MAXN; i++) //初始化并查集和入度和标记 &#123; indegree[i] = 0; disjoint[i] = i; show[i] = 0; &#125; if (x == 0 &amp;&amp; y == 0) //特判空树 &#123; printf(&quot;Case %d is a tree.\n&quot;, count++); continue; &#125; show[x]++; show[y]++; indegree[y]++; merge(x, y); //要注意x，y顺序，因为该树是有方向的 int flag1 = 0, flag2 = 0,flag3=0; //分别表示是否成环，是否成树林，是否入度小于等于1 int a, b; while (cin &gt;&gt; a &gt;&gt; b&amp;&amp;a&amp;&amp;b) &#123; if (merge(a, b) == 0)flag1 = 1;//成环 show[a]++; show[b]++; indegree[b]++; &#125; int root=0; if(flag1==1)printf(&quot;Case %d is not a tree.\n&quot;, count++); else &#123; for (int j = 1; j &lt; MAXN; j++) &#123; if (show[j] &amp;&amp; disjoint[j] == j) //计算有几个根节点 &#123; root++; if (root &gt; 1) &#123; flag2 = 1; break; &#125; &#125; if (indegree[j] &gt; 1)flag3 = 1; &#125; if(flag2||flag3)printf(&quot;Case %d is not a tree.\n&quot;, count++); else printf(&quot;Case %d is a tree.\n&quot;, count++); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1232]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1232%2F</url>
    <content type="text"><![CDATA[HDOJ1232 不瞒大家，这题提交了十几遍，一道简单的并查集，硬是被我做成了一坨屎，orz，还是自己没有真正理解并查集的意思，导致自己翻车了2333 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;int city[1002];int find(int x) &#123; int temp=x; while(city[temp] != temp) //一定是while不能是if，是寻找根节点，不是父节点 temp = city[temp]; return temp; &#125;void merge(int a, int b)&#123; int fa, fb; fa = find(a); fb = find(b); if (fa != fb) city[fa] =fb;&#125;int main()&#123; int cnum, rnum, count,x, y,i; while (scanf(&quot;%d&quot;, &amp;cnum),cnum) &#123; for (i = 1; i &lt;=cnum; i++) city[i] = i; for(scanf(&quot;%d&quot;,&amp;rnum);rnum&gt;0;rnum--) &#123; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); merge(x, y); &#125; for (i= 1,count=-1; i &lt;= cnum; i++) if (city[i] == i) count++; printf(&quot;%d\n&quot;, count); &#125;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1297]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1297%2F</url>
    <content type="text"><![CDATA[HDOJ1297 第一次做这道题的时候，以为就是一个简单的递推题，但还是too native，结果自然是WA，后来测试发现题目给的范围是1~1000,但是取100数据就会溢出（即便使用的是long long），因此需要使用大数计算。 先简单的分析这题的递推公式：用f（n）表示排队种类，假定已知f（n-1）第n个是男生，则有f（n-1）种可能第n个是女生，首先需要明确要使f（n）要合法，那么第n-1个必须为女生，接着需要分类讨论，如果前n-2个学生排列合法，则有f（n-2）种可能，如果前n-2个学生不合法，即第n-2是女生，第n-3是男生，此时再加上两个女生，队列就变成合法，因此这种情况有f（n-4）种可能该题递推公式为f（n）=f（n-1）+f（n-2）+f（n-4） 接着需要解决大数计算的问题，接下来再引入ACM1002大数计算基本思路：利用字符数组来保存每一位上的数字，并模拟手算 先讲解大数计算的核心代码： 定义两个数组，用来存储需要相加的两个数 12#define MAXN 10005 //MAXN值为几，就说明至少可以用来计算几位数之和int list1[MAXN],list[MAXN]; 程序做循环相加的时候要知道什么时候退出，因此需要知道较长的字符串长度，作为退出标志 1234int len1,len2，max_len;len1=strlen(list1);len2=strlen(list2);max_len=max(len1,len2); 接下来我们要模拟手算 1234567int temp=0； //用来保存临时结算结果for(int i=max_len;i&gt;=1;i--) //从最低位开始&#123; temp=list1[i]+list2[i]+temp; list1[i]+=temp%10; temp/=10;&#125; 贴上杭电ACM1002的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#define MAXN 1005using namespace std;void add(char num1[MAXN], char num2[MAXN])&#123; int temp1[MAXN] = &#123; 0 &#125;;int temp2[MAXN] = &#123; 0 &#125;; int len1 = 0;int len2 = 0; int i = 0, j = 0; int maxlen = 0; len1 = strlen(num1); len2 = strlen(num2); ////反转字符串，便于从低位到高位相加和最高位的进位导致和的位数增加 for (i = len1 - 1; i &gt;= 0; i--) &#123; temp1[j++] = num1[i] - '0'; &#125; temp1[j] = '\0'; j = 0; for (i = len2 - 1; i &gt;= 0; i--) &#123; temp2[j++] = num2[i] - '0'; &#125; //一位一位的加 maxlen = (len1 &gt; len2) ? len1 : len2; for (i = 0; i &lt; maxlen; i++) &#123; temp1[i] += temp2[i]; if (temp1[i] &gt;= 10) &#123; temp1[i] -= 10; temp1[i + 1]++; &#125; &#125; for (i = maxlen - 1; i &gt;= 0; i--) cout &lt;&lt; temp1[i];&#125;int main()&#123; char s1[MAXN]; char s2[MAXN]; /*gets_s(num1); gets_s(num2);*/ int t; cin &gt;&gt; t; for (int j = 1; j &lt;= t;j++) &#123; cin &gt;&gt; s1 &gt;&gt;s2; cout &lt;&lt; "Case " &lt;&lt; j &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; " + " &lt;&lt; s2&lt;&lt;" = "; add(s1, s2); cout &lt;&lt; endl; if (j!= t) &#123; cout &lt;&lt; endl; &#125; &#125; //add(num1, num2); return 0;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1215]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1215%2F</url>
    <content type="text"><![CDATA[HDOJ1215 例题：输入一个数N，输出所有小于等于N的素数基本思想：素数的倍数一定不是素数实现方法：用一个长度为N+1的数组保存信息（0表示素数，1表示非素数），先假设所有的数都是素数（初始化为0），从第一个素数2开始，把2的倍数都标记为非素数（置为1），一直到大于N；然后进行下一趟，找到2后面的下一个素数3，进行同样的处理，直到最后，数组中依然为0的数即为素数。说明：整数1特殊处理即可。1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int a[100001];int main()&#123; int i, n,j; while (cin &gt;&gt; n) &#123; for(i=2;i&lt;=n;i++) if (a[i] == 0) &#123; for (j = i + i; j &lt;= n; j += i) a[j] = 1; &#125; cout&lt;&lt;"2"; for (i = 3; i &lt; n; i++) if (a[i] == 0)cout &lt;&lt;i; cout &lt;&lt;endl; &#125;&#125; 和例题相似的处理方式，先定义一个a[t]来保存t对应的所有因子之和对于一个i，它一定是所有i的倍数的因子，因此将a[ix]都加上i(ix表示i的所有倍数)12345678910111213141516171819#include&lt;iostream&gt;#define MAXN 500005int a[MAXN];using namespace std;int main()&#123; int i, j; for( i=1;i&lt;=MAXN/2;i++) for (j = i + i; j &lt;= MAXN; j+=i) a[j]+=i; int n; cin &gt;&gt; n; while (n--) &#123; int t; cin &gt;&gt; t; cout &lt;&lt; a[t]&lt;&lt; endl; &#125;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1421]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1421%2F</url>
    <content type="text"><![CDATA[HDOJ1421 又是动态规划的题目，dp方面问题对现阶段的自己还是一个坎，还是要多理解多刷题。 首先从简单的数塔入手，从第一行开始走，走到最后一行，怎么使经过的值之和最大？ dp问题的核心：找到状态并建立状态转移方程 首先需要建立一个数塔模型，模型中的元素用a(i,j)(j&lt;=i)表示，如第三行第二个元素10用a(3,2)表示。并且我们规定从a(i,j)往下走所能得到的最大值为dp(i,j)。我们以数塔中任意一个元素a(i,j)为一个状态，根据规则，该元素可以选择向左下方a(i+1,j)或者右下方a(i+1，j+1)移动(最后一行除外)，显然对于处于a(i,j)一定选择{dp(i+1,j),dp(i+1,j+1)}中较大的值，于是我们得到了dp(i,j)的计算公式：dp(i,j)=a(i,j)+max(dp(i+1,j),dp(i+1,j+1))，这就是我们所要找的状态转移方程。很容易就知道该问题的最终答案是dp(1,1)。 接下来介绍三种方法来求解：1.递归求解 123456int dp(int i,int j)&#123; if(i!=n)return a[i][j]+=max(dp(i+1,j),dp(i+1,j+1)); else return 0; //n表示最后一行的行数，即为边界&#125; 分析该算法，会发现效率很低。例如对于上图dp(3,2),dp(4,2),dp(4,3)将会被重复计算，但是这部分的结果一样，却被重复计算，我们就要设法使这部分不被重复，很显然，要使他不重复，那就在第一次计算的时候把结果记录下来，下次遇到的时候直接使用，就避免了重复计算。 2.根据算法1的分析，我们得到了带记忆功能的算法。 1234567int dp(int i,int j)&#123;//第一行就是所说的记忆功能，如果dp&gt;=0,就表明它已经被计算过了，可以直接使用，//所以在函数之前要将dp的值全赋值成-1，表示dp都未被计算过memset(dp,-1,sizeof(dp)) if(dp(i,j)&gt;=0)return dp(i,j); else return dp[i][j]=a[i][j]+max(dp(i+1,j),dp(i+1,j+1));&#125; 从图中很直观的看出记忆功能的算法能直接利用计算过的结果。 3.递推算法 算法3改变了思路，前两种都是自顶向下计算，算法3则选择从下向上计算，而且规定一下是从左下角向顶角计算。12345for(int i=n;i&gt;=1;i--) for(int j=1;j&lt;=i;j++) dp[i][j]=a[i][j]+max(a[i-1][j],a[i-1][j+1]);//仔细分析甚至连dp数组都可以不用 a[i][j]+=max(a[i-1][j],a[i-1][j+1]); 下面给出数塔问题ACM2084的完整代码，这里选择算法3 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAXN 105int a[MAXN][MAXN];using namespace std;int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) cin &gt;&gt; a[i][j]; for (int i = n - 1; i &gt;= 1; i--) for (int j = 1; j &lt;= i; j++) a[i][j] += max(a[i + 1][j], a[i + 1][j + 1]); cout &lt;&lt; a[1][1] &lt;&lt; endl; &#125; return 0;&#125; 接下来分析一下开头的ACM1421首先必须承认渣渣的我这道题想了很久，也是借鉴了别人的思路。 先申明用a[n]来存储输入的数据，用dp[i][j]表示从i个数中取j对时的最小值，例如dp[3][1]表示从3个数取1对的最小疲劳度(当然三个数的时候也只能取一对) 我想从题意中应该很容易想到给数组a进行排序 1sort(a,a+n); 我们先从简单的找找规律：当只有两个数的时候，结果显然等于(a[2]-a[1])*(a[2]-a[1]),根据前面的定义我们把结果记作dp[2][1];当有三个数，要么a[1]和a[2],要么a[2]和a[3]组合，我们取两个组合的最小值,因此： 1dp[3][1]=min(dp[2][1],(a[3]-a[2])*(a[3]-a[2])); 我们接着在推一个当四个数的时候，此时我们可以选取一对或者两对,此时选取一对可以分成两类：121.不包括第四个数时，dp[4][1]=dp[3][1];2.包括第四个数时，dp[4][1]=(a[4]-a[3])*(a[4]-a[3]); 选取两对： 1dp[4][2]=dp[2][1]+(a[4]-a[3])*(a[4]-a[3]); 不知道你们发现什么没(如果还没有,可以在推一两组找找规律） 123dp[i][j]=min(dp[i-1][j],dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]);//其实这就是我们要找的状态转移方程//假设要找i个元素中j对的最小值:要么从前i-1个元素中找j对；要么从前i-2个元素中找j-1对+a[i]-a[i-1])*(a[i]-a[i-1]； 既然找到了状态转移方程，我们就根据题意进行一些细节的处理 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAXN 2050int dp[MAXN][MAXN];int a[MAXN];using namespace std;int main()&#123; int n, k; while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 1; i &lt;=n; i++) cin &gt;&gt; a[i]; sort(a+1, a + n+1); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= k; j++) dp[i][j] = 268435456; for (int i = 2; i &lt;= n; i++) for (int j = 1; 2*j&lt;= i ; j++) dp[i][j] = min(dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]), dp[i - 1][j]); cout &lt;&lt; dp[n][k]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1176]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1176%2F</url>
    <content type="text"><![CDATA[HDOJ1176 作为一个弱鸡，这道题目花了我很长的时间orz，首先花了很长的时间去理解这道题其实和数塔（ACM2084）实质其实一模一样，甚至连代码都差不多orz 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 140000int a[MAXN][11];int main()&#123; int n, position, time; while (cin&gt;&gt;n&amp;&amp;n) &#123; int max_time = 0; memset(a, 0, sizeof(a)); for (int i = 0; i &lt; n; i++) &#123; scanf_s("%d%d", &amp;position, &amp;time); a[time][position]++; max_time = max(max_time, time); &#125; for (int i = max_time - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= 10; j++) &#123; if(j==0) &#123; a[i][j] += max(a[i + 1][j], a[i + 1][j +1]); continue; &#125; if(j==10) &#123; a[i][j] += max(a[i + 1][j], a[i + 1][j - 1]); continue; &#125; a[i][j] += max(max(a[i + 1][j ], a[i + 1][j+1]), a[i + 1][j - 1]); &#125; &#125; cout &lt;&lt; a[0][5] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1233]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1233%2F</url>
    <content type="text"><![CDATA[HDOJ1233 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;#define M 10005 struct node &#123; //定义边的结构体，包含边的起始城市，结束城市，路的距离 int start; int end; int dis;&#125;edge[10005];int disjoint[M]; int find(int x)&#123; int temp=x; while(disjoint[temp]!= temp) //一直找到根节点 temp =disjoint[temp]; return temp;&#125;int merge(int a, int b)&#123; int fa, fb; fa = find(a); fb = find(b); if (fa != fb) &#123; disjoint[fa] = fb; return 1; &#125; else return 0;&#125;bool cmp(node n,node m) //间接排序&#123; return n.dis &lt; m.dis;&#125;int main()&#123; int n,i,j; while (scanf("%d",&amp;n)&amp;&amp;n) &#123; int count = n*(n - 1) / 2; for (i = 1; i &lt;= count; i++) disjoint[i] = i; //初始化并查集 for (i = 1; i &lt;= count; i++) scanf("%d%d%d", &amp;edge[i].start, &amp;edge[i].end, &amp;edge[i].dis); sort(edge+1, edge + count+1, cmp); //将边长按从小到大排序 int sum = 0,num=0; for (j = 1; j &lt;=count&amp;&amp;num&lt;n; j++) &#123; if (merge(edge[j].start,edge[j].end)) &#123; sum += edge[j].dis; num++; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ2899]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ2899%2F</url>
    <content type="text"><![CDATA[HDOJ2899 一道很水的题目，硬是被我做成有毒的题目先讲二分法这种多次函数照理来说是不能用二分法的（因为一般来说函数不是单调的），但是这个函数的导函数在给定（0，100）区间是单调的，所以就可以以利用二分法去找导数等于零的点，也就是要找的极小值点12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;using namespace std;#define flag 1e-6double val(double x,double y)&#123; return 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * pow(x, 2) - x*y;&#125;double der(double x)&#123; return 42 * pow(x, 6) + 48 * pow(x, 5) + 21 * pow(x, 2) + 10 * x;&#125;int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; double y; cin &gt;&gt; y; double x_mid=50.0, x_min = 0.0, x_max = 100.0; while (abs(der(x_mid) - y) &gt; flag) &#123; if (der(x_mid) &gt; y) &#123; x_max = x_mid; x_mid = (x_max + x_min) / 2; &#125; else &#123; x_min = x_mid; x_mid = (x_min + x_max) / 2; &#125; &#125; printf("%.4lf\n", val(x_mid, y)); &#125;&#125; 这个三分法是真的有毒，我在网上找到的三分查找都是先分成两半，再分，也就是四分了吧，所以害我WA了两遍，有大佬和我讲解一下为什么嘛先把三分法的原理过一遍：首先需要明确三分法的使用条件，在给定区间内要具有相同的凹凸性（我们在后面举例说明如果不具备凹凸性三分法就不成立） 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define flag 1e-6double Fx(double x, double y)&#123; return 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * pow(x, 2) - x*y;&#125;int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; double y; cin &gt;&gt; y; double x_mid1 , x_min =0, x_max = 100, x_mid2; while ((x_max-x_min)&gt;flag) &#123; x_mid1 = (x_max +2*x_min) / 3; x_mid2 = (2*x_max +x_min) / 3; if (Fx(x_mid1, y) &lt; Fx(x_mid2, y)) x_max = x_mid2; else x_min=x_mid1 ; &#125; printf("%.4lf\n", Fx(x_max,y)); &#125;&#125;]]></content>
      <tags>
        <tag>HDOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDOJ1010]]></title>
    <url>%2F2018%2F03%2F12%2FHDOJ1010%2F</url>
    <content type="text"><![CDATA[HDOJ1010 这是最初的代码，没有经过剪枝，自然TLE，DFS很大的一个特点就是要搜遍全图，很耗时间，如果你按F10去一步步调试，将会按到天昏地暗（我就是这么做的），它会把每个能到达的节点都做一遍DFS，不过没关系，先理解最初始的代码，理解了再去剪枝12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int si, sj,ei, ej,n,m,flag,t;char map[8][8];int dir[4][2] = &#123; &#123;0,1&#125;,&#123;1,0&#125;, &#123;-1,0&#125;,&#123;0,-1&#125; &#125;;void dfs(int a, int b, int cost_time)&#123; if (a &gt; n || a&lt;1 || b&gt;m || b &lt; 1)return; if (cost_time == t&amp;&amp;ei == a&amp;&amp;ej == b)flag = 1; if (flag)return; for(int i=0;i&lt;4;i++) if (map[a + dir[i][0]][b + dir[i][1]] !='X') &#123; map[a + dir[i][0]][b + dir[i][1]] = 'X'; dfs(a + dir[i][0], b + dir[i][1],cost_time+1); map[a + dir[i][0]][b + dir[i][1]] = '.'; &#125; return;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&amp;&amp;n&amp;&amp;m&amp;&amp;t) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; map[i][j]; if (map[i][j] == 'S') &#123; si = i; sj = j; &#125; if (map[i][j] == 'D') &#123; ei = i; ej = j; &#125; &#125; flag = 0; map[si][sj] = 'X'; dfs(si, sj, 0); if (flag)cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125;&#125; 接下来我们考虑怎么去剪枝，即不能剪多了，也要尽量多剪 最重要的一个剪枝，奇偶性剪枝： 先复习一个很蠢的知识：奇数-奇数=偶数，奇数-偶数=奇数，偶数-偶数=偶数也就是说只要是相同奇偶性的两个数相减，结果就是偶数 在地图的底层附加一个01MAP会发现从0-&gt;1肯定需要奇数步，从0-&gt;0需要偶数步，1void dfs(int a, int b, int cost_time) cost_time表示从起点(si，sj)走到(a,b)点花费的时间，从(a,b)走到终点(ei，ej)的步数为abs(ei-a)+abs(ej-b),(t-temp)-(abs(ei-a)+abs(ej-b))：这个式子表示到终点还剩余的时间和花费的步骤之差(其实(abs(ei-a)+abs(ej-b))n才表示花费的步骤，但是在这个式子里只需要花费步骤的最小值和奇偶性就够了，也就不需要n)这个式子就用到了那个很蠢的知识，只要判断这个式子值的奇偶性，就可以起到奇偶性剪枝的作用。 12345678910111213141516171819void dfs(int a, int b, int cost_time)&#123; int temp; if (a &gt; n || a&lt;1 || b&gt;m || b &lt; 1)return; if (cost_time == t&amp;&amp;ei == a&amp;&amp;ej == b)flag = 1; temp = (t - cost_time) - (abs(ei - a) + abs(ej - b)); if (temp &lt; 0 || temp &amp; 1)return; if (flag)return; for(int i=0;i&lt;4;i++) if (map[a + dir[i][0]][b + dir[i][1]] !='X') &#123; map[a + dir[i][0]][b + dir[i][1]] = 'X'; dfs(a + dir[i][0], b + dir[i][1],cost_time+1); map[a + dir[i][0]][b + dir[i][1]] = '.'; &#125; return;&#125; 将奇偶性剪枝放入代码，就可以解决TLE的问题，当然还有其他零散的剪枝]]></content>
      <tags>
        <tag>HDOJ</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB GCC]]></title>
    <url>%2F2018%2F03%2F11%2FGDB-GCC%2F</url>
    <content type="text"><![CDATA[这个星期作死的想要在linux下写c代码，结果花了大半天，不过还是很有收获的，至少以后可以在linux下写代码了，还有CSAPP上的案例也就可以动手操作了，哈哈哈之前都是在CSAPP上看的汇编代码，今天终于看到了“真人”了。还是总结一下这次烦人的操作因为看书的时候，经常会看到gdb调试，就一直都想实验一下，但是windows安装实在烦人首先是安装虚拟机，这步倒是很顺利；安装linux也是按照教程一步步就完成了，安装的是centos7gcc，gdb的安装也是瞎操作一番就成功了，但是就是这个编译运行花了很长时间，我写了一个文件hello.c保存在了home下的Documents，结果导致我运行gcc hello.c -o hello,一直提示No such file or directory，去百度的时候也是搜到一堆没用的东西，知道我想起来home，我尝试的将hello.c放到了home中，结果就成功了，就是手贱，要把它保存到Documents 要想使用GDB调试，在生成可执行文件时要加上-g参数 接下来就是要学习gdb的操作，熟悉linux常见的GDB调试命令 完整的GDB文件]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>GDB</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bomblab]]></title>
    <url>%2F2018%2F03%2F11%2Flab-bomb%2F</url>
    <content type="text"><![CDATA[啃完了CSAPP的前四章，但是怎么能停在只是坑完了呢，当然要做配套的经典Lab,这次做实验把学到的都用起来了因为实验会涉及到GDB的调试，可以参照GDB GCC phase_1 phase_2 phase_3 phase_4 phase_5 phase_6 phase_1首先调用objdump -d bomp &gt; bomb.txt语句对其进行反汇编,产生bomb.txt1234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp //栈指针向栈顶移8字节 400ee4: be 00 24 40 00 mov $0x402400,%esi //设置%esi的值为$Ox402400 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt;//调用strings_not_equal函数 400eee: 85 c0 test %eax,%eax //比较%eax是否为0，%eax存储的是函数的返回值，即strings_not_equal的返回值 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; //返回等于零进入下一关 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; //否则调用炸弹爆炸函数 400ef7: 48 83 c4 08 add $0x8,%rsp //恢复栈顶指针 400efb: c3 从对汇编代码的分析看，$0x402400地址的值是破解的关键 我们先GDB该程序，并在phase_1函数开头设置一个断点，如下图所示 之后run该程序，就会在断点处停下，并随机输入一个字符串xzy（当时在这里还碰到了个小问题，我是把直接把程序从Windows下直接复制到虚拟机中，导致该文件的权限为-rw-------，因此我是没有权限去执行它的，具体修改权限可以参照Linux-第六章） 我们的目的是要读取$0x402400地址的值，所以我们单步调试到mov语句之后，并读取该地址的值，我们可以看到写入的字符串xzy存在%eax，而我们要的信息存在%esi 至此我们就找到破解第一关的密码了 phase_2为了之后的做题带来方便，我们将答案存储在ans.txt,并在每次运行时作为参数输入，如下图所示这一关用到了一点栈操作的知识，前两行分别是将%rbp和%rbx压入栈中，%rsp始终是指向栈顶，栈的结构类似下图我们看到400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt;语句的时候,应该猜到第二关的密码是六个数字,并且读入的六个数字保存在%rsp到%rsp+28中 下一条语句比较1和%rsp指向的内存的值（也就是读入的第一个数字），如果相等则跳转到400f30 &lt;phase_2+0x34&gt;，该语句是设置寄存器值的操作，也就是将%rsp+4的值赋给%rbx，同理将%rsp+18的值赋给%rbp，继续跳转到400f17 &lt;phase_2+0x1b&gt;，该语句表示将（%rbx-4）地址所指向内存的值（即%rsp指向内存的值，也是第一个输入的数）赋给%eax，然后%eax自加后和%rbx（即第二个输入的值）比较，所以第二个数字应该是2，接下来就是一个循环，所以最后的结果应该是1 2 4 8 16 32 phase_3经过两关的练习，做第三关的时候明显感到容易起来了 前几行依旧是栈的预处理，直到我们看到这一行400f51: be cf 25 40 00 mov $0x4025cf,%esi,又在将某个东西传进来了，所以本着好奇的原则我们取查看一下%esi存了点什么东西，所有当调用(gdb) x/s $esi发现了点线索，提示0x4025cf: &quot;%d %d&quot;,我们猜测这一关的密码应该是两个数字，继续往下看 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp)这句话是将7和%rsp+8进行比较，但我们暂时还不知道他的作用是什么，但如果超过7就会跳转到炸弹爆炸函数 继续往下看看，400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8)这句话是这一关的关键，他会间接跳转，并且以%rax作为偏移量，跳转到0x402470+8*%rax，所以后面很工整的语句类似于switch语句 回到第二点，应该就是表示第一个数字不能大于7，否则爆炸，而第二个数字的值是由第一个数字决定的 其他一些语句的意思 12345//判读sccanf函数的返回值是否大于1，如果大于1则继续，否则爆炸，这一点也肯定了我们要输入的是两个数 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a &lt;phase_3+0x27&gt; 接下来就是找出第二个数的值，可以通过看代码计算出来，可以切断点去查看1-7分别对应的数字，最终结果是0 207 || 1 311 || 2 707 || 3 256 || 4 389 || 5 206 || 6 682 || 7 327 phase_4首先依旧是通过前几行去找出密码的形式是什么如图所以这一关的密码就是两个数字，之后通过调用scanf函数，并且检查返回值是否为2（即输入值的个数是否为2），之后连着的三条mov语句应该是设置func4函数的参数，我们设参数为a,b，输入值x,返回值为result,我们先跳过callq语句，接着往下看，检查返回值是否为0，比较第二个输入值是否为零，因此我们判断第二个数字就是0，接下来着重分析func4函数,其实该函数是递归函数,并将汇编代码大致翻译成如下的c语言版本1234567891011121314151617181920212223242526272829a in %edx,b in %esi,x in %edi,result in %eax,t in %ecxfunc4(int a ,int b,int x)&#123; int t,result; sub $0x8,%rsp result = a; mov %edx,%eax result -= b; sub %esi,%eax t = result; mov %eax,%ecx t = t &gt;&gt; 31; shr $0x1f,%ecx result = result + t; add %ecx,%eax result /= 2; sar %eax t = result + b; lea (%rax,%rsi,1),%ecx if(x &lt;= t) cmp %edi,%ecx &#123; jle 400ff2 &lt;func4+0x24&gt; result = 0; mov $0x0,%eax if(x &gt;= t) cmp %edi,%ecx return result; jge 401007 &lt;func4+0x39&gt; else b = t + 1; lea 0x1(%rcx),%esi result = func4(a,b,x); callq 400fce &lt;func4&gt; result = 2*result + 1; lea 0x1(%rax,%rax,1),%eax &#125; else &#123; a = t - 1; lea -0x1(%rcx),%edx result = func4(a,b,x); callq 400fce &lt;func4&gt; result = result*2; add %eax,%eax &#125; return result;&#125; 初次调用fun4函数时为func(14,0,x),其中x为输入值最后得到结果为7 0 phase_5这一关还是有点难度，思路很难去想，也是看了好久的解题思路首先早早就发现了这关的密码是长度为6的字符串，但是一开始以为密码就是单纯的保存在寄存器或者那个浅显的地址当中，导致但是看到两个明显的地址，就去尝试，如下图所示，但是显然这不是正确的密码这条线索很快就找到了，但是看不懂和密码之间的关系，后来就看到题解和ASCII码有关，就沿着这个思路去寻找答案1234567891011121314151617181920212223242526272829303132333435363738394041A[] in %rbxint phase_5(int* A)&#123; push %rbx sub $0x20,%rsp mov %rdi,%rbx mov %fs:0x28,%rax mov %rax,0x18(%rsp) xor %eax,%eax callq 40131b &lt;string_length&gt; cmp $0x6,%eax je 4010d2 &lt;phase_5+0x70&gt; if(A.length != 6) callq 40143a &lt;explode_bomb&gt; explode_bomb jmp 4010d2 &lt;phase_5+0x70&gt; int i = 0; movzbl (%rbx,%rax,1),%ecx char c = A[i]; mov %cl,(%rsp) 取字符c的低四位 mov (%rsp),%rdx 0000-1111 即0-15 and $0xf,%edx movzbl 0x4024b0(%rdx),%edx 找出字符串0x4024b0对应数字的字符 mov %dl,0x10(%rsp,%rax,1) add $0x1,%rax i++； cmp $0x6,%rax while(i&lt;=6) jne 40108b &lt;phase_5+0x29&gt; movb $0x0,0x16(%rsp) mov $0x40245e,%esi 将字符串flyers作为函数调用的参数 lea 0x10(%rsp),%rdi 将输入的字符串作为另外一个参数 callq 401338 &lt;strings_not_equal&gt; 比较两个参数是否相等 test %eax,%eax je 4010d9 &lt;phase_5+0x77&gt; callq 40143a &lt;explode_bomb&gt; nopl 0x0(%rax,%rax,1) jmp 4010d9 &lt;phase_5+0x77&gt; mov $0x0,%eax jmp 40108b &lt;phase_5+0x29&gt; mov 0x18(%rsp),%rax xor %fs:0x28,%rax callq 400b30 &lt;__stack_chk_fail@plt&gt; add $0x20,%rsp pop %rbx retq &#125; 看懂了反汇编代码，我们就要去找0x40245e&quot;flyers&quot;每个字母对应ASCII码的低四位，并根据这个去找在字符串0x4024b0&quot;maduiersnfotvbyl对应的字母，最后答案有好几种,其中一个是ionefg phase_612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485push %r14 push %r13push %r12push %rbppush %rbxsub $0x50,%rspmov %rsp,%r13mov %rsp,%rsicallq 40145c &lt;read_six_numbers&gt;mov %rsp,%r14mov $0x0,%r12dmov %r13,%rbpmov 0x0(%r13),%eaxsub $0x1,%eaxcmp $0x5,%eaxjbe 401128 &lt;phase_6+0x34&gt;callq 40143a &lt;explode_bomb&gt;add $0x1,%r12dcmp $0x6,%r12dje 401153 &lt;phase_6+0x5f&gt;mov %r12d,%ebxmovslq %ebx,%raxmov (%rsp,%rax,4),%eaxcmp %eax,0x0(%rbp)jne 401145 &lt;phase_6+0x51&gt;callq 40143a &lt;explode_bomb&gt;add $0x1,%ebxcmp $0x5,%ebxjle 401135 &lt;phase_6+0x41&gt;add $0x4,%r13jmp 401114 &lt;phase_6+0x20&gt;lea 0x18(%rsp),%rsimov %r14,%raxmov $0x7,%ecxmov %ecx,%edxsub (%rax),%edxmov %edx,(%rax)add $0x4,%raxcmp %rsi,%raxjne 401160 &lt;phase_6+0x6c&gt;mov $0x0,%esijmp 401197 &lt;phase_6+0xa3&gt;mov 0x8(%rdx),%rdxadd $0x1,%eaxcmp %ecx,%eaxjne 401176 &lt;phase_6+0x82&gt;jmp 401188 &lt;phase_6+0x94&gt;mov $0x6032d0,%edxmov %rdx,0x20(%rsp,%rsi,2)add $0x4,%rsicmp $0x18,%rsije 4011ab &lt;phase_6+0xb7&gt;mov (%rsp,%rsi,1),%ecxcmp $0x1,%ecxjle 401183 &lt;phase_6+0x8f&gt;mov $0x1,%eaxmov $0x6032d0,%edxjmp 401176 &lt;phase_6+0x82&gt;mov 0x20(%rsp),%rbxlea 0x28(%rsp),%raxlea 0x50(%rsp),%rsimov %rbx,%rcxmov (%rax),%rdxmov %rdx,0x8(%rcx)add $0x8,%raxcmp %rsi,%raxje 4011d2 &lt;phase_6+0xde&gt;mov %rdx,%rcxjmp 4011bd &lt;phase_6+0xc9&gt;movq $0x0,0x8(%rdx) mov $0x5,%ebpmov 0x8(%rbx),%raxmov (%rax),%eaxcmp %eax,(%rbx)jge 4011ee &lt;phase_6+0xfa&gt;callq 40143a &lt;explode_bomb&gt;mov 0x8(%rbx),%rbxsub $0x1,%ebpjne 4011df &lt;phase_6+0xeb&gt;add $0x50,%rsppop %rbxpop %rbppop %r12pop %r13pop %r14 输入的六个数字有以下条件 每个数字都不能大于6并且都大于0 六个数字各不相同 前五个数字做7-x反转]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿谢的BLOG Beta3.9版 发布说明]]></title>
    <url>%2F2018%2F03%2F10%2F%E9%98%BF%E8%B0%A2%E7%9A%84BLOG-Beta3-9%E7%89%88-%E5%8F%91%E5%B8%83%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[折腾了一个晚上也算是搭建好了属于自己的小窝，我不是一个很会说话的人，即使我有酒和故事，我也不会和别人讲，但我愿意以文字的形式在这记录我的故事，记录我的成长。 安装 注册github账户 安装Git 安装node.js 安装hexo 使用入门 分类和标签 导航栏 摘要(文章折叠) markdown简单语法 部署 主题修改 图片 总结 安装 注册github：我想作为一个同性交友网站，github是每个程序员都需要注册和使用的。 安装Git: 学会使用Git就可以替代Windows下的命令行。 划重点：接下来的两步都是 文档|hexo 上面都的，要学会看文档，不管是哪种类型。 安装node.js 安装hexo 使用入门多标签:[tag1,tag2,tag3]导航栏：1hexo new page &quot;xxx&quot; 产生如下图所示的文件格式 markdown简单语法： 一级标题:# 摘要(文章折叠):&lt;!–more–&gt;之前的文字就会显示在文章首页，后面的文字就会被折叠。 链接和锚点: 123[安装](#1) &lt;span id = &quot;1&quot;&gt;**安装**&lt;/span&gt; 粗体:斜体，粗体，斜体和粗体 转义:比如我要打出&lt;!–more–&gt;，可以在”!”前添加”\” 文章间跳转: 1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 链接样式: 12345678910111213//修改文件 themes\next\source\css\_common\components\post\post.styl ，//在末尾添加如下css样式，颜色可以自己定义。.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 主页文章添加阴影效果: 123456789// 打开\themes\next\source\css\_custom\custom.styl,向里面加入:.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 数学公式：在主题文件的_config.yml找到mathjax,并将其设置为trueLaTe常见符号123456789101112mathjax: enable: true per_page: true//并在需要数学公式的文章前将mathjax开关打开mathjax: true$$f([\frac&#123;1+\&#123;x,y\&#125;&#125;&#123;(\frac&#123;x&#125;&#123;y&#125;+\frac&#123;y&#125;&#123;x&#125;)(u+1)&#125;+a]^&#123;3\2&#125;)$$//效果如下所示 $$f([\frac{1+{x,y}}{(\frac{x}{y}+\frac{y}{x})(u+1)}+a]^{3\2})$$ 部署：123hexo cleanhexo generatehexo deploy 图片： 在根目录下_config.yml中找到post_asset_folder，并将其值修改为true； 右键Git Bash Here输入：npm install hexo-asset-image –save 输入hexo n “xxxx”,产生xxxx.md文件同时还会生成一个xxxx文件夹 将图片复制进xxxx文件夹,并在xxxx.md对应位置输入![t](xxxx/x.jpg) 注意:xxxx为文件夹的名字,x为图片的名字，jpg也是分大小写的。 总结其实很早就开始写Blog，之前是在CSDN，写着写着感觉不爽，想要有自己的定制Blog，于是就想到搭建属于自己的Blog。今后会在这上面写下自己的学习过程，自己的心得体会。搭建Blog之前，还没开始尝试，就去问了一个学长，可不可以教教我怎么搭建Blog，学长只和我说了一句话:”学计算机要有自学能力，不要一上来就问能不能教教我”,我当时就感觉很惭愧，觉得自己连怎么向别人提问题都不会。之前看过一本书叫《学会提问》，我想我有必要去再看一遍。 参考:https://segmentfault.com/a/1190000009544924 更新站内搜索（2019.3.23 update）当博客中的文章越来越多时，自然就会有这个需求，因此有此次更新 这里第一步就不顺利，原因是环境变量设置错误，根据错误提示修改环境变量后解决 npm install hexo-generator-searchdb --save 在站点配置文件添加 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件 12local_search: enable: true Sitemap（2019.3.23 update） 安装针对谷歌和百度的插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 重新部署就能在博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml 注意修改根目录配置文件中的URL为你博客首页，这样是为了保证生成的sitemap.xml文件中地址正确 下面访问就能查看自己网站的网页树 然后将该文件添加到百度站点，谷歌站点 在将站点加入百度引擎时，需要验证网站所有者，下面是设置HTML方法 在主题的_config.yml themes\next\layout\_partials下添加 谷歌的效率还是高！几分钟就能搜索到！ 整篇都是自己网站的结果哈哈哈哈！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>nodejs</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
