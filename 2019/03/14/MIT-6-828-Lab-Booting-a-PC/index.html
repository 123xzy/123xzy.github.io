<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="Khli46YQxkzLrGPC8TO1Jnk9UfI0AHZrdIvc81pJqDA" />



  <meta name="msvalidate.01" content="true" />






  <meta name="baidu-site-verification" content="PB8YrnF2my"/>







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统," />










<meta name="description" content="实验1：启动PC">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 Lab:Booting a PC">
<meta property="og:url" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/index.html">
<meta property="og:site_name" content="阿谢的BLOG">
<meta property="og:description" content="实验1：启动PC">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/1.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/2.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/3.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/4.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/5.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/6.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/7.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/8.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/9.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/10.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/11.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/12.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/13.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/14.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/15.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/16.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/17.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/19.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/20.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/21.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/18.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/22.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/24.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/23.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/29.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/26.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/27.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/28.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/25.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/30.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/31.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/33.JPG">
<meta property="og:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/32.JPG">
<meta property="og:updated_time" content="2019-04-10T14:38:28.945Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 Lab:Booting a PC">
<meta name="twitter:description" content="实验1：启动PC">
<meta name="twitter:image" content="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/1.JPG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/"/>





  <title>MIT 6.828 Lab:Booting a PC | 阿谢的BLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">阿谢的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/Life" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Life
          </a>
        </li>
      
        
        <li class="menu-item menu-item-theory">
          <a href="/Theory" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Theory
          </a>
        </li>
      
        
        <li class="menu-item menu-item-practice">
          <a href="/Practice" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Practice
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/About" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="123xzy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿谢的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT 6.828 Lab:Booting a PC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-14T21:27:48+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>实验1：启动PC<br><a id="more"></a></p>
<hr>
<a href="/2019/03/08/MIT-6-828-Operating-System-Engineering/" title="MIT 6.828 Operating System Engineering">MIT 6.828 Operating System Engineering</a>
<p>该实验<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener">原始指南</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本实验分为三个部分</p>
<ul>
<li>getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstrap procedure</li>
<li>examines the boot loader for our 6.828 kernel</li>
<li>delves into the initial template for our 6.828 kernel itself</li>
</ul>
<h1 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h1><p>介绍x86汇编语言和PC引导程序（PC Bootstrap），并开始使用QEMU和QEMU/GDB调试</p>
<h2 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h2><p>MIT官方为我们提供了一个关于汇编语言的参考资料<a href="https://pdos.csail.mit.edu/6.828/2014/readings/pcasm-book.pdf" target="_blank" rel="noopener">pcasm-book</a>，里面基本介绍了汇编语言的方方面面，你可以把这本书作为一个备查，遇到没看过的命令就上里面查，或者直接上网查。如果没有任何汇编基础，建议还是看一看书，把一些基础的指令看懂</p>
<p>本书中的示例是为NASM汇编程序编写的，而我们将使用GNU汇编程序。NASM使用所谓的Intel语法，而GNU使用AT＆T语法。虽然在语义上是等效的，但是程序集文件会有很大不同，至少表面上看，这取决于使用的语法。幸运的是，两者之间的转换非常简单，并且在<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">汇编指南</a>中有所介绍</p>
<h2 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h2><p><code>Instead of developing the operating system on a real, physical personal computer (PC), we use a program that faithfully emulates a complete PC: the code you write for the emulator will boot on a real PC too. Using an emulator simplifies debugging; you can, for example, set break points inside of the emulated x86, which is difficult to do with the silicon version of an x86.</code></p>
<p>进行该部分需要安装QEMU（<a href="/2019/03/08/MIT-6-828-Lab-Guide/" title="MIT 6.828 Lab:Guide">MIT 6.828 Lab:Guide</a>，该文章中有实验的所有前期准备指南）和熟悉GDB调试（<a href="/2018/03/11/GDB-GCC/" title="GDB GCC">GDB GCC</a>）</p>
<p><code>Everything after &#39;Booting from Hard Disk...&#39; was printed by our skeletal JOS kernel; the K&gt; is the prompt printed by the small monitor, or interactive control program, that we&#39;ve included in the kernel. These lines printed by the kernel will also appear in the regular shell window from which you ran QEMU. This is because for testing and lab grading purposes we have set up the JOS kernel to write its console output not only to the virtual VGA display (as seen in the QEMU window), but also to the simulated PC&#39;s virtual serial port, which QEMU in turn outputs to its own standard output.</code></p>
<p>启动给内核之后，所有字符就是由<code>JOS kernel</code>产生</p>
<p><code>There are only two commands you can give to the kernel monitor, help and kerninfo.</code></p>
<p>现在只有两个命令可以使用：<code>help</code> <code>kerninfo</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/1.JPG" alt="运行截图"></p>
<p><code>Although simple, it&#39;s important to note that this kernel monitor is running &quot;directly&quot; on the &quot;raw (virtual) hardware&quot; of the simulated PC. This means that you should be able to copy the contents of obj/kern/kernel.img onto the first few sectors of a real hard disk, insert that hard disk into a real PC, turn it on, and see exactly the same thing on the PC&#39;s real screen as you did above in the QEMU window</code></p>
<p>虽然该内核还比较简单，但只要愿意，可以将该内核镜像写入硬盘前几个扇区，就能想真正启动PC一样启动它，并能看到完全一样的东西</p>
<h2 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h2><p><code>A PC&#39;s physical address space is hard-wired to have the following general layout:</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/2.JPG" alt="运行截图"></p>
<p>早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为<code>Low memory</code>，这只能被随机存储器(RAM)使用</p>
<p>从<code>0x000A0000</code>到<code>0x000FFFFF</code>的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从<code>0x000F0000</code>到<code>0x000FFFFF</code>占据64KB区域的部分是最重要的<strong>BIOS</strong></p>
<p>现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了<code>0xFFFFFFFF</code>。<code>JOS</code>这里只用开始的256MB，所以假设PC只有32位地址空间</p>
<h2 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h2><p>这部分研究计算机如何<strong>启动</strong></p>
<p>在一个终端中输入<code>make qemu-gdb</code>，这将启动QEMU，但QEMU在处理器执行第一条指令之前停止，并等待来自GDB的调试连接，另一个终端输入<code>make gdb</code><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/3.JPG" alt="运行截图"></p>
<p><code>[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b</code>是GDB反汇编出的第一条执行指令，表明：</p>
<ul>
<li>IBM PC从物理地址<code>0x000ffff0</code>处执行，该地址位于为ROM BIOS保留的64KB区域的最顶端</li>
<li>PC从地址<code>CS=0xf000,IP=0xfff0</code>开始执行</li>
<li>执行的第一条指令是<code>jmp</code>指令，它跳转到分段地址<code>CS = 0xf000,IP=0xe05b</code></li>
</ul>
<p>由于PC中的BIOS与物理地址范围<code>0x000f0000-0x000fffff</code>“硬连线”，因此该设计可确保BIOS在上电或任何系统重启后始终首先控制机器。QEMU仿真器带有自己的BIOS，它放置在处理器的模拟物理地址空间中的位置。当通电后，处理器进入实模式也就是设置<code>CS:IP</code>两个寄存器为<code>CS=0xf000,IP=0xfff0</code>，为什么这个段地址指示的是<code>0x000ffff0</code>？</p>
<p><code>0x000ffff0</code>是BIOS结束前的16个字节（<code>0x100000</code>）</p>
<p>当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取<code>Boot loader</code>并转移控制</p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/4.JPG" alt="运行截图">可以通过GDB<code>si</code>命令一步步猜测BIOS正在做什么！</p>
<h1 id="The-Boot-Loader"><a href="#The-Boot-Loader" class="headerlink" title="The Boot Loader"></a>The Boot Loader</h1><p>PC的软盘和硬盘分为512个字节区域，称为扇区。扇区是磁盘的最小传输粒度：每个读取或写入操作必须是一个或多个扇区，并在扇区边界上对齐。如果磁盘是可引导的，则第一个扇区称为引导扇区，因为这是boot loader代码所在的位置。当BIOS找到可引导的软盘或硬盘时，它将512字节的引导扇区加载到物理地址<code>0x7c00</code>到<code>0x7dff</code>的内存中，然后使用jmp指令将<code>CS：IP</code>设置为<code>0000：7c00</code>，将控制权传递给boot loader</p>
<p>对于6.828，boot loader包含一个汇编语言源文件<code>boot/boot.S</code>和一个C源文件<code>boot/main.c</code>，仔细查看这些源文件，确保您了解正在发生的事情</p>
<p>boot loader分为汇编语言和C语言两部分的原因，我想是因为最开始启动的时候使用汇编更加精准，之后使用C则使编码效率更高，语义更丰富</p>
<p>在<code>main.c</code>有以下注释，详细讲述了启动流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span></span><br><span class="line"><span class="comment"> *    be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in boot.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br></pre></td></tr></table></figure></p>
<p>boot loader执行两个主要功能：</p>
<ul>
<li>boot loader将处理器从实模式切换到32位保护模式，因为只有在此模式下，软件才能访问处理器物理地址空间中1MB以上的所有内存</li>
<li>boot loader通过x86的特殊I/O指令直接访问IDE磁盘设备寄存器，从硬盘读取内核</li>
</ul>
<p>在了解了boot loader源代码之后，查看文件<code>obj/boot/boot.asm</code>。此文件是我们的<code>GNUmakefile</code>在编译boot loader后创建的boot loader的反汇编。这个反汇编文件可以很容易地查看所有boot loader代码所在的物理内存的确切位置，并且可以更轻松地跟踪在GDB中单步执行boot loader时发生的情况。同样，<code>obj/kern/kernel.asm</code>包含一个JOS内核的反汇编，它通常可用于调试</p>
<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><p>在地址0x7c00处设置断点，这是加载引导扇区的位置。继续执行直到该断点。通过跟踪开机代码<code>/boot.S</code>、使用的源代码、反汇编文件<code>OBJ的/boot/boot.asm</code>跟踪你在哪里。还可以使用GDB中的<code>x/i</code>命令来反汇编boot loader中的指令序列，并将原始boot loader代码与<code>obj/boot/boot.asm</code>和GDB中的反汇编进行比较</p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/5.JPG" alt="运行截图"></p>
<p>跟踪<code>main.c/bootmain()</code>，然后进入<code>readsect()</code> 。确定与<code>readsect()</code>中每个语句对应的精确汇编指令。跟踪<code>readsect()</code>的其余部分并返回到<code>bootmain()</code>，并识别for循环的开始和结束，从磁盘读取内核的剩余扇区。找出循环结束时将运行的代码，在那里设置断点，并继续该断点。然后逐步执行boot loader的其余部分</p>
<p>问题：</p>
<ul>
<li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?<br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/6.JPG" alt="运行截图"></li>
<li><p>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return!</span></span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0x10000c</span>:	movw   $<span class="number">0x1234</span>,<span class="number">0x472</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?<br>通过查看ELF信息头查看</p>
</li>
</ul>
<p>回答完这三个命令，我们再好好看一看这几段代码！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// read 1st page off disk</span></span><br><span class="line">        readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// is this a valid ELF?</span></span><br><span class="line">        <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">                <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">        ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">        eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">        <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">                <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">                <span class="comment">// as the physical address)</span></span><br><span class="line">                readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">        <span class="comment">// note: does not return!</span></span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bootmain</code>先读取ELF文件头信息（关于ELF文件，可以查看<a href="/2019/01/07/修养-《目标文件》/" title="《目标文件》">《目标文件》</a>），获取文件大小，然后判断魔数，然后调用<code>readseg</code>函数循环读取扇区内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></span><br><span class="line"><span class="comment">// Might copy more than asked</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">        end_pa = pa + count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round down to sector boundary</span></span><br><span class="line">        pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">        offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">        <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">        <span class="comment">// we load in increasing order.</span></span><br><span class="line">        <span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">                <span class="comment">// Since we haven't enabled paging yet and we're using</span></span><br><span class="line">                <span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">                <span class="comment">// use physical addresses directly.  This won't be the</span></span><br><span class="line">                <span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">                readsect((<span class="keyword">uint8_t</span>*) pa, offset);</span><br><span class="line">                pa += SECTSIZE;</span><br><span class="line">                offset++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有3个参数，第一个是物理地址，第二个是页的大小，第三个是偏移量。函数先计算末尾地址，在根据字节数得出扇区号，最后循环读取扇区内容到内存地址<code>pa</code>处，读完之后，移动内存地址和扇区</p>
<h2 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h2><p>现在，我们将对<code>boot/main.c</code>中的boot loader的C语言部分详细介绍</p>
<p>ELF头的C定义在inc / elf.h中。我们感兴趣的计划部分是：</p>
<ul>
<li><code>.text</code>：程序的可执行指令</li>
<li><code>.rodata</code>：只读数据，例如C编译器生成的ASCII字符串常量（但是，我们不会费心设置硬件来禁止写入。）</li>
<li><code>.data</code>：数据部分保存程序的初始化数据，例如使用初始化器（如int x = 5）声明的全局变量</li>
</ul>
<p>通过<code>objdump -h obj/kern/kernel</code>，检查内核可执行文件中所有段的名称，大小和链接地址<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/7.JPG" alt="运行截图"></p>
<p>请特别注意<code>.text</code>部分的<code>VMA</code>（或链接地址）和<code>LMA</code>（或加载地址） 。段的加载地址是应该将该段加载到内存中的内存地址。段的链接地址是段期望执行的内存地址</p>
<p>通常链接和加载地址是相同的。查看boot loader的<code>.text</code>部分：<code>objdump -h obj/boot/boot.out</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/8.JPG" alt="运行截图"></p>
<p>boot loader使用ELF 程序头来决定如何加载节。程序头指定要加载到内存中的ELF对象的哪些部分以及每个应占用的目标地址。您可以通过键入以下内容来检查程序标题<code>objdump -x obj/kern/kernel</code><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/9.JPG" alt="运行截图"></p>
<p>程序头在objdump的输出中的<code>Program Headers</code>下列出。需要加载到内存中的ELF对象的区域是标记为<code>LOAD</code>的区域。给出了每个程序头的其他信息，例如虚拟地址<code>vaddr</code>，物理地址<code>paddr</code>和加载区域的大小<code>memsz</code> <code>filesz</code></p>
<p>回到<code>boot/main.c</code>，<code>ph-&gt;p_pa</code>是每个程序头包含的段目的物理地址</p>
<p>BIOS把引导扇区加载到内存地址<code>0x7c00</code>，这也就是引导扇区的加载地址和链接地址。在<code>boot/Makefrag</code>中，是通过传<code>-Ttext 0x7C00</code>这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址</p>
<p>ELF头中还有一个对我们很重要的字段，名为<code>e_entry</code>，该字段保存程序中入口点的链接地址，也就是程序执行的text字段中的内存地址。<code>objdump -f obj/kern/kernel</code></p>
<p>现在应该能够理解<code>boot/ main.c</code>中的最小ELF加载器 。它将内核的每个部分从磁盘读入内存的部分加载地址，然后跳转到内核的入口点</p>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p>阅读Brian Kernighan和Dennis Ritchie编写的<a href="https://github.com/123xzy/K-R" target="_blank" rel="noopener">《C程序设计语言》</a>（称为“K＆R”）中的5.5和5.1，并理解<a href="https://pdos.csail.mit.edu/6.828/2014/labs/lab1/pointers.c" target="_blank" rel="noopener">pointers.c</a></p>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p><code>change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens.</code></p>
<p>修改<code>boot/Makefrag</code>，把引导扇区的加载地址和链接地址从<code>0x7c00</code>改为<code>0x8c00</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/10.JPG" alt="运行截图"></p>
<p>可以发现起始地址从原来的<code>00007c00</code>变为<code>00008c00</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/11.JPG" alt="运行截图"></p>
<p>由于BIOS载入内核后，是跳转到<code>00007c00</code>，显然这样子就无法加载成功<br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/12.JPG" alt="运行截图"></p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p><code>Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</code></p>
<p>使用GDB的<code>x/Nx ADDR</code>可以打印内存地址ADDR的N个字</p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/13.JPG" alt="运行截图"></p>
<p>这里很明显是因为内核程序被加载到了0x100000地址处，使用<code>x /8i *0x100000</code>可以反汇编查看内存地址对应的指令，如果去查看<code>kernel</code>的目标文件，会发现两者一致<br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/14.JPG" alt="运行截图"><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/15.JPG" alt="运行截图"></p>
<h1 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h1><p>我们现在将开始更详细地研究JOS内核（最后你会写一些代码！）。与boot loader一样，内核以一些汇编语言代码开始，这些代码设置正确，以便C语言代码可以正确执行</p>
<h2 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h2><p>boot loader的链接地址和加载地址是一样的，然而kernel 的链接地址和加载地址有些差异。查看<code>kern/kernel.ld</code>可以发现链接地址在<code>0xF0100000</code>，加载地址为<code>0x100000</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/16.JPG" alt="运行截图"></p>
<p>操作系统内核通常喜欢链接并在非常高的虚拟地址（例如<code>0xf0100000</code>）下运行，以便留下处理器虚拟地址空间的下半部分供用户程序使用</p>
<p>许多机器在地址<code>0xf0100000</code>处没有任何物理内存，因此我们无法指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址<code>0xf0100000</code>（内核代码期望运行的链接地址）映射到物理地址<code>0x00100000</code>（boot loader将内核加载到物理内存中）。这样，虽然内核的虚拟地址足够高，可以为用户进程留出足够的地址空间，但它将被加载到PC RAM的1MB点的物理内存中，就在BIOS ROM上方。这种方法要求PC至少有几兆字节的物理内存（因此物理地址<code>0x00100000</code>可以工作）</p>
<p>在下一个实验中，我们将把物理地址<code>0x00000000</code>到<code>0x0fffffff</code>的整个底部256MB的物理地址空间分别映射到虚拟地址<code>0xf0000000</code>到<code>0xffffffff</code>。您现在应该明白为什么JOS只能使用前256MB的物理内存</p>
<p>我们使用<code>kern/entrypgdir.c</code>中手写的、静态初始化的页面目录和页表来完成 映射前4MB的物理内存的操作</p>
<p>如果<code>kern/entry.S</code>中没有设置<code>CR0_PG</code>标志，内存引用被视为物理地址（严格来说，它们是线性地址，但<code>boot/boot.S</code>设置从线性地址到物理地址的身份映射，我们永远不会要改变那个）；如果设置，内存引用就变为虚拟地址，由虚拟内存硬件转换为物理地址的虚拟地址。 <code>entry_pgdir</code>将<code>0xf0000000</code>到<code>0xf0400000</code>范围内的虚拟地址转换为物理地址<code>0x00000000</code>到<code>0x00400000</code>，以及虚拟地址<code>0x00000000</code>到<code>0x00400000</code>到物理地址<code>0x00000000</code>到<code>0x00400000</code>。任何不属于这两个范围之一的虚拟地址都会导致硬件异常，因为我们尚未设置中断处理，将导致QEMU转储机器状态并退出</p>
<h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p><code>Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.
What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren&#39;t in place? Comment out the movl %eax, %cr0 in kern/entry.S, trace into it, and see if you were right.</code></p>
<p>第一部分没能成功，不知道为什么，不管是在<code>movl %eax, %cr0</code>之前还是之后，两个地址的值都是一样的，照理说应该是不一样的。原因就是之前还没有建立分页机制，高地址内核区域还没有映射到内核的物理地址，而只有低地址有效的．开启分页之后，由于有静态映射表的存在(<code>kern/enterpgdir.c</code>)，两块虚拟地址都指向同一块物理地址区域。但是第二阶段却可以完成</p>
<p>在注释掉<code>movl %eax, %cr0</code>，也就是关闭虚拟内存之后，就会出现以下错误，因为物理内存只有<code>0x001002c</code>，无法获取<code>0xf01002c</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/17.JPG" alt="运行截图"></p>
<h2 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h2><p>大多数人认为像<code>printf()</code>这样的函数是理所当然的，有时甚至认为它们是C语言的“原语”。但在OS内核中，我们必须自己实现所有<code>I/O</code></p>
<p>通读<code>kern/printf.c</code> <code>lib/printfmt.c</code> <code>kern/console.c</code>，确保了解它们之间的关系。在后面的实验中将清楚为什么<code>printfmt.c</code>位于单独的lib目录中</p>
<p><code>kern/printf.c</code> 和 <code>lib/printfmt.c</code> 依赖 <code>kern/console.c</code></p>
<p>现在回答一下问题</p>
<ul>
<li><strong>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">putch(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span><br><span class="line">&#123;</span><br><span class="line">        cputchar(ch);</span><br><span class="line">        *cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">vcprintf(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vprintfmt((<span class="keyword">void</span>*)putch, &amp;cnt, fmt, ap);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">cprintf(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        cnt = vcprintf(fmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上图显示了<code>printf.c</code>实现的接口，下图显示了<code>console.c</code>提供的接口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `High'-level console I/O.  Used by readline and cprintf.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">cputchar(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        cons_putc(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">getchar(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((c = cons_getc()) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">/* do nothing */</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">iscons(<span class="keyword">int</span> fdnum)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// used by readline</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出关键函数是<code>cons_putc()</code>，其功能就是输出字符到控制台，而该函数又是由三个函数组成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output a character to the console</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cons_putc(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        serial_putc(c);</span><br><span class="line">        lpt_putc(c);</span><br><span class="line">        cga_putc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们一个个来看，先看<code>serial_putc(c)</code>，由名字看是<strong>串行输出</strong>的意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM1            0x3F8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LSR         5       <span class="comment">// In:  Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LSR_TXRDY 0x20    <span class="comment">//   Transmit buffer avail</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_TX          0       <span class="comment">// Out: Transmit buffer (DLAB=0)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">serial_putc(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">             !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>;</span><br><span class="line">             i++)</span><br><span class="line">                delay();</span><br><span class="line"></span><br><span class="line">        outb(COM1 + COM_TX, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它控制的是端口<code>0x3F8</code>，<code>inb</code>读取的是<code>COM1 + COM_LSR = 0x3FD</code>端口，<code>outb</code>输出到<code>COM1 + COM_TX = 0x3F8</code></p>
<p><code>!(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY)</code>则是判断传输缓存是否avail，<code>outb</code>是将字符<code>c</code>输出到传输缓存<code>COM1 + COM_TX</code></p>
<p>再来看 <code>lpt_putc()</code>，是<strong>并行输出</strong>的意思，把字符<code>c</code>传输给并口设备端口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** Parallel port output code *****/</span></span><br><span class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lpt_putc(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)</span><br><span class="line">                delay();</span><br><span class="line">        outb(<span class="number">0x378</span>+<span class="number">0</span>, c);</span><br><span class="line">        outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);</span><br><span class="line">        outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是<code>cga_putc(c)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">cga_putc(<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if no attribute given, then use black on white</span></span><br><span class="line">    <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</span><br><span class="line">        c |= <span class="number">0x0700</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\b'</span>:</span><br><span class="line">        <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            crt_pos--;</span><br><span class="line">            crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">        crt_pos += CRT_COLS;</span><br><span class="line">        <span class="comment">/* fallthru */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">        crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        cons_putc(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        crt_buf[crt_pos++] = c;        <span class="comment">/* write the character */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move that little blinky thing */</span></span><br><span class="line">    outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先 <code>!(c &amp; ~0xFF)</code> 是否在 0 ~ 255 之前。<code>\b</code>就是退格键，让缓冲区 <code>crt_buf</code> 的下标 <code>crt_pos</code> 减1。其他的同理，case都是格式操作。default就是往缓冲区里写入字符c。之后就是当缓存超过<code>CRT_SIZE</code>，就是用<code>memmove</code>复制内存内容，证明屏幕放不下了，需要页面向上滚动一行。最后四句代码是将缓冲区的内容输出到显示屏</p>
<ul>
<li><strong>Explain the following from console.c</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">memcpy</span>(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">                crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是检测当前屏幕的输出<code>buffer</code>是否满了，这里注意<code>memmove</code>是把第二个参数<code>crt_buf + CRT_COLS</code>指向的地址加上<code>(CRT_SIZE - CRT_COLS) * sizeof(uint16_t))</code>后的地址赋值给第一个参数<code>crt_buf</code></p>
<p>如果buffer满了,把屏幕第一行覆盖掉逐行上移，空出最后一行，并由for循环填充以<code></code>，最后把<code>crt_pos</code>置于最后一行的行首</p>
<ul>
<li><strong>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.Trace the execution of the following code step-by-step.In the call to cprintf(), to what does fmt point? To what does ap point?</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<p><code>fmt</code>指向的就是字符串<code>&quot;x %d, y %x, z %d\n&quot;</code>，<code>ap</code>指向一个参数列表，在这里就是<code>x,y,z</code></p>
<p>List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.</p>
<p>这里的问题就是c语言中的变长参数的实现，先跳过！！！！</p>
<ul>
<li><strong>Run the following code.What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here’s an ASCII table that maps bytes to characters.The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</strong></li>
</ul>
<p>将下述代码加入<code>kern/monitor.c</code>，并重新编译运行就能看到结果<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">"H%x Wo%s\n"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/19.JPG" alt="运行截图">我们看到输出了<code>He110 World</code>，原理就是根据ASCII码输出。首先<code>%x</code>是指十六进制，所以将 <code>57616</code>转为十六进制就是<code>e110</code>。这里的<code>%s</code>部分是打印的i地址处的值，由于是little-endian机器，所以i的值在储存的时候是<code>72 6c 64 00</code>.这样对应的ASCII码就是<code>rld</code>。如果是大端机器，不需要改变57616，但是i要变为<code>0x726c6400</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/20.JPG" alt="运行截图"></p>
<ul>
<li><strong>In the following code, what is going to be printed after ‘y=’? (note: the answer is not a specific value.) Why does this happen?</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">"x=%d y=%d"</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看到输出为y因为没有被指定值，所以输出的是不确定的<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/21.JPG" alt="运行截图"></p>
<ul>
<li><strong>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</strong></li>
</ul>
<p>这道题目需要明白怎么实现<strong>变长数组</strong>才能回答！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">cprintf(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        cnt = vcprintf(fmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>...</code>表示参数的数量和类型可能会改变，这个符号只会出现在参数列表的末尾</p>
<p>实现这个的困难在于函数不知道参数的名字，在标准头库<code>&lt;stdarg.h&gt;</code>包含了一系列定义如何遍历参数列表的宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _STDARG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STDARG_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Amount of space required in an argument list for an arg of type TYPE.</span></span><br><span class="line"><span class="comment">   TYPE may alternatively be an expression whose type is used.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __va_rounded_size(TYPE)  </span></span><br><span class="line">  (((<span class="keyword">sizeof</span> (TYPE) + <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">1</span>) / <span class="keyword">sizeof</span> (<span class="keyword">int</span>)) * <span class="keyword">sizeof</span> (<span class="keyword">int</span>))</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __sparc__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(AP, LASTARG)                       </span></span><br><span class="line"> (AP = ((<span class="keyword">char</span> *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(AP, LASTARG)                       </span></span><br><span class="line"> (__builtin_saveregs (),                        </span><br><span class="line">  AP = ((<span class="keyword">char</span> *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span> <span class="params">(va_list)</span></span>;      <span class="comment">/* Defined in gnulib */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(AP)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(AP, TYPE)                        </span></span><br><span class="line"> (AP += __va_rounded_size (TYPE),                   </span><br><span class="line">  *((TYPE *) (AP - __va_rounded_size (TYPE))))</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _STDARG_H */</span></span></span><br></pre></td></tr></table></figure>
<p><code>va_list</code>轮流指向每个未命名的变量，这个变量暂时就叫<code>ap</code>（argument pointer），宏<code>va_start</code>初始化使得<code>ap</code>指向第一个未命名参数，<code>va_arg(ap, type)</code>返回一个参数并使<code>ap</code>指向下一个，<code>type</code>表明返回类型和移动距离，最后<code>va_end</code>清理内存</p>
<p>变长函数的实现得益于C默认的cdecl调用惯例的<strong>自右向左压栈的参数传递方式</strong>，因为栈是以从高往低的方向增长的，<code>va_arg</code>每次是以地址往后增长取出下一参数变量的地址</p>
<p>回到这个问题本身，如果GCC按照声明的顺序压入参数，即自左向右， 那么需要修改上面代码中的 <code>va_start</code> 和 <code>va_arg</code> 两个宏,将其改成用减法得到新地址即可</p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p><code>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form &quot;%o&quot;. Find and fill in this code fragment.</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (unsigned) octal</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">        <span class="comment">// Replace this with your code.</span></span><br><span class="line">        <span class="comment">//putch('X', putdat);</span></span><br><span class="line">        <span class="comment">//putch('X', putdat);</span></span><br><span class="line">        <span class="comment">//putch('X', putdat);</span></span><br><span class="line">        num = getuint(&amp;ap,lflag);</span><br><span class="line">        base = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">goto</span> number;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>找到<code>lib/printfmt.c</code>并照着之前的画个葫芦就行，修改之后启动界面就能显示十进制数6828对应的八进制数15254<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/18.JPG" alt="运行截图"></p>
<h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h3><p><code>Enhance the console to allow text to be printed in different colors. If you&#39;re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</code></p>
<p>对于将VGA切换成图形模式就略过，不是我们的重点</p>
<p>回到<code>cga_putc(c)</code>函数，这里有这样一段注释<code>// if no attribute given, then use black on white</code>，对应代码是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</span><br><span class="line">        c |= <span class="number">0x0700</span>;</span><br></pre></td></tr></table></figure></p>
<p>检测c的8bit以上是否为0，如果是，那么黑白显示打印的字符，int c这个变量低8位控制显示的ASCII码。接着8-15bits用来控制颜色输出</p>
<p>因此我们将输出字符修改成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// character</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">        putch(va_arg(ap, <span class="keyword">int</span>) + <span class="number">0x1200</span>, putdat);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>此时输出的字符<code>X</code>就变成了紫色<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/22.JPG" alt="运行截图"></p>
<h2 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h2><p>我们将更详细地探讨C语言在x86上使用堆栈的方式，并在此过程中编写一个有用的新内核监视器函数，用于打印堆栈的回溯，即查看指令寄存器（IP）的值的变化</p>
<p>x86堆栈指针（esp寄存器）指向当前正在使用的堆栈上的最低位置。低于这个位置的空间还没使用<br>将值压入堆栈涉及减少堆栈指针，然后将值写入堆栈指针指向的位置。从堆栈中弹出一个值包括读取堆栈指针指向的值，然后增加堆栈指针。在32位模式下，堆栈只能保存32位值，esp总是可以被4整除。各种x86指令（例如调用）被“硬连线”以使用堆栈指针寄存器</p>
<h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><p><code>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which &quot;end&quot; of this reserved area is the stack pointer initialized to point to?</code></p>
<p>在<code>kern/entry.S</code>中找到下面的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">relocated:</span><br><span class="line"></span><br><span class="line">        # <span class="function">Clear the frame pointer <span class="title">register</span> <span class="params">(EBP)</span></span></span><br><span class="line"><span class="function">        <span class="meta"># so that once we get into debugging C code,</span></span></span><br><span class="line"><span class="function">        <span class="meta"># stack backtraces will be terminated properly.</span></span></span><br><span class="line">        movl    $0x0,%ebp                       # nuke frame pointer</span><br><span class="line"></span><br><span class="line">        # Set the <span class="built_in">stack</span> pointer</span><br><span class="line">        movl    $(bootstacktop),%esp</span><br><span class="line"></span><br><span class="line">        <span class="meta"># now to C code</span></span><br><span class="line">        call    i386_init</span><br><span class="line"></span><br><span class="line">        # Should never get here, but in <span class="keyword">case</span> we <span class="keyword">do</span>, just spin.</span><br><span class="line">spin:   jmp     spin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">###################################################################</span><br><span class="line"><span class="meta"># boot stack</span></span><br><span class="line">###################################################################</span><br><span class="line">        .p2align        PGSHIFT         <span class="meta"># force page alignment</span></span><br><span class="line">        .globl          bootstack</span><br><span class="line">bootstack:</span><br><span class="line">        .space          KSTKSIZE</span><br><span class="line">        .globl          bootstacktop</span><br><span class="line">bootstacktop:</span><br></pre></td></tr></table></figure></p>
<p><code>bootstacktop</code>就是栈顶，<code>bootstack</code>应该指的就是栈的位置，大小为<code>KSTKSIZE</code>，且恰好在数据段开头位置对齐之后</p>
<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><p><code>To become familiar with the C calling conventions on the x86, find the address of the test_backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words?</code></p>
<p>这个联系其实不难，因为在CSAPP的拆炸弹实验中都是类似的</p>
<h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><p><code>Implement the backtrace function(kern/monitor.c/mon_backtrace()) as specified above</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args <span class="number">00000001</span> f0109e80 f0109e98 f0100ed2 <span class="number">00000031</span></span><br><span class="line">  ebp f0109ed8  eip f01000d6  args <span class="number">00000000</span> <span class="number">00000000</span> f0100058 f0109f28 <span class="number">00000061</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">uint32_t</span> eip = *((<span class="keyword">uint32_t</span> *)ebp+<span class="number">1</span>);</span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="keyword">while</span> ((<span class="keyword">int</span>)ebp != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cprintf(<span class="string">"  ebp 0x%08x eip 0x%08x args "</span>, ebp, eip);</span><br><span class="line">                <span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++) &#123;</span><br><span class="line">                        cprintf(<span class="string">"%08x "</span>, args[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"\n"</span>);</span><br><span class="line">                eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">                ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的第一行反映当前正在执行的函数，即<code>mon_backtrace</code>本身，第二行反映调用的函数，<code>mon_backtrace</code>第三行反映调用该函数的函数，依此类推</p>
<p>在每一行中，ebp值表示进入该函数使用的堆栈的基指针：即，在输入函数之后堆栈指针的位置和函数序言代码设置基指针。列出的eip值是函数的返回指令指针：当函数返回时控件将返回的指令地址。返回指令指针通常指向调用指令之后的指令（为什么？）。最后，args之后列出的五个十六进制值 是有问题的函数的前五个参数，它们在调用函数之前就被推到了堆栈上？？？</p>
<p>可以将此新函数挂钩到内核监视器的命令列表中，以便用户可以交互地调用它<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/24.JPG" alt="运行截图"><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/23.JPG" alt="运行截图"></p>
<h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><p><code>Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip</code></p>
<p>已经提供<code>debuginfo_eip()</code>，其在符号表中查找EIP，并返回该地址的调试信息，就如注释所示，从特定的指令地址中读取信息填充到<code>Stab</code>结构体中，用于调试。该函数在<code>kern/kdebug.c</code>中定义<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/29.JPG" alt="运行截图"></p>
<p>下面的结构则保存着该函数读取的信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Debug information about a particular instruction pointer</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *eip_file;           <span class="comment">// Source code filename for EIP</span></span><br><span class="line">        <span class="keyword">int</span> eip_line;                   <span class="comment">// Source code linenumber for EIP</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *eip_fn_name;        <span class="comment">// Name of function containing EIP</span></span><br><span class="line">                                        <span class="comment">//  - Note: not null terminated!</span></span><br><span class="line">        <span class="keyword">int</span> eip_fn_namelen;             <span class="comment">// Length of function name</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> eip_fn_addr;          <span class="comment">// Address of start of function</span></span><br><span class="line">        <span class="keyword">int</span> eip_fn_narg;                <span class="comment">// Number of function arguments</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在文件kern / kernel.ld中查找<code>__STAB_ *</code>（即Symbol Table）</li>
</ul>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/26.JPG" alt="运行截图"></p>
<ul>
<li><code>objdump -h obj/kern/kernel</code></li>
</ul>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/27.JPG" alt="运行截图"></p>
<ul>
<li><code>objdump -G obj/kern/kernel</code></li>
</ul>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/28.JPG" alt="运行截图"></p>
<ul>
<li><code>gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c</code>，看<code>init.s.</code></li>
</ul>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/25.JPG" alt="运行截图"></p>
<ul>
<li>查看boot loader是否在内存中加载符号表作为加载内核二进制文件的一部分</li>
</ul>
<p>回到这道练习题，要我们在<code>Exercise 11</code>基础之上，显示更多调试信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">uint32_t</span> eip = *((<span class="keyword">uint32_t</span> *)ebp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="keyword">while</span> ((<span class="keyword">int</span>)ebp != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cprintf(<span class="string">"  ebp 0x%08x eip 0x%08x args "</span>, ebp, eip);</span><br><span class="line">                <span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++) &#123;</span><br><span class="line">                        cprintf(<span class="string">"%08x "</span>, args[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memset</span>(&amp;info,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct Eipdebuginfo));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!debuginfo_eip(eip,&amp;info))</span><br><span class="line">                        cprintf(<span class="string">"\t%s:%d:%s+%u\n"</span>,info.eip_file,info.eip_line,info.eip_fn_name,eip-info.eip_fn_addr);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        cprintf(<span class="string">"failed to get debufinfo for eip %x\n"</span>,eip);</span><br><span class="line"></span><br><span class="line">                eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">                ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每行给出堆栈帧<code>eip</code>对应文件名和行，后跟函数的名称和<code>eip</code>与函数的第一条指令的偏移量<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/30.JPG" alt="运行截图"></p>
<h1 id="实模式和保护模式区别及寻址方式"><a href="#实模式和保护模式区别及寻址方式" class="headerlink" title="实模式和保护模式区别及寻址方式"></a>实模式和保护模式区别及寻址方式</h1><p>我们先来说一下实模式和保护模式的区别。最早期的8086 CPU只有一种工作方式，那就是实模式，而且数据总线为16位，地址总线为20位，实模式下所有寄存器都是16位。而从80286开始就有了保护模式，从80386开始CPU数据总线和地址总线均为32位，而且寄存器都是32位。但80386以及现在的奔腾，酷睿等等CPU为了向前兼容都保留了实模式，现代操作系统在刚加电时首先运行在实模式下，然后再切换到保护模式下运行</p>
<p>相关链接<a href="/2018/07/02/修养-《程序员的自我修养》/" title="《程序员的自我修养》">《程序员的自我修养》</a></p>
<h2 id="实模式寻址方式"><a href="#实模式寻址方式" class="headerlink" title="实模式寻址方式"></a>实模式寻址方式</h2><p>刚才说了8086 CPU数据总线为16位，也就是一次最多能取$2^{16}=64KB$数据，这个数据也解释了实模式下为什么每个段最大只有64KB。但刚才还说了其地址总线为20位，这样它能寻址的能力其实是$2^{20}=1MB$，这也就是实模式下CPU的最大寻址能力。段寄存器明明就16位，为什么说它有有$2^{20}=1MB$的寻址能力呢？</p>
<p>因为芯片设计者想出了一种<strong>段地址+偏移地址</strong>的寻址方式（通常写作段地址：偏移地址）。8086内置4个段寄存器（如下文提到的<code>%ds</code> <code>%es</code> <code>ss</code>），每个段寄存器可以存放一个16位的段地址，在寻址时，处理器首先将段地址左移4位，然后再加上偏移地址，由此得到20位的物理地址（如 1234H:5678H所对应的物理地址为12340H+5678H=179B8H，其中， 1234H:5678H称作逻辑地址或虚地址）。当地址有溢出时（FFFFH:FFFFH 对应的物理地址是FFFF0H+FFFFH=10FFEFH，大于FFFFFH），会发生回卷（10FFEFH = FFF0H）</p>
<p>如此寻址会产生很多问题。一个段大小最大为$2^16=64KB$，并且，所有的段都是可读写的。这意味着不同的段存在着重叠部分（即不同的逻辑地址可以映射到相同的物理地址），无法保证程序的安全性（程序段可被修改），也不具有权限分级</p>
<h2 id="保护模式寻址方式"><a href="#保护模式寻址方式" class="headerlink" title="保护模式寻址方式"></a>保护模式寻址方式</h2><p>在定义“逻辑地址”时看到保护模式和实模式的区别在于它是用段选择符而非段基地址，这也许就是保护模式的真谛所在</p>
<p>在保护模式中，处理器将段信息存放于描述符表中。一张描述符表有$2^{13}$个条目（描述符），每条目8字节长，其中包括24位长的段起始物理地址、16位长的段长（因此段的长度范围从1 B到216 B，即不超过64 KiB），其余为属性信息。每一段的地址范围为 段首～段首+段长，每一个段的大小不一定相同（由段长确定）。描述符表有两个，一个是全局描述符表（GDT），一个是局部描述符表（LDT），也就是说，总共可以有$2 * 2^{13}$个段</p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/31.JPG" alt="运行截图"></p>
<p>保护模式下，段寄存器保存的内容称作选择器（selector），其本质是索引（13位，即在表中的偏移量）、TI位（1位，表示是使用GDT还是LDT）和优先级信息（2位，0-3值越小优先级越高）</p>
<p>在寻址时，首先拿出选择器（段寄存器）的高13位作为偏移量（索引），结合TI位找到描述符。取出其中24位长的段首地址信息，再加上偏移量（这个偏移量是段地址:偏移量 中的偏移量，前面提到的描述符表的偏移量是段地址的高13位），得到实际物理地址</p>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>它把物理内存分成相同固定大小$2^{12}=4KB$的页面。在分页寻址模式中，CPU维护一张页目录（page directory）与多张页表（page table），其中，页目首地址由CR3寄存器给出，而页表的首地址存放在页目中。页目与页表中的条目每条均为4字节，而每个页目页表最多能容纳1024个条目（即每张页目页表最大空间占用4KB，4096位）。页目与页表存放信息的方式相似，在每条目的32位中，最高20位（31-12）存放地址信息，剩余12位存放属性信息<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/33.JPG" alt="运行截图"></p>
<p>从一个逻辑地址经过分段和分页寻址物理地址的整个过程就如下图所示。总的来说整个过就是逻辑地址经分段机制变成线性地址，如果不启用分页的情况下，此线性地址就是物理地址;如果启用分页，那么线性地址经分页机制变成物理地址<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/32.JPG" alt="运行截图"></p>
<p>一个多段模型充分发挥了段机制对代码，数据结构和程序提供硬件保护的能力。每个程序都有自己的段描述符表和自己的段。段可以完全属于程序私有也可以和其它程序之间共享</p>
<p>访问权限的检查不仅仅用来保护地址越界，也可以保护某一特定段不允许操作。例如代码段是只读段，硬件可以阻击向代码段进行写操作</p>
<p>做了快一个星期，真的有点难度的哦！！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/14/Redis：多机数据库的实现/" rel="next" title="《多机数据库的实现》">
                <i class="fa fa-chevron-left"></i> 《多机数据库的实现》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/15/lab-data/" rel="prev" title="Data">
                Data <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">123xzy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">234</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/123xzy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xzy-71-59/activities" target="_blank" title="ZhiHu">
                      
                        <i class="fa fa-fw fa-globe"></i>ZhiHu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xzy0320@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PC-Bootstrap"><span class="nav-number">2.</span> <span class="nav-text">PC Bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-Started-with-x86-assembly"><span class="nav-number">2.1.</span> <span class="nav-text">Getting Started with x86 assembly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Simulating-the-x86"><span class="nav-number">2.2.</span> <span class="nav-text">Simulating the x86</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-PC’s-Physical-Address-Space"><span class="nav-number">2.3.</span> <span class="nav-text">The PC’s Physical Address Space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-ROM-BIOS"><span class="nav-number">2.4.</span> <span class="nav-text">The ROM BIOS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Boot-Loader"><span class="nav-number">3.</span> <span class="nav-text">The Boot Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-3"><span class="nav-number">3.1.</span> <span class="nav-text">Exercise 3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loading-the-Kernel"><span class="nav-number">3.2.</span> <span class="nav-text">Loading the Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-4"><span class="nav-number">3.2.1.</span> <span class="nav-text">Exercise 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-5"><span class="nav-number">3.2.2.</span> <span class="nav-text">Exercise 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-6"><span class="nav-number">3.2.3.</span> <span class="nav-text">Exercise 6</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Kernel"><span class="nav-number">4.</span> <span class="nav-text">The Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-virtual-memory-to-work-around-position-dependence"><span class="nav-number">4.1.</span> <span class="nav-text">Using virtual memory to work around position dependence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-7"><span class="nav-number">4.1.1.</span> <span class="nav-text">Exercise 7</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Formatted-Printing-to-the-Console"><span class="nav-number">4.2.</span> <span class="nav-text">Formatted Printing to the Console</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-8"><span class="nav-number">4.2.1.</span> <span class="nav-text">Exercise 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Challenge"><span class="nav-number">4.2.2.</span> <span class="nav-text">Challenge</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Stack"><span class="nav-number">4.3.</span> <span class="nav-text">The Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-9"><span class="nav-number">4.3.1.</span> <span class="nav-text">Exercise 9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-10"><span class="nav-number">4.3.2.</span> <span class="nav-text">Exercise 10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-11"><span class="nav-number">4.3.3.</span> <span class="nav-text">Exercise 11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-12"><span class="nav-number">4.3.4.</span> <span class="nav-text">Exercise 12</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实模式和保护模式区别及寻址方式"><span class="nav-number">5.</span> <span class="nav-text">实模式和保护模式区别及寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实模式寻址方式"><span class="nav-number">5.1.</span> <span class="nav-text">实模式寻址方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保护模式寻址方式"><span class="nav-number">5.2.</span> <span class="nav-text">保护模式寻址方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页机制"><span class="nav-number">5.3.</span> <span class="nav-text">分页机制</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">123xzy</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  :<span id="busuanzi_value_site_uv"></span>
</span>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
