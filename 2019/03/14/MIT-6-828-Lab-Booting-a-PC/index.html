<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统," />










<meta name="description" content="实验1：启动PC">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 Lab:Booting a PC">
<meta property="og:url" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/index.html">
<meta property="og:site_name" content="阿谢的BLOG">
<meta property="og:description" content="实验1：启动PC">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/1.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/2.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/3.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/4.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/5.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/6.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/7.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/8.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/9.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/10.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/11.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/12.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/13.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/14.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/15.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/16.JPG">
<meta property="og:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/17.JPG">
<meta property="og:updated_time" content="2019-03-20T10:50:30.643Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 Lab:Booting a PC">
<meta name="twitter:description" content="实验1：启动PC">
<meta name="twitter:image" content="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/1.JPG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/"/>





  <title>MIT 6.828 Lab:Booting a PC | 阿谢的BLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">阿谢的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/Life" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Life
          </a>
        </li>
      
        
        <li class="menu-item menu-item-theory">
          <a href="/Theory" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Theory
          </a>
        </li>
      
        
        <li class="menu-item menu-item-practice">
          <a href="/Practice" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Practice
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/About" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/MIT-6-828-Lab-Booting-a-PC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="123xzy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿谢的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT 6.828 Lab:Booting a PC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-14T21:27:48+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>实验1：启动PC<br><a id="more"></a></p>
<hr>
<p>该实验<a href="https://pdos.csail.mit.edu/6.828/2014/labs/lab1/" target="_blank" rel="noopener">原始指南</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本实验分为三个部分</p>
<ul>
<li>getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstrap procedure</li>
<li>examines the boot loader for our 6.828 kernel</li>
<li>delves into the initial template for our 6.828 kernel itself</li>
</ul>
<h1 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h1><p>介绍x86汇编语言和PC引导程序（PC Bootstrap），并开始使用QEMU和QEMU/GDB调试</p>
<h2 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h2><p>MIT官方为我们提供了一个关于汇编语言的参考资料<a href="https://pdos.csail.mit.edu/6.828/2014/readings/pcasm-book.pdf" target="_blank" rel="noopener">pcasm-book</a>，里面基本介绍了汇编语言的方方面面，你可以把这本书作为一个备查，遇到没看过的命令就上里面查，或者直接上网查。如果没有任何汇编基础，建议还是看一看书，把一些基础的指令看懂</p>
<p>本书中的示例是为NASM汇编程序编写的，而我们将使用GNU汇编程序。NASM使用所谓的Intel语法，而GNU使用AT＆T语法。虽然在语义上是等效的，但是程序集文件会有很大不同，至少表面上看，这取决于使用的语法。幸运的是，两者之间的转换非常简单，并且在<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">汇编指南</a>中有所介绍</p>
<h2 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h2><p><code>Instead of developing the operating system on a real, physical personal computer (PC), we use a program that faithfully emulates a complete PC: the code you write for the emulator will boot on a real PC too. Using an emulator simplifies debugging; you can, for example, set break points inside of the emulated x86, which is difficult to do with the silicon version of an x86.</code></p>
<p>进行该部分需要安装QEMU（<a href="/2019/03/08/MIT-6-828-Lab-Guide/" title="MIT 6.828 Lab:Guide">MIT 6.828 Lab:Guide</a>，该文章中有实验的所有前期准备指南）和熟悉GDB调试（<a href="/2018/03/11/GDB-GCC/" title="GDB GCC">GDB GCC</a>）</p>
<p><code>Everything after &#39;Booting from Hard Disk...&#39; was printed by our skeletal JOS kernel; the K&gt; is the prompt printed by the small monitor, or interactive control program, that we&#39;ve included in the kernel. These lines printed by the kernel will also appear in the regular shell window from which you ran QEMU. This is because for testing and lab grading purposes we have set up the JOS kernel to write its console output not only to the virtual VGA display (as seen in the QEMU window), but also to the simulated PC&#39;s virtual serial port, which QEMU in turn outputs to its own standard output.</code></p>
<p>启动给内核之后，所有字符就是由<code>JOS kernel</code>产生</p>
<p><code>There are only two commands you can give to the kernel monitor, help and kerninfo.</code></p>
<p>现在只有两个命令可以使用：<code>help</code> <code>kerninfo</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/1.JPG" alt="运行截图"></p>
<p><code>Although simple, it&#39;s important to note that this kernel monitor is running &quot;directly&quot; on the &quot;raw (virtual) hardware&quot; of the simulated PC. This means that you should be able to copy the contents of obj/kern/kernel.img onto the first few sectors of a real hard disk, insert that hard disk into a real PC, turn it on, and see exactly the same thing on the PC&#39;s real screen as you did above in the QEMU window</code></p>
<p>虽然该内核还比较简单，但只要愿意，可以将该内核镜像写入硬盘前几个扇区，就能想真正启动PC一样启动它，并能看到完全一样的东西</p>
<h2 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h2><p><code>A PC&#39;s physical address space is hard-wired to have the following general layout:</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/2.JPG" alt="运行截图"></p>
<p>早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为<code>Low memory</code>，这只能被随机存储器(RAM)使用</p>
<p>从<code>0x000A0000</code>到<code>0x000FFFFF</code>的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从<code>0x000F0000</code>到<code>0x000FFFFF</code>占据64KB区域的部分是最重要的<strong>BIOS</strong></p>
<p>现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了<code>0xFFFFFFFF</code>。<code>JOS</code>这里只用开始的256MB，所以假设PC只有32位地址空间</p>
<h2 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h2><p>这部分研究计算机如何<strong>启动</strong></p>
<p>在一个终端中输入<code>make qemu-gdb</code>，这将启动QEMU，但QEMU在处理器执行第一条指令之前停止，并等待来自GDB的调试连接，另一个终端输入<code>make gdb</code><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/3.JPG" alt="运行截图"></p>
<p><code>[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b</code>是GDB反汇编出的第一条执行指令，表明：</p>
<ul>
<li>IBM PC从物理地址<code>0x000ffff0</code>处执行，该地址位于为ROM BIOS保留的64KB区域的最顶端</li>
<li>PC从地址<code>CS=0xf000,IP=0xfff0</code>开始执行</li>
<li>执行的第一条指令是<code>jmp</code>指令，它跳转到分段地址<code>CS = 0xf000,IP=0xe05b</code></li>
</ul>
<p>由于PC中的BIOS与物理地址范围<code>0x000f0000-0x000fffff</code>“硬连线”，因此该设计可确保BIOS在上电或任何系统重启后始终首先控制机器。QEMU仿真器带有自己的BIOS，它放置在处理器的模拟物理地址空间中的位置。当通电后，处理器进入实模式也就是设置<code>CS:IP</code>两个寄存器为<code>CS=0xf000,IP=0xfff0</code>，为什么这个段地址指示的是<code>0x000ffff0</code>？</p>
<p>因为在启动电源也就是实模式时，地址转译根据这个公式工作：<code>物理地址=16 * 段地址+偏移量</code></p>
<p><code>0x000ffff0</code>是BIOS结束前的16个字节（<code>0x100000</code>）</p>
<p>当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取<code>Boot loader</code>并转移控制</p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/4.JPG" alt="运行截图">可以通过GDB<code>si</code>命令一步步猜测BIOS正在做什么！</p>
<h1 id="The-Boot-Loader"><a href="#The-Boot-Loader" class="headerlink" title="The Boot Loader"></a>The Boot Loader</h1><p>PC的软盘和硬盘分为512个字节区域，称为扇区。扇区是磁盘的最小传输粒度：每个读取或写入操作必须是一个或多个扇区，并在扇区边界上对齐。如果磁盘是可引导的，则第一个扇区称为引导扇区，因为这是引导加载程序代码所在的位置。当BIOS找到可引导的软盘或硬盘时，它将512字节的引导扇区加载到物理地址<code>0x7c00</code>到<code>0x7dff</code>的内存中，然后使用jmp指令将<code>CS：IP</code>设置为<code>0000：7c00</code>，将控制权传递给引导装载机</p>
<p>对于6.828，引导加载程序包含一个汇编语言源文件<code>boot/boot.S</code>和一个C源文件<code>boot/main.c</code>，仔细查看这些源文件，确保您了解正在发生的事情</p>
<p>在<code>main.c</code>有以下注释，详细讲述了启动流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span></span><br><span class="line"><span class="comment"> *    be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in boot.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br></pre></td></tr></table></figure></p>
<p>引导加载程序执行两个主要功能：</p>
<ul>
<li>引导加载程序将处理器从实模式切换到32位保护模式，因为只有在此模式下，软件才能访问处理器物理地址空间中1MB以上的所有内存</li>
<li>引导加载程序通过x86的特殊I/O指令直接访问IDE磁盘设备寄存器，从硬盘读取内核</li>
</ul>
<p>在了解了引导加载程序源代码之后，查看文件<code>obj/boot/boot.asm</code>。此文件是我们的<code>GNUmakefile</code>在编译引导加载程序后创建的引导加载程序的反汇编。这个反汇编文件可以很容易地查看所有引导加载程序代码所在的物理内存的确切位置，并且可以更轻松地跟踪在GDB中单步执行引导加载程序时发生的情况。同样，<code>obj/kern/kernel.asm</code>包含一个JOS内核的反汇编，它通常可用于调试</p>
<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><p>在地址0x7c00处设置断点，这是加载引导扇区的位置。继续执行直到该断点。通过跟踪开机代码<code>/boot.S</code>、使用的源代码、反汇编文件<code>OBJ的/boot/boot.asm</code>跟踪你在哪里。还可以使用GDB中的<code>x/i</code>命令来反汇编引导加载程序中的指令序列，并将原始引导加载程序代码与<code>obj/boot/boot.asm</code>和GDB中的反汇编进行比较</p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/5.JPG" alt="运行截图"></p>
<p>跟踪<code>main.c/bootmain()</code>，然后进入<code>readsect()</code> 。确定与<code>readsect()</code>中每个语句对应的精确汇编指令。跟踪<code>readsect()</code>的其余部分并返回到<code>bootmain()</code>，并识别for循环的开始和结束，从磁盘读取内核的剩余扇区。找出循环结束时将运行的代码，在那里设置断点，并继续该断点。然后逐步执行引导加载程序的其余部分</p>
<p>问题：</p>
<ul>
<li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?<br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/6.JPG" alt="运行截图"></li>
<li><p>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return!</span></span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0x10000c</span>:	movw   $<span class="number">0x1234</span>,<span class="number">0x472</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?<br>通过查看ELF信息头查看</p>
</li>
</ul>
<p>回答完这三个命令，我们再好好看一看这几段代码！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// read 1st page off disk</span></span><br><span class="line">        readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// is this a valid ELF?</span></span><br><span class="line">        <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">                <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">        ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">        eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">        <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">                <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">                <span class="comment">// as the physical address)</span></span><br><span class="line">                readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">        <span class="comment">// note: does not return!</span></span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bootmain</code>先读取ELF文件头信息（关于ELF文件，可以查看<a href="/2019/01/07/修养-《目标文件》/" title="《目标文件》">《目标文件》</a>），获取文件大小，然后判断魔数，然后调用<code>readseg</code>函数循环读取扇区内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></span><br><span class="line"><span class="comment">// Might copy more than asked</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">        end_pa = pa + count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round down to sector boundary</span></span><br><span class="line">        pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">        offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">        <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">        <span class="comment">// we load in increasing order.</span></span><br><span class="line">        <span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">                <span class="comment">// Since we haven't enabled paging yet and we're using</span></span><br><span class="line">                <span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">                <span class="comment">// use physical addresses directly.  This won't be the</span></span><br><span class="line">                <span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">                readsect((<span class="keyword">uint8_t</span>*) pa, offset);</span><br><span class="line">                pa += SECTSIZE;</span><br><span class="line">                offset++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有3个参数，第一个是物理地址，第二个是页的大小，第三个是偏移量。函数先计算末尾地址，在根据字节数得出扇区号，最后循环读取扇区内容到内存地址<code>pa</code>处，读完之后，移动内存地址和扇区</p>
<p>数据读取之后，就返回<code>bootmian</code>，进入ELF记录的入口地址，进而由内核来操控。Exercise 3因而结束</p>
<h2 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h2><p>现在，我们将对<code>boot/main.c</code>中的引导加载程序的C语言部分详细介绍</p>
<p>ELF头的C定义在inc / elf.h中。我们感兴趣的计划部分是：</p>
<ul>
<li><code>.text</code>：程序的可执行指令</li>
<li><code>.rodata</code>：只读数据，例如C编译器生成的ASCII字符串常量（但是，我们不会费心设置硬件来禁止写入。）</li>
<li><code>.data</code>：数据部分保存程序的初始化数据，例如使用初始化器（如int x = 5）声明的全局变量</li>
</ul>
<p>通过<code>objdump -h obj/kern/kernel</code>，检查内核可执行文件中所有段的名称，大小和链接地址<img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/7.JPG" alt="运行截图"></p>
<p>请特别注意<code>.text</code>部分的<code>VMA</code>（或链接地址）和<code>LMA</code>（或加载地址） 。段的加载地址是应该将该段加载到内存中的内存地址。段的链接地址是段期望执行的内存地址</p>
<p>通常链接和加载地址是相同的。查看引导加载程序的<code>.text</code>部分：<code>objdump -h obj/boot/boot.out</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/8.JPG" alt="运行截图"></p>
<p>引导加载程序使用ELF 程序头来决定如何加载节。程序头指定要加载到内存中的ELF对象的哪些部分以及每个应占用的目标地址。您可以通过键入以下内容来检查程序标题<code>objdump -x obj/kern/kernel</code><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/9.JPG" alt="运行截图"></p>
<p>程序头在objdump的输出中的<code>Program Headers</code>下列出。需要加载到内存中的ELF对象的区域是标记为<code>LOAD</code>的区域。给出了每个程序头的其他信息，例如虚拟地址<code>vaddr</code>，物理地址<code>paddr</code>和加载区域的大小<code>memsz</code> <code>filesz</code></p>
<p>回到<code>boot/main.c</code>，<code>ph-&gt;p_pa</code>是每个程序头包含的段目的物理地址</p>
<p>BIOS把引导扇区加载到内存地址<code>0x7c00</code>，这也就是引导扇区的加载地址和链接地址。在<code>boot/Makefrag</code>中，是通过传<code>-Ttext 0x7C00</code>这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址</p>
<p>ELF头中还有一个对我们很重要的字段，名为<code>e_entry</code>，该字段保存程序中入口点的链接地址，也就是程序执行的text字段中的内存地址。<code>objdump -f obj/kern/kernel</code></p>
<p>现在应该能够理解<code>boot/ main.c</code>中的最小ELF加载器 。它将内核的每个部分从磁盘读入内存的部分加载地址，然后跳转到内核的入口点</p>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p>阅读Brian Kernighan和Dennis Ritchie编写的<a href="https://github.com/123xzy/K-R" target="_blank" rel="noopener">《C程序设计语言》</a>（称为“K＆R”）中的5.5和5.1，并理解<a href="https://pdos.csail.mit.edu/6.828/2014/labs/lab1/pointers.c" target="_blank" rel="noopener">pointers.c</a></p>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p><code>change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens.</code></p>
<p>修改<code>boot/Makefrag</code>，把引导扇区的加载地址和链接地址从<code>0x7c00</code>改为<code>0x8c00</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/10.JPG" alt="运行截图"></p>
<p>可以发现起始地址从原来的<code>00007c00</code>变为<code>00008c00</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/11.JPG" alt="运行截图"></p>
<p>由于BIOS载入内核后，是跳转到<code>00007c00</code>，显然这样子就无法加载成功<br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/12.JPG" alt="运行截图"></p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p><code>Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</code></p>
<p>使用GDB的<code>x/Nx ADDR</code>可以打印内存地址ADDR的N个字</p>
<p><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/13.JPG" alt="运行截图"></p>
<p>这里很明显是因为内核程序被加载到了0x100000地址处，使用<code>x /8i *0x100000</code>可以反汇编查看内存地址对应的指令，如果去查看<code>kernel</code>的目标文件，会发现两者一致<br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/14.JPG" alt="运行截图"><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/15.JPG" alt="运行截图"></p>
<h1 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h1><p>我们现在将开始更详细地研究JOS内核（最后你会写一些代码！）。与引导加载程序一样，内核以一些汇编语言代码开始，这些代码设置正确，以便C语言代码可以正确执行</p>
<h2 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h2><p>boot loader的链接地址和加载地址是一样的，然而kernel 的链接地址和加载地址有些差异。查看<code>kern/kernel.ld</code>可以发现链接地址在<code>0xF0100000</code>，加载地址为<code>0x100000</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/16.JPG" alt="运行截图"></p>
<p>操作系统内核通常喜欢链接并在非常高的虚拟地址（例如<code>0xf0100000</code>）下运行，以便留下处理器虚拟地址空间的下半部分供用户程序使用</p>
<p>许多机器在地址<code>0xf0100000</code>处没有任何物理内存，因此我们无法指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址<code>0xf0100000</code>（内核代码期望运行的链接地址）映射到物理地址<code>0x00100000</code>（引导加载程序将内核加载到物理内存中）。这样，虽然内核的虚拟地址足够高，可以为用户进程留出足够的地址空间，但它将被加载到PC RAM的1MB点的物理内存中，就在BIOS ROM上方。这种方法要求PC至少有几兆字节的物理内存（因此物理地址<code>0x00100000</code>可以工作）</p>
<p>在下一个实验中，我们将把物理地址<code>0x00000000</code>到<code>0x0fffffff</code>的整个底部256MB的物理地址空间分别映射到虚拟地址<code>0xf0000000</code>到<code>0xffffffff</code>。您现在应该明白为什么JOS只能使用前256MB的物理内存</p>
<p>我们使用<code>kern/entrypgdir.c</code>中手写的、静态初始化的页面目录和页表来完成 映射前4MB的物理内存的操作</p>
<p>如果<code>kern/entry.S</code>中没有设置<code>CR0_PG</code>标志，内存引用被视为物理地址（严格来说，它们是线性地址，但<code>boot/boot.S</code>设置从线性地址到物理地址的身份映射，我们永远不会要改变那个）；如果设置，内存引用就变为虚拟地址，由虚拟内存硬件转换为物理地址的虚拟地址。 <code>entry_pgdir</code>将<code>0xf0000000</code>到<code>0xf0400000</code>范围内的虚拟地址转换为物理地址<code>0x00000000</code>到<code>0x00400000</code>，以及虚拟地址<code>0x00000000</code>到<code>0x00400000</code>到物理地址<code>0x00000000</code>到<code>0x00400000</code>。任何不属于这两个范围之一的虚拟地址都会导致硬件异常，因为我们尚未设置中断处理，将导致QEMU转储机器状态并退出</p>
<h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p><code>Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.
What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren&#39;t in place? Comment out the movl %eax, %cr0 in kern/entry.S, trace into it, and see if you were right.</code></p>
<p>第一部分没能成功，不知道为什么，不管是在<code>movl %eax, %cr0</code>之前还是之后，两个地址的值都是一样的，照理说应该是不一样的。原因就是之前还没有建立分页机制，高地址内核区域还没有映射到内核的物理地址，而只有低地址有效的．开启分页之后，由于有静态映射表的存在(<code>kern/enterpgdir.c</code>)，两块虚拟地址都指向同一块物理地址区域。但是第二阶段却可以完成</p>
<p>在注释掉<code>movl %eax, %cr0</code>，也就是关闭虚拟内存之后，就会出现以下错误，因为物理内存只有<code>0x001002c</code>，无法获取<code>0xf01002c</code><br><img src="/2019/03/14/MIT-6-828-Lab-Booting-a-PC/17.JPG" alt="运行截图"></p>
<h2 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h2><p>大多数人认为像<code>printf()</code>这样的函数是理所当然的，有时甚至认为它们是C语言的“原语”。但在OS内核中，我们必须自己实现所有<code>I/O</code></p>
<p>通读<code>kern/printf.c</code> <code>lib/printfmt.c</code> <code>kern/console.c</code>，确保了解它们之间的关系。在后面的实验中将清楚为什么<code>printfmt.c</code>位于单独的lib目录中</p>
<ul>
<li><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p>
</li>
<li><p>Explain the following from console.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">memcpy</span>(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">                crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.<br>Trace the execution of the following code step-by-step:</p>
</li>
</ul>
<p>int x = 1, y = 3, z = 4;<br>cprintf(“x %d, y %x, z %d\n”, x, y, z);</p>
<p>In the call to cprintf(), to what does fmt point? To what does ap point?<br>List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.</p>
<ul>
<li>Run the following code.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here’s an ASCII table that maps bytes to characters.<br>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</p>
<p>Here’s a description of little- and big-endian and a more whimsical description.</p>
<ul>
<li><p>In the following code, what is going to be printed after ‘y=’? (note: the answer is not a specific value.) Why does this happen?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">"x=%d y=%d"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</p>
</li>
</ul>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p><code>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form &quot;%o&quot;. Find and fill in this code fragment.</code></p>
<h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h3><p><code>Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret ANSI escape sequences embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on the 6.828 reference page and elsewhere on the web on programming the VGA display hardware. If you&#39;re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</code></p>
<h2 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/14/Redis：多机数据库的实现/" rel="next" title="《多机数据库的实现》">
                <i class="fa fa-chevron-left"></i> 《多机数据库的实现》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/15/lab-data/" rel="prev" title="Data">
                Data <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">123xzy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">211</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">79</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/123xzy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xzy-71-59/activities" target="_blank" title="ZhiHu">
                      
                        <i class="fa fa-fw fa-globe"></i>ZhiHu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xzy0320@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PC-Bootstrap"><span class="nav-number">2.</span> <span class="nav-text">PC Bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-Started-with-x86-assembly"><span class="nav-number">2.1.</span> <span class="nav-text">Getting Started with x86 assembly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Simulating-the-x86"><span class="nav-number">2.2.</span> <span class="nav-text">Simulating the x86</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-PC’s-Physical-Address-Space"><span class="nav-number">2.3.</span> <span class="nav-text">The PC’s Physical Address Space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-ROM-BIOS"><span class="nav-number">2.4.</span> <span class="nav-text">The ROM BIOS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Boot-Loader"><span class="nav-number">3.</span> <span class="nav-text">The Boot Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-3"><span class="nav-number">3.1.</span> <span class="nav-text">Exercise 3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loading-the-Kernel"><span class="nav-number">3.2.</span> <span class="nav-text">Loading the Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-4"><span class="nav-number">3.2.1.</span> <span class="nav-text">Exercise 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-5"><span class="nav-number">3.2.2.</span> <span class="nav-text">Exercise 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-6"><span class="nav-number">3.2.3.</span> <span class="nav-text">Exercise 6</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Kernel"><span class="nav-number">4.</span> <span class="nav-text">The Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-virtual-memory-to-work-around-position-dependence"><span class="nav-number">4.1.</span> <span class="nav-text">Using virtual memory to work around position dependence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-7"><span class="nav-number">4.1.1.</span> <span class="nav-text">Exercise 7</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Formatted-Printing-to-the-Console"><span class="nav-number">4.2.</span> <span class="nav-text">Formatted Printing to the Console</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-8"><span class="nav-number">4.2.1.</span> <span class="nav-text">Exercise 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Challenge"><span class="nav-number">4.2.2.</span> <span class="nav-text">Challenge</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Stack"><span class="nav-number">4.3.</span> <span class="nav-text">The Stack</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">123xzy</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  :<span id="busuanzi_value_site_uv"></span>
</span>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
